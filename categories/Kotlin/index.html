
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="欧阳锋工作室">
    <title>分类: Kotlin - 欧阳锋工作室</title>
    <meta name="author" content="欧阳锋工作室">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="关注欧阳锋工作室，你想知道的都在这里~">
<meta property="og:type" content="blog">
<meta property="og:title" content="欧阳锋工作室">
<meta property="og:url" content="http://youngfeng.com/categories/Kotlin/index.html">
<meta property="og:site_name" content="欧阳锋工作室">
<meta property="og:description" content="关注欧阳锋工作室，你想知道的都在这里~">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欧阳锋工作室">
<meta name="twitter:description" content="关注欧阳锋工作室，你想知道的都在这里~">
    
    
        
    
    
        <meta property="og:image" content="http://youngfeng.com/assets/images/avatar.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-n3h5fvwrba2ezx3jjewg1itrl3r4ognmb0rqhxoh9kr7ltfomtbpdedrggqw.min.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            欧阳锋工作室
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">欧阳锋工作室</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Stay hungry, stay foolish</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/yuanhoujun" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/assets/images/mpwexin.jpg"
                            title="微信公众号"
                        >
                    
                        <i class="sidebar-button-icon fab fa-weixin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微信公众号</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://weibo.com/u/6140262139?is_all=1" target="_blank" rel="noopener" title="微博">
                    
                        <i class="sidebar-button-icon fab fa-weibo" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微博</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:ouyangfeng2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/07/09/kotlin/2018最新Kotlin基础视频教程上线了/"
                            aria-label=": 2018最新Kotlin基础视频教程上线了"
                        >
                            2018最新Kotlin基础视频教程上线了
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-09T15:02:00+08:00">
	
		    7月 09, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>从5月份开始制作这个视频，历时两个多月，终于在网易云课堂与大家见面了…</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/9/1647d0644608714d" alt=""></p>
<h3 id="视频特色"><a href="#视频特色" class="headerlink" title="视频特色"></a>视频特色</h3><ul>
<li>在前期课程中，使用普通编辑器进行编码，治疗你的IDE依赖症</li>
<li>所有课程均使用live coding的方式授课，保持与你的频率一致</li>
<li>每节课程课后都准备了相应的习题供大家巩固练习</li>
<li>课程覆盖面广，线下效果持续跟踪</li>
<li>项目实战部分是一个非常有意思的小项目，使用控制台完成类QQ聊天室功能（支持文字消息、文件发送、文件下载等功能）</li>
</ul>
<h3 id="课程目录"><a href="#课程目录" class="headerlink" title="课程目录"></a>课程目录</h3><ul>
<li>Kotlin基础环境配置、变量与空值安全</li>
<li>一等公民函数基础语法</li>
<li>高阶函数、lambda表达式与匿名函数</li>
<li>面向对象知识点（类、接口、继承、扩展等）</li>
<li>Kotlin语言中多样的class类型、对象以及枚举</li>
<li>强大的集合与控制流处理</li>
<li>操作符重载</li>
<li>更安全的泛型处理</li>
<li>代理模式及其应用</li>
<li>协程简介</li>
<li>析构、注解与异常处理</li>
<li>Kotlin与Java互通的那些事儿</li>
<li>控制台版本QQ聊天室项目实战</li>
</ul>
<h3 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h3><p>这是我第一次真正尝试录制视频教程，种种原因，导致整个视频的录制、剪辑加发布审核一共花掉了两个多月，将近三个月。而且还是离职在家，全职的情况下。</p>
<p>即便如此，事实上，这个视频依然没有达到我的要求。但我想，第一次永远是青涩的，想要一步到位永远不过是痴人说梦。我坚信下一个视频我会做的更好。因此，也希望大家对这个视频提出宝贵的意见。</p>
<h3 id="视频介绍看这里"><a href="#视频介绍看这里" class="headerlink" title="视频介绍看这里"></a>视频介绍看这里</h3><p>在Kotlin交流群中，不少同学希望我能够出露脸视频。为了满足大家的愿望，我在课程的开始部分录制了一段真人解说视频。如果你不想看文字介绍的话，请移步到这里：<a href="http://study.163.com/course/courseLearn.htm?courseId=1005686004&amp;share=2&amp;shareId=400000000535034#/learn/video?lessonId=1052950023&amp;courseId=1005686004" target="_blank" rel="noopener">http://study.163.com/course/courseLearn.htm?courseId=1005686004&amp;share=2&amp;shareId=400000000535034#/learn/video?lessonId=1052950023&amp;courseId=1005686004</a></p>
<h3 id="如何观看这个视频教程"><a href="#如何观看这个视频教程" class="headerlink" title="如何观看这个视频教程"></a>如何观看这个视频教程</h3><p>目前，该视频教程仅上线了网易云课堂，同学们可以移步至这里观看：<a href="http://study.163.com/course/introduction.htm?courseId=1005686004&amp;share=2&amp;shareId=400000000535034" target="_blank" rel="noopener">http://study.163.com/course/introduction.htm?courseId=1005686004&amp;share=2&amp;shareId=400000000535034</a></p>
<h3 id="课程问题解惑"><a href="#课程问题解惑" class="headerlink" title="课程问题解惑"></a>课程问题解惑</h3><p>如果你在使用Kotlin视频教程的时候遇到了任何问题，欢迎来我的Kotlin语言交流群里面提问。只要是关于视频课程的内容，一定有问必答。如果你没有购买这个视频教程，也可以添加这个QQ交流群，群里的小伙伴都非常热情。如果遇到了Kotlin语言问题，也可以在群里提问，同样会有问必答。</p>
<h3 id="视频课程资料"><a href="#视频课程资料" class="headerlink" title="视频课程资料"></a>视频课程资料</h3><p>课程源码：<a href="https://github.com/yuanhoujun/kotlin-video-tutorial" target="_blank" rel="noopener">https://github.com/yuanhoujun/kotlin-video-tutorial</a></p>
<p>习题答案：关注微信公众号【欧阳锋工作室】，回复“Kotlin视频教程”索取</p>
<h3 id="Kotlin语言交流群"><a href="#Kotlin语言交流群" class="headerlink" title="Kotlin语言交流群"></a>Kotlin语言交流群</h3><p> 唯一官方Kotlin语言交流群：329673958，期待您的加入。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/07/09/kotlin/2018最新Kotlin基础视频教程上线了/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/"
                            aria-label=": 那些年，我们看不懂的那些Kotlin标准函数"
                        >
                            那些年，我们看不懂的那些Kotlin标准函数
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-27T15:21:00+08:00">
	
		    4月 27, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>Kotlin标准库中提供了一套用于常用操作的函数。最近，在我的Kotlin交流群中有人再次问到了关于这些函数的用法。今天，让我们花一点时间，一起看一下这些函数的用法。</p>
</blockquote>
<h1 id="Ready-go-gt-gt-gt"><a href="#Ready-go-gt-gt-gt" class="headerlink" title="Ready go &gt;&gt;&gt;"></a>Ready go &gt;&gt;&gt;</h1><p><strong>注：这里所说的标准函数主要来自于标准库中在文件Standard.kt中的所有函数。</strong></p>
<h3 id="run-1"><a href="#run-1" class="headerlink" title="run#1"></a>run#1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;R&gt; run(block: () -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>contract部分主要用于编译器上下文推断，这里我们忽略掉这部分代码。</p>
<p>观察源码发现，run方法仅仅是执行传入的block表达式并返回执行结果而已（block是一个lambda表达式）。</p>
<p><strong>因此，如果你仅仅需要执行一个代码块，可以使用该函数</strong></p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val x = run &#123;</span><br><span class="line">           println(&quot;Hello, world&quot;)</span><br><span class="line">           return@run 1</span><br><span class="line">        &#125;</span><br><span class="line">println(x)</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">Hello，world</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="run-2"><a href="#run-2" class="headerlink" title="run#2"></a>run#2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数跟上面的函数功能是完全一样的。不同的是，block的receiver是当前调用对象，即在block中可以使用当前对象的上下文。</p>
<p><strong>因此，如果你需要在执行的lambda表达式中使用当前对象的上下文的话，可以使用该函数。除此之外，两者没有任何差别</strong></p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    fun sayHi(name: String) &#123;</span><br><span class="line">        println(&quot;Hello, $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val a = A()</span><br><span class="line">    val b = a.run &#123;</span><br><span class="line">        // 这里你可以使用A的上下文</span><br><span class="line">        a.sayHi(&quot;Scott Smith&quot;)</span><br><span class="line">        return@run B()</span><br><span class="line">    &#125;</span><br><span class="line">    println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">Hello，Scott Smith</span><br><span class="line">b@2314</span><br></pre></td></tr></table></figure>
<p>从例子中，我们可以看到，这个函数还可以用于对数据类型进行转换。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数其实和run函数也是做了一样的事情。不同的是，这里可以指定block的接收者。</p>
<p><strong>因此，如果你在执行lambda表达式的时候，希望指定不同的接收者的话，可以使用该方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    fun sayHi(name: String) &#123;</span><br><span class="line">        println(&quot;Hello, $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val a = A()</span><br><span class="line">    with(a) &#123;</span><br><span class="line">        // 这里的接收者是对象a，因此可以调用a实例的所有方法</span><br><span class="line">        sayHi(&quot;Scott Smith&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个方法是针对泛型参数的扩展方法，即所有对象都将拥有该扩展方法。相对于run#2方法，apply不仅执行了block，同时还返回了receiver本身。</p>
<p><strong>这在链式编程中很常用，如果你希望执行lambda表达式的同时而不破坏链式编程，可以使用该方法</strong></p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    fun sayHi(name: String) &#123;</span><br><span class="line">        println(&quot;Hello, $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fun other() &#123;</span><br><span class="line">        println(&quot;Other function...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val a = A()</span><br><span class="line">    a.apply &#123; </span><br><span class="line">        println(&quot;This is a block&quot;)</span><br><span class="line">        sayHi(&quot;Scott Smith&quot;)</span><br><span class="line">    &#125;.other()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">This is a block</span><br><span class="line">Hello, Scott Smith</span><br><span class="line">Other function...</span><br></pre></td></tr></table></figure>
<h3 id="also"><a href="#also" class="headerlink" title="also"></a>also</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">@SinceKotlin(&quot;1.1&quot;)</span><br><span class="line">public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(this)</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数跟with又很像，不同的是，block带有一个当前receiver类型的参数。在block中，你可以使用该参数对当前实例进行操作。</p>
<p><strong>这个函数和with完全可以互相通用，with函数可以直接在当前实例上下文中对其进行操作，而also函数要通过block参数获取当前类实例。因为用法完全一致，这里就不举例了</strong></p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return block(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用过RxJava，可能会感到似曾相识，这其实就是RxJava的map函数。这个函数也是针对泛型参数的扩展函数，所有类都将拥有这个扩展函数。</p>
<p><strong>如果你希望对当前数据类型进行一定的转换，可以使用该方法。该方法的block中同样可以使用当前receiver的上下文</strong></p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Triangle &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle &#123;&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val tr = Triangle()</span><br><span class="line">    val rect = tr.let &#123; it -&gt;</span><br><span class="line">        println(&quot;It is $it&quot;)</span><br><span class="line">        return@let Rectangle()</span><br><span class="line">    &#125;</span><br><span class="line">    println(rect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">It is Triangle@78308db1</span><br><span class="line">Rectangle@27c170f0</span><br></pre></td></tr></table></figure>
<p>从例子中可以看到，我们成功地将三角形转换成了矩形，这就是let函数的作用。</p>
<h3 id="takeIf"><a href="#takeIf" class="headerlink" title="takeIf"></a>takeIf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">@SinceKotlin(&quot;1.1&quot;)</span><br><span class="line">public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return if (predicate(this)) this else null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数也是针对泛型参数的扩展函数，所有类都将拥有这个扩展。这个函数使用了一个预言函数作为参数，主要用于判断当前对象是否符合条件。<br>这个条件函数由你指定。如果条件符合，将返回当前对象。否则返回空值。</p>
<p><strong>因此，如果你希望筛选集合中某个数据是否符合要求，可以使用这个函数</strong></p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val arr = listOf(1, 2, 3)</span><br><span class="line">    arr.forEach &#123;</span><br><span class="line">        println(&quot;$it % 2 == 0 =&gt; $&#123;it.takeIf &#123; it % 2 == 0 &#125;&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">1 % 2 == 0 =&gt; null</span><br><span class="line">2 % 2 == 0 =&gt; 2</span><br><span class="line">3 % 2 == 0 =&gt; null</span><br></pre></td></tr></table></figure>
<h3 id="takeUnless"><a href="#takeUnless" class="headerlink" title="takeUnless"></a>takeUnless</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">@SinceKotlin(&quot;1.1&quot;)</span><br><span class="line">public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return if (!predicate(this)) this else null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数刚好与takeIf筛选逻辑恰好相反。即：如果符合条件返回null，不符合条件返回对象本身。</p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val arr = listOf(1, 2, 3)</span><br><span class="line">    arr.forEach &#123;</span><br><span class="line">        println(&quot;$it % 2 == 0 =&gt; $&#123;it.takeUnless &#123; it % 2 == 0 &#125;&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">1 % 2 == 0 =&gt; 1</span><br><span class="line">2 % 2 == 0 =&gt; null</span><br><span class="line">3 % 2 == 0 =&gt; 3</span><br></pre></td></tr></table></figure>
<p>看到了吗？这里的执行结果和takeIf恰好相反。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun repeat(times: Int, action: (Int) -&gt; Unit) &#123;</span><br><span class="line">    contract &#123; callsInPlace(action) &#125;</span><br><span class="line"></span><br><span class="line">    for (index in 0 until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数意思很明显，就是将一个动作重复指定的次数。动作对应一个lambda表达式，表达式中持有一个参数表示当前正在执行的次数索引。</p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    repeat(3) &#123;</span><br><span class="line">        println(&quot;Just repeat, index: $it&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Just repeat, index: 0</span><br><span class="line">Just repeat, index: 1</span><br><span class="line">Just repeat, index: 2</span><br></pre></td></tr></table></figure>
<h1 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h1><p>最后，我们用一个表格简单总结一下这些函数的用法：<br>函数|用途|特点|形式<br>:—:|:—:|:—:|:—:<br>run#1|执行block，并返回执行结果|block中无法获取接收者上下文|全局函数<br>run#2|执行block，并返回执行结果|block中可以获取接收者上下文|扩展函数<br>with|指定接收者，通过接收者执行block|block中可以获取接收者的上下文，可以对接收者数据类型做一定转换|全局函数<br>apply|执行block，并返回接收者实例本身|block中可以获取接收者的上下文，可用于链式编程|扩展<br>also|执行block，并返回接收者实例本身|block中有一个参数代表接收者实例，可用于链式编程|扩展<br>let|执行block，并返回执行结果|block中有一个参数代表接收者实例，可以对接收者数据类型做一定转换|扩展<br>takeIf|根据条件predicate判断当前实例是否符合要求|如果符合要求，返回当前实例本身；否则返回null|扩展函数<br>takeUnless|根据条件predicate判断当前实例是否不符合要求|如果不符合要求，返回当前实例本身；否则返回null|扩展</p>
<h1 id="搞定Receiver"><a href="#搞定Receiver" class="headerlink" title="搞定Receiver"></a>搞定Receiver</h1><p>理解上面这几个函数，最重要的一点是要理解Receiver。遗憾的是，Kotlin官方文档中并没有针对Receiver的详细讲解。关于这部分的讲解，请扫描下方二维码关注<strong>欧阳锋工作室</strong>，回复<strong>搞定Receiver</strong>查看文章。</p>
<h1 id="欢迎加入Kotlin交流群"><a href="#欢迎加入Kotlin交流群" class="headerlink" title="欢迎加入Kotlin交流群"></a>欢迎加入Kotlin交流群</h1><p>关于Kotlin，如果你有任何问题，欢迎加入我的Kotlin交流群： 329673958。当前群交流活跃，问题解答速度很快，期待你的加入。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/04/27/kotlin/测测你的Kotlin基础/"
                            aria-label=": 测测你的Kotlin基础"
                        >
                            测测你的Kotlin基础
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-27T15:09:00+08:00">
	
		    4月 27, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fabff1c2028ae?w=2250&amp;h=500&amp;f=png&amp;s=60530" alt="文 | 欧阳锋"></p>
<blockquote>
<p>本次测试满分160分，测测看，你能拿几分 &lt;&lt;&lt;</p>
</blockquote>
<h4 id="1）Kotlin语言有基本数据类型吗？（5分）"><a href="#1）Kotlin语言有基本数据类型吗？（5分）" class="headerlink" title="1）Kotlin语言有基本数据类型吗？（5分）"></a>1）Kotlin语言有基本数据类型吗？（5分）</h4><h4 id="2）Kotlin中有哪些访问控制符，分别代表什么意思？默认访问控制符是什么？（5分）"><a href="#2）Kotlin中有哪些访问控制符，分别代表什么意思？默认访问控制符是什么？（5分）" class="headerlink" title="2）Kotlin中有哪些访问控制符，分别代表什么意思？默认访问控制符是什么？（5分）"></a>2）Kotlin中有哪些访问控制符，分别代表什么意思？默认访问控制符是什么？（5分）</h4><h4 id="3）Kotlin接口是否允许有方法实现？是否允许声明成员变量？（5分）"><a href="#3）Kotlin接口是否允许有方法实现？是否允许声明成员变量？（5分）" class="headerlink" title="3）Kotlin接口是否允许有方法实现？是否允许声明成员变量？（5分）"></a>3）Kotlin接口是否允许有方法实现？是否允许声明成员变量？（5分）</h4><h4 id="4）Sealed类有什么作用？（5分）"><a href="#4）Sealed类有什么作用？（5分）" class="headerlink" title="4）Sealed类有什么作用？（5分）"></a>4）Sealed类有什么作用？（5分）</h4><h4 id="5）Kotlin语言中如何实现类似Java创建匿名内部类对象？（10分）"><a href="#5）Kotlin语言中如何实现类似Java创建匿名内部类对象？（10分）" class="headerlink" title="5）Kotlin语言中如何实现类似Java创建匿名内部类对象？（10分）"></a>5）Kotlin语言中如何实现类似Java创建匿名内部类对象？（10分）</h4><h4 id="6）Kotlin的扩展相对继承有什么优势？扩展方法的执行是否也遵循多态？（10分）"><a href="#6）Kotlin的扩展相对继承有什么优势？扩展方法的执行是否也遵循多态？（10分）" class="headerlink" title="6）Kotlin的扩展相对继承有什么优势？扩展方法的执行是否也遵循多态？（10分）"></a>6）Kotlin的扩展相对继承有什么优势？扩展方法的执行是否也遵循多态？（10分）</h4><h4 id="7）如果一个类同时实现多个接口，接口中存在同名方法，如何解决冲突？（5分）"><a href="#7）如果一个类同时实现多个接口，接口中存在同名方法，如何解决冲突？（5分）" class="headerlink" title="7）如果一个类同时实现多个接口，接口中存在同名方法，如何解决冲突？（5分）"></a>7）如果一个类同时实现多个接口，接口中存在同名方法，如何解决冲突？（5分）</h4><h4 id="8）Kotlin语言中是否存在static关键字，如果没有，如何声明静态变量，并实现与Java互通（5分）"><a href="#8）Kotlin语言中是否存在static关键字，如果没有，如何声明静态变量，并实现与Java互通（5分）" class="headerlink" title="8）Kotlin语言中是否存在static关键字，如果没有，如何声明静态变量，并实现与Java互通（5分）"></a>8）Kotlin语言中是否存在static关键字，如果没有，如何声明静态变量，并实现与Java互通（5分）</h4><h4 id="9）使用Kotlin语言是否一定不会出现空指针异常？为什么？（10分）"><a href="#9）使用Kotlin语言是否一定不会出现空指针异常？为什么？（10分）" class="headerlink" title="9）使用Kotlin语言是否一定不会出现空指针异常？为什么？（10分）"></a>9）使用Kotlin语言是否一定不会出现空指针异常？为什么？（10分）</h4><h4 id="10）Kotlin语言中推荐使用什么方式判断两个对象是否相等？如何判断两个对象是同一个对象？（5分）"><a href="#10）Kotlin语言中推荐使用什么方式判断两个对象是否相等？如何判断两个对象是同一个对象？（5分）" class="headerlink" title="10）Kotlin语言中推荐使用什么方式判断两个对象是否相等？如何判断两个对象是同一个对象？（5分）"></a>10）Kotlin语言中推荐使用什么方式判断两个对象是否相等？如何判断两个对象是同一个对象？（5分）</h4><h4 id="11）如果使用Foo-lt-out-T-TUpper-gt-这种方式声明泛型，使用Foo-lt-gt-这种方式接收该对象实例，代表什么意思？如何理解Kotlin泛型，与Java有什么区别？（10分）"><a href="#11）如果使用Foo-lt-out-T-TUpper-gt-这种方式声明泛型，使用Foo-lt-gt-这种方式接收该对象实例，代表什么意思？如何理解Kotlin泛型，与Java有什么区别？（10分）" class="headerlink" title="11）如果使用Foo&lt;out T: TUpper&gt;这种方式声明泛型，使用Foo&lt;*&gt;这种方式接收该对象实例，代表什么意思？如何理解Kotlin泛型，与Java有什么区别？（10分）"></a>11）如果使用<code>Foo&lt;out T: TUpper&gt;</code>这种方式声明泛型，使用<code>Foo&lt;*&gt;</code>这种方式接收该对象实例，代表什么意思？如何理解Kotlin泛型，与Java有什么区别？（10分）</h4><h4 id="12）如何自定义setter-getter方法？（5分）"><a href="#12）如何自定义setter-getter方法？（5分）" class="headerlink" title="12）如何自定义setter/getter方法？（5分）"></a>12）如何自定义setter/getter方法？（5分）</h4><h4 id="13）使用语句var-x-null声明变量x是否合法？如果合法，x的具体类型是什么？-5分"><a href="#13）使用语句var-x-null声明变量x是否合法？如果合法，x的具体类型是什么？-5分" class="headerlink" title="13）使用语句var x = null声明变量x是否合法？如果合法，x的具体类型是什么？(5分)"></a>13）使用语句<code>var x = null</code>声明变量x是否合法？如果合法，x的具体类型是什么？(5分)</h4><h4 id="14）下面这段代码的输出结果是什么？（10分）"><a href="#14）下面这段代码的输出结果是什么？（10分）" class="headerlink" title="14）下面这段代码的输出结果是什么？（10分）"></a>14）下面这段代码的输出结果是什么？（10分）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val list = listOf(1, 2, 3)</span><br><span class="line">list.add(4)</span><br><span class="line">println(list)</span><br></pre></td></tr></table></figure>
<h4 id="15）下面这段代码的执行结果是什么？（5分）"><a href="#15）下面这段代码的执行结果是什么？（5分）" class="headerlink" title="15）下面这段代码的执行结果是什么？（5分）"></a>15）下面这段代码的执行结果是什么？（5分）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Kotlin端</span><br><span class="line">object A &#123;</span><br><span class="line">    fun init() &#123;</span><br><span class="line">        println(&quot;A init&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Java端</span><br><span class="line">A.init()</span><br></pre></td></tr></table></figure>
<h4 id="16）下面代码的执行结果是什么？（5分）"><a href="#16）下面代码的执行结果是什么？（5分）" class="headerlink" title="16）下面代码的执行结果是什么？（5分）"></a>16）下面代码的执行结果是什么？（5分）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a: Int, b: Int) = &#123; a + b &#125;</span><br><span class="line"></span><br><span class="line">println(sum(1, 3))</span><br></pre></td></tr></table></figure>
<h4 id="17）下面代码的执行结果是什么？（5分）"><a href="#17）下面代码的执行结果是什么？（5分）" class="headerlink" title="17）下面代码的执行结果是什么？（5分）"></a>17）下面代码的执行结果是什么？（5分）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(null is Any)</span><br><span class="line">println(null!! is Nothing)</span><br></pre></td></tr></table></figure>
<h4 id="18）下面代码的执行结果是什么？（10分）"><a href="#18）下面代码的执行结果是什么？（10分）" class="headerlink" title="18）下面代码的执行结果是什么？（10分）"></a>18）下面代码的执行结果是什么？（10分）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    val a = &quot;a&quot;</span><br><span class="line">    </span><br><span class="line">    fun f() &#123;</span><br><span class="line">        println(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    A()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19）下面代码的执行结果是什么？（10分）"><a href="#19）下面代码的执行结果是什么？（10分）" class="headerlink" title="19）下面代码的执行结果是什么？（10分）"></a>19）下面代码的执行结果是什么？（10分）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(127 as Int? === 127 as Int?)</span><br><span class="line">println(128 as Int? === 128 as Int?)</span><br></pre></td></tr></table></figure>
<h4 id="20）下面代码的执行结果是什么？如果运行异常，应该怎样修改才能达到预期效果？（10分）"><a href="#20）下面代码的执行结果是什么？如果运行异常，应该怎样修改才能达到预期效果？（10分）" class="headerlink" title="20）下面代码的执行结果是什么？如果运行异常，应该怎样修改才能达到预期效果？（10分）"></a>20）下面代码的执行结果是什么？如果运行异常，应该怎样修改才能达到预期效果？（10分）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1..5).forEach &#123;</span><br><span class="line">   if (it == 3) break</span><br><span class="line">   println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="21）下面代码的执行结果是什么？如果运行异常，应该怎样修改，为什么要这样修改？（10分）"><a href="#21）下面代码的执行结果是什么？如果运行异常，应该怎样修改，为什么要这样修改？（10分）" class="headerlink" title="21）下面代码的执行结果是什么？如果运行异常，应该怎样修改，为什么要这样修改？（10分）"></a>21）下面代码的执行结果是什么？如果运行异常，应该怎样修改，为什么要这样修改？（10分）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val A.x: Int = 3</span><br><span class="line"></span><br><span class="line">println(A().x)</span><br></pre></td></tr></table></figure>
<h4 id="22）下面这段代码的执行结果是什么？（10分）"><a href="#22）下面这段代码的执行结果是什么？（10分）" class="headerlink" title="22）下面这段代码的执行结果是什么？（10分）"></a>22）下面这段代码的执行结果是什么？（10分）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun isOdd(x: Int) = x % 2 != 0</span><br><span class="line"></span><br><span class="line">fun length(s: String) = s.length</span><br><span class="line"></span><br><span class="line">fun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B): (A) -&gt; C &#123;</span><br><span class="line">    return &#123; x -&gt; f(g(x)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val oddLength = compose(::isOdd, ::length)</span><br><span class="line">    val strings = listOf(&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;)</span><br><span class="line">    println(strings.filter(oddLength))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：本篇例子Kotlin版本为1.2.31，更新版本可能存在部分差异</strong></p>
<h4 id="下面是你的基础等级："><a href="#下面是你的基础等级：" class="headerlink" title="下面是你的基础等级："></a>下面是你的基础等级：</h4><table>
<thead>
<tr>
<th style="text-align:center">得分</th>
<th style="text-align:center">评价</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0 ~ 80</td>
<td style="text-align:center">基础较差</td>
</tr>
<tr>
<td style="text-align:center">80 ~ 108</td>
<td style="text-align:center">基础较好</td>
</tr>
<tr>
<td style="text-align:center">108 ~ 160</td>
<td style="text-align:center">基础很棒</td>
</tr>
</tbody>
</table>
<h1 id="查看答案方法"><a href="#查看答案方法" class="headerlink" title="查看答案方法"></a>查看答案方法</h1><p>微信扫描下方二维码关注<strong>欧阳锋工作室</strong>，回复“Kotlin测试题答案”即可获取当前测试题答案</p>
<h1 id="欢迎加入Kotlin交流群"><a href="#欢迎加入Kotlin交流群" class="headerlink" title="欢迎加入Kotlin交流群"></a>欢迎加入Kotlin交流群</h1><p>如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/04/27/kotlin/测测你的Kotlin基础/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/04/27/kotlin/关于Kotlin抛弃可检测的异常处理，你怎么看？/"
                            aria-label=": 关于Kotlin抛弃可检测的异常处理，你怎么看？"
                        >
                            关于Kotlin抛弃可检测的异常处理，你怎么看？
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-27T14:57:00+08:00">
	
		    4月 27, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>可检测的异常英文翻译为<strong>Checked Exception</strong>，以下简称为CE。CE是一个备受争议的话题，有人主张CE是一个不可或缺的特性，也有人认为CE带来了一些问题，是一个冗余特性。这其中的支持者和反对者中都不乏软件行业的大佬。今天，我们借助这篇文章一起来讨论一下CE存在的必要性。</p>
</blockquote>
<h1 id="什么是CE"><a href="#什么是CE" class="headerlink" title="什么是CE"></a>什么是CE</h1><p>部分同学可能还不知道CE到底是什么。因此，在开始命题之前，有必要给大家解释一下CE的概念。</p>
<p>CE其实你每天都在用，只是你不知道它的存在而已。看一个例子你就明白了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void readString() throws IOException, FileNotFoundException &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数声明的最后面，我们指定了函数可能抛出的异常，在使用的时候我们就可以针对具体的异常使用<code>try {} catch() {}</code>进行处理了。</p>
<p>由于我们在方法声明中指定了可能抛出的异常，因此方法具体可能抛出的异常是已知的，这就称之为可检测的异常（CE）。由于CE的声明来自编译阶段，因此IDE可能帮助你智能判断强制你针对某些异常进行处理，并给出友好提示。</p>
<p>这是一个很好的特性，不是吗？</p>
<p>想象一下，如果有一天，我们不能在函数上指定可抛出的异常了，会怎样？我们无法确定函数可能抛出的异常，并且可能会因为没有正确处理某个异常而导致程序奔溃。</p>
<p>可是，就是有人认为CE多此一举，并且Kotlin语言就是其中的支持者。为什么会有人坚定地认为CE多此一举呢？这是下一个我们要讨论的话题。</p>
<h1 id="关于CE的争论"><a href="#关于CE的争论" class="headerlink" title="关于CE的争论"></a>关于CE的争论</h1><p>Java语言的CE设计借鉴了C++，而在受到Java影响的那些语言中，例如C#、Ruby等都去掉了CE的设计，这从实践的角度证明CE的存在确实意义不大。</p>
<p>在这个问题中，C#的主导工程师Anders Hejlsberg最有发言权。老实说，笔者并没有用过C#。可是，如果你搜索一下网络上关于C#和Java对比的文章你就会发现：C#被认为是一门比Java更优秀的编程语言，它始终在新增一些现代语言的特性，使你毫不费力地使用它。而Java作为一门古老的语言，受限于一些原始设计，在增加新特性时总是步履维艰，甚至有点不伦不类。</p>
<p>关于CE的设计，有人对Anders Hejlsberg进行过一次采访。采访的原文链接在这里：<a href="https://www.artima.com/intv/handcuffs.html" target="_blank" rel="noopener">https://www.artima.com/intv/handcuffs.html</a></p>
<p>关于CE，Anders Hejlsberg认为它带来了两个问题<strong>版本问题</strong>和<strong>扩展问题</strong>。</p>
<p>所谓的版本问题是什么意思呢？Anders Hejlsberg举了一个例子：</p>
<blockquote>
<p>假设有一个方法foo，它声明了抛出异常A、B和C，在下一个版本设计的时候，foo增加了一个新的特性，可能会抛出异常D。对于设计者来说，很明显这是一个大的改变，几乎可以确定的是，客户程序员不会去处理这个异常。为了避免出现问题，设计者不得不声明一个新的方法foo2，抛出一个新的异常。然后，客户程序员可以将针对foo的逻辑处理切换到foo2。</p>
</blockquote>
<p>而所谓的扩展问题又是什么意思呢？这更好理解，以下来自Anders Hejlsberg的原话翻译并整理：</p>
<blockquote>
<p>如果你在设计一个很小的系统，声明一个方法抛出一个异常，这很棒。可是，如果你尝试构建一个大的系统，其中包含了四、五个小系统的时候，问题来了。假设每个子系统可能抛出四到五个异常，而每上升一个系统，就犹如爬阶梯，异常数量会指数倍增加，最终你可能处理的异常将达到40个甚至80个。很显然，这是一个很糟糕的设计！</p>
</blockquote>
<p>Anders Hejlsberg的话有理有据。可是，中国的 <a href="https://baike.baidu.com/item/%E7%8E%8B%E5%9E%A0/6826943?fr=aladdin" target="_blank" rel="noopener">王垠</a> 并不同意这个观点。关于Kotlin的CE设计，他写了一篇文章专门讲了这个问题，文章的原稿在这里：<a href="http://www.yinwang.org/blog-cn/2017/05/23/kotlin" target="_blank" rel="noopener">Kotlin 和 Checked Exception
</a></p>
<p>看完王垠的文章，你会发现，他并不赞同Anders Hejlsberg的话。他认为，所谓的版本问题和扩展问题，其实都来自于程序员的滥用。只要处理得当，CE带来的好处是无法取代的。</p>
<p>其实，关于CE的争论还远不止Anders Hejlsberg和王垠两人。互联网上有很多关于这个问题的讨论。如果你感兴趣，可以Google了解一下。</p>
<h1 id="你怎么看？"><a href="#你怎么看？" class="headerlink" title="你怎么看？"></a>你怎么看？</h1><p>很显然，Kotlin语言受到了C#设计的影响，手起刀落，去掉了CE的设计。对于客户程序员来说，显而易见的一个改变是，你再也不能在Kotlin的方法声明中指定可能抛出的异常了。对于Kotlin语言的这种设计，你是赞成还是反对呢？</p>
<h1 id="欢迎参与投票讨论"><a href="#欢迎参与投票讨论" class="headerlink" title="欢迎参与投票讨论"></a>欢迎参与投票讨论</h1><p>扫描下方二维码关注<strong>欧阳锋工作室</strong>，回复“CE”参与投票，或在所有文章中选择同名文章进行投票。</p>
<h1 id="欢迎加入Kotlin交流群"><a href="#欢迎加入Kotlin交流群" class="headerlink" title="欢迎加入Kotlin交流群"></a>欢迎加入Kotlin交流群</h1><p>如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/04/27/kotlin/关于Kotlin抛弃可检测的异常处理，你怎么看？/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/04/17/kotlin/Kotlin语言中的泛型设计哲学/"
                            aria-label=": Kotlin语言中的泛型设计哲学"
                        >
                            Kotlin语言中的泛型设计哲学
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-17T23:16:00+08:00">
	
		    4月 17, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="https://upload-images.jianshu.io/upload_images/703764-912c5c8fce46d69d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文 | 欧阳锋"></p>
<blockquote>
<p>Kotlin语言的泛型设计很有意思，但并不容易看懂。关于这个部分的官方文档，我反复看了好几次，终于弄明白Kotlin语言泛型设计的背后哲学。这篇文章将讲述Kotlin泛型设计的整个思考过程及其背后的哲学思想，希望可以解答你心中的疑问。不过，可以预见地，即使看完，你也未必完全明白这篇文章在说什么，但至少希望你通过这篇文章可以快速掌握Kotlin泛型的用法。</p>
</blockquote>
<h2 id="Kotlin泛型的设计初衷"><a href="#Kotlin泛型的设计初衷" class="headerlink" title="Kotlin泛型的设计初衷"></a>Kotlin泛型的设计初衷</h2><p>我们认为，Kotlin是一门比Java更优秀的JVM编程语言，Kotlin泛型设计的初衷就是为了解决Java泛型设计中一些不合理的问题。这样说可能不够直观，看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;String&gt; strs = new ArrayList&lt;&gt;();</span><br><span class="line">// 这里将导致编译错误，Java语言不允许这样做</span><br><span class="line"> List&lt;Object&gt; objs = strs;</span><br></pre></td></tr></table></figure>
<p>很明显，String和Object之间存在着安全的隐式转换关系。存放字符串的集合应该可以自由转换为对象集合。这很合理，不是吗？</p>
<p>如果你这样认为的话，就错了！继续往下看，我们扩展这个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strs = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; objs = strs;</span><br><span class="line">objs.add(1);</span><br><span class="line"></span><br><span class="line">String s = strs.get(0);</span><br></pre></td></tr></table></figure>
<p>很明显，这不合理！我们在第一个位置存入了整型数值1，却在取的时候将它当成了字符串。strs本身是一个字符串集合，用字符串接收读取的数据的逻辑是合理的。却因为错误的类型转换导致了不安全写入出现了运行时类型转换问题，因此，Java语言不允许我们这样做。</p>
<p>大多数情况下，这种限制没有问题。可是，在某些情况下，这并不合理。看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface List&lt;T&gt; &#123;</span><br><span class="line">    void addAll(List&lt;T&gt; t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void copy(List&lt;String&gt; from, List&lt;Object&gt; to) &#123;</span><br><span class="line">   to.addAll(from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个类型绝对安全的操作，但在Java语言中这依然是不允许的。原因是，泛型是一个编译期特性，一旦指定，运行期类型就已经固定了。换而言之，泛型操作的类型是不可变的。这就意味着，List<string>并不是List<object>的子类型。</object></string></p>
<p>为了允许正确执行上述操作，Java语言增加了神奇的通配符操作魔法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface List&lt;T&gt; &#123;</span><br><span class="line">  void addAll(List&lt;? extends T&gt; t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>? extends T</strong>意味着集合中允许添加的类型不仅仅是T还包括T的子类，但这个集合中可以添加的类型在集合参数传入addAll时就已经确定了。因此，这并不影响参数集合中可以存放的数据类型，它带来的一个直接影响就是addAll方法参数中终于可以传入泛型参数是T或者T的子类的集合了，即上面的copy方法将不再报错。</p>
<p>这很有意思，在使用通配符之前我们并不能传入类型参数为子类型的集合。使用通配符之后，居然可以了！这个特性在C#被称之为<strong>协变</strong>（covariant）。</p>
<p><strong>协变</strong>这个词来源于类型之间的绑定。以集合为例，假设有两个集合L1、L2分别绑定数据类型F、C，并且F、C之间存在着父子关系，即F、C之间存在着一种安全的从<strong>C-&gt;F</strong>的隐式转换关系。那么，集合L1和L2之间是否也存在着<strong>L2-&gt;L1</strong>的转换关系呢？这就牵扯到了原始类型转换到绑定类型的集合之间的转换映射关系，我们称之为“可变性”。如果原始类型转换和绑定类型之间转换的方向相同，就称之为“协变”。</p>
<p>用一句话总结<strong>协变</strong>：如果绑定对象和原始对象之间存在着相同方向的转换关系，即称之为<strong>协变</strong>。</p>
<p>PS：以上关于<strong>协变</strong>的概念来自笔者的总结，更严谨的概念请参考<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/covariance-contravariance/index" target="_blank" rel="noopener">C#官方文档</a>。</p>
<p>文章开头我们将不可变泛型通过通配符使其成为了可变泛型参数，现在我们知道这种行为叫做<strong>协变</strong>。很明显，<strong>协变</strong>转换中写入是不安全的。因此，<strong>协变</strong>行为仅仅用于读取。如果需要写入怎么办呢？这就牵扯到了另外一个概念<strong>逆变</strong>（contravariance）。</p>
<p><strong>逆变</strong>与<strong>协变</strong>恰恰相反，即如果F、C之间存在着父子转换关系，L1、L2之间存在着从<strong>L1-&gt;L2</strong>的转换关系。其绑定对象的转换关系与原始对象的转换关系恰好相反。Java语言使用关键字super（？super List）实现<strong>逆变</strong>。</p>
<p>举个例子：假设有一个集合List&lt;? super String&gt;，你将可以安全地使用add(String)或set(Int，String)方法。但你不能通过get(Int)返回String对象，因为你无法确定返回的对象是否是String类型，你最终只能得到Object。</p>
<p>因此，我们认为，<strong>逆变</strong>可以安全地写入数据，但并不能安全地读取，即最终不能获取具体的对象数据类型。</p>
<p>为了简化理解，我们引入官方文档中 <a href="https://baike.baidu.com/item/Josh%20Bloch" target="_blank" rel="noopener">Joshua Bloch</a> 说的一句话：</p>
<blockquote>
<p>Joshua Bloch calls those objects you only read from Producers, and those you only write to Consumers. He recommends: “For maximum flexibility, use wildcard types on input parameters that represent producers or consumers”</p>
</blockquote>
<p>Joshua Bloch是Java集合框架的创始人，他把那些只能读取的对象叫做生产者；只能写入的对象叫做消费者。为了保证最大灵活性，他推荐在那些代表了生产者和消费者的输入参数上使用通配符指定泛型。</p>
<p>相对于Java的通配符，Kotlin语言针对<strong>协变</strong>和<strong>逆变</strong>引入两个新的关键词<strong>out</strong>和<strong>in</strong>。</p>
<p><strong>out</strong>用于<strong>协变</strong>，是只读的，属于生产者，即用在方法的返回值位置。而<strong>in</strong>用于<strong>逆变</strong>，是只写的，属于消费者，即用在方法的参数位置。</p>
<p>用英文简记为：<strong>POCI</strong> = Producer Out , Consumer In。</p>
<p>如果一个类中只有生产者，我们就可以在类头使用out声明该类是对泛型参数T<strong>协变</strong>的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Link&lt;out T&gt; &#123;</span><br><span class="line">    fun node(): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样地，如果一个类中只有消费者，我们就可以在类头使用in声明该类是对泛型参数T<strong>逆变</strong>的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Repo&lt;in T&gt; &#123;</span><br><span class="line">    fun add(t: T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>out</strong>等价于Java端的<strong>? extends List</strong>通配符，而<strong>in</strong>等价于Java端的<strong>? super List</strong>通配符。因此，类似下面的转换是合理的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Link&lt;out T&gt; &#123;</span><br><span class="line">    fun node(): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun f1(linkStr: Link&lt;String&gt;) &#123;</span><br><span class="line">    // 这是一个合理的协变转换</span><br><span class="line">    val linkAny: Link&lt;Any&gt; = linkStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Repo&lt;in T&gt; &#123;</span><br><span class="line">    fun add(t: T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun f2(repoAny: Repo&lt;Any&gt;) &#123;</span><br><span class="line">    // 这是一个合理的逆变转换</span><br><span class="line">    val repoStr: Repo&lt;String&gt; = repoAny</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结：协变和逆变"><a href="#小结：协变和逆变" class="headerlink" title="小结：协变和逆变"></a>小结：协变和逆变</h2><p><strong>协变</strong>和<strong>逆变</strong>对于Java程序员来说是一个全新的概念，为了便于理解，我用一个表格做一个简单的总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">协变</th>
<th style="text-align:center">逆变</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">关键字</td>
<td style="text-align:center">out</td>
<td style="text-align:center">in</td>
</tr>
<tr>
<td style="text-align:center">读写</td>
<td style="text-align:center">只读</td>
<td style="text-align:center">可写</td>
</tr>
<tr>
<td style="text-align:center">位置</td>
<td style="text-align:center">返回值</td>
<td style="text-align:center">参数</td>
</tr>
<tr>
<td style="text-align:center">角色</td>
<td style="text-align:center">生产者</td>
<td style="text-align:center">消费者</td>
</tr>
</tbody>
</table>
<h2 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h2><p>在上面的例子中，我们直接在类体声明了泛型参数的协变或逆变类型。在这种情况下，就严格限制了该类中只允许出现该泛型参数的消费者或者生产者。很显然，这种场景并不多见，大多数情况下，一个类中既存在着消费者又存在着生产者。为了适应这种场景，我们可以将协变或逆变声明写在方法参数中。Kotlin官方将这种方式叫做 <a href="https://kotlinlang.org/docs/reference/generics.html#use-site-variance-type-projections" target="_blank" rel="noopener">类型投影（Type Projection）</a>。</p>
<p>这里我们直接使用官方文档的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Array&lt;T&gt;(val size: Int) &#123;</span><br><span class="line">    fun get(index: Int): T &#123; /* ... */ &#125;</span><br><span class="line">    fun set(index: Int, value: T) &#123; /* ... */ &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun copy(from: Array&lt;Any&gt;, to: Array&lt;Any&gt;) &#123;</span><br><span class="line">    assert(from.size == to.size)</span><br><span class="line">    for (i in from.indices)</span><br><span class="line">        to[i] = from[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val ints: Array&lt;Int&gt; = arrayOf(1, 2, 3)</span><br><span class="line">val any = Array&lt;Any&gt;(3) &#123; &quot;&quot; &#125; </span><br><span class="line"></span><br><span class="line">// 由于泛型参数的不变性，这里将出现问题</span><br><span class="line">copy(ints, any)</span><br></pre></td></tr></table></figure>
<p>很明显，我们希望from参数可以接收元素为Any或其子类的任意元素，但我们并不希望修改from，以防止出现类似文章开头的问题。因此，我们可以在from参数中添加out修饰，使其协变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦添加out修饰符，你就会发现，当你尝试调用set方法的时候，编译器将会提示你在out修饰的情况下禁止调用该方法。</p>
<p>注：Java语言在使用”协变“的情况下，from参数依然可以调用set方法。从这里可以看出，Kotlin语言在泛型安全控制上比Java更加精细。</p>
<h2 id="星号投影"><a href="#星号投影" class="headerlink" title="星号投影"></a>星号投影</h2><p>除了上述明确的类型投影方式之外，还有一种非常特殊的投影方式，称之为星号投影（star projection）。</p>
<p>在某些情况下，我们并不知道具体的类型参数信息。为了适应这种情况，Java语言中我们会直接忽略掉类型参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Box&lt;T&gt; &#123;</span><br><span class="line">     public void unPack(T t) &#123;</span><br><span class="line">          ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在不确定类型参数的情况下，我们会这样做</span><br><span class="line">Box box = new Box();</span><br></pre></td></tr></table></figure>
<p>在Kotlin语言中，我们使用星号对这种情况进行处理。因为，Kotlin针对泛型有严格的读写区分。同样地，使用*号将限制泛型接口的读写操作：</p>
<ul>
<li><code>Foo&lt;out T: TUpper&gt;</code>，这种情况下，T是协变类型参数，上边界是TUpper。Foo&lt;*&gt;等价于Foo<out tupper="">，这意味着你可以安全地从Foo&lt;*&gt;读取TUpper类型。</out></li>
<li><code>Foo&lt;in T&gt;</code>，在这种情况下，T是逆变类型参数，下边界是T。Foo&lt;*&gt;等价于Foo<in nothing="">，这意味着在T未知的情况下，你将无法安全写入Foo&lt;*&gt;。</in></li>
<li><code>Foo&lt;T: TUpper&gt;</code>，在这种情况下，T是不可变的。Foo&lt;*&gt;等价于你可以使用Foo<out tupper="">安全读取值，写入等价于Foo<in nothing="">，即无法安全写入。</in></out></li>
</ul>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>在泛型约束的控制上，Kotlin语言相对于Java也技高一筹。在大多数情况下，泛型约束需要指定一个上边界。这同Java一样，Kotlin使用冒号代替extends：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T: Animal&gt; catch(t: T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在使用Java的时候，经常碰到这样一个需求。我希望泛型参数可以约束必须同时实现两个接口，但遗憾的是Java语言并没有给予支持。令人惊喜的是，Kotlin语言对这种场景给出了自己的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; swap(first: List&lt;T&gt;, second: List&lt;T&gt;) where T: CharSequence, </span><br><span class="line">                                                    T: Comparable&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Kotlin语言使用where关键字控制泛型约束存在多个上边界的情况，此处应该给Kotlin鼓掌。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kotlin语言使用<strong>协变</strong>和<strong>逆变</strong>来规范可变泛型操作，out关键字用于协变，代表生产者。in关键字用于逆变，代表消费者。out和in同样可以用于方法参数的泛型声明中，这称之为类型投影。在针对泛型类型约束的处理上，Kotlin增加了多个上边界的支持。</p>
<p>Kotlin语言最初是希望成为一门编译速度比Scala更快的JVM编程语言！为了更好地设计泛型，我们看到它从C#中引入了<strong>协变</strong>和<strong>逆变</strong>的概念。这一次，我想，它至少同时站在了Scala和C#的肩膀上。</p>
<h2 id="欢迎加入Kotlin交流群"><a href="#欢迎加入Kotlin交流群" class="headerlink" title="欢迎加入Kotlin交流群"></a>欢迎加入Kotlin交流群</h2><p>如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/04/17/kotlin/Kotlin语言中的泛型设计哲学/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/04/14/kotlin/你是否也被Kotlin语言的object绕晕了呢/"
                            aria-label=": 你是否也被Kotlin语言的object绕晕了呢"
                        >
                            你是否也被Kotlin语言的object绕晕了呢
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-14T12:18:00+08:00">
	
		    4月 14, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="https://upload-images.jianshu.io/upload_images/703764-499d2f2f3e299b80.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文 | 欧阳锋"></p>
<p>近日，在笔者的Kotlin语言交流群中。的确发现了一些同学对<strong>object</strong>的用法有一些疑问。于是，出现了下面这样错误的用法：<br><img src="https://upload-images.jianshu.io/upload_images/703764-a0f15e2bb073278a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>很自然的想法，c是一个接口类型的成员变量，访问外部类的成员变量，这不是理所应当的吗？</p>
<p>即使查看Kotlin官方文档，也有这样一段描述：</p>
<blockquote>
<p>Sometimes we need to create an object of a slight modification of some class, without explicitly declaring a new subclass for it. Java handles this case with anonymous inner classes. Kotlin slightly generalizes this concept with object expressions and object declarations.</p>
</blockquote>
<p>核心意思是：Kotlin使用object代替Java匿名内部类实现。</p>
<p>很明显，即便如此，这里的访问应该也是合情合理的。从匿名内部类中访问成员变量在Java语言中是完全允许的。</p>
<p>这个问题很有意思，解答这个我们需要生成Java字节码，再反编译成Java看看具体生成的代码是什么。</p>
<p>借助<a href="http://jd.benow.ca/" target="_blank" rel="noopener">JD-GUI</a>，我们可以看到下面的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class Outer</span><br><span class="line">&#123;</span><br><span class="line">  private String a;</span><br><span class="line"></span><br><span class="line">  public static final class c</span><br><span class="line">    implements Moveable</span><br><span class="line">  &#123;</span><br><span class="line">    public static final c INSTANCE;</span><br><span class="line">    </span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">      c localc = new c();INSTANCE = localc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void move()</span><br><span class="line">    &#123;</span><br><span class="line">      Moveable.DefaultImpls.move(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很有意思，我们在Kotlin类中object部分的代码最终变成了下面这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static final class c implements Moveable &#123;</span><br><span class="line">   public static final c INSTANCE;</span><br><span class="line">   static &#123;</span><br><span class="line">     c localc = new c();INSTANCE = localc;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void move() &#123;</span><br><span class="line">     Moveable.DefaultImpls.move(this);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这是一个静态内部类，很明显，静态内部类是不能访问外部类成员变量的。可是问题来了，说好的匿名内部类呢？</p>
<p>这里一定要注意，如果你只是这样声明了一个object，Kotlin认为你是需要一个静态内部类。而如果你用一个变量去接收object表达式，Kotlin认为你需要一个匿名内部类对象。</p>
<p>因此，这个类应该这样改进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    private var a: String? = null</span><br><span class="line">    </span><br><span class="line">    // 用变量c去接收object表达式</span><br><span class="line">    private val c = object: Moveable &#123;</span><br><span class="line">        override fun move() &#123;</span><br><span class="line">            super.move()</span><br><span class="line">            // 改进后，这里访问正常</span><br><span class="line">            println(a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了避免出现这个问题，谨记一个原则：如果object只是声明，它代表一个静态内部类。如果用变量接收object表达式，它代表一个匿名内部类对象。</p>
</blockquote>
<h2 id="object能干啥？"><a href="#object能干啥？" class="headerlink" title="object能干啥？"></a>object能干啥？</h2><p>很自然地想到，Kotlin的object到底有什么作用。其实，从上文的表述来看。很明显，object至少有下面两个作用：</p>
<ul>
<li>简化生成静态内部类</li>
<li>生成匿名内部类对象</li>
</ul>
<p>其实，object还有一个非常重要的作用，就是生成单例对象。如果你需要在Kotlin语言中使用单例，非常简单，只需要使用object关键字即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object Singleton &#123;</span><br><span class="line">    fun f1() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fun f2() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式声明object和上面的方式略有区别，其最终会生成一个名为Singleton的类，并在类中生成一个静态代码块进行单例对象生成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class Singleton</span><br><span class="line">&#123;</span><br><span class="line">  public static final Singleton INSTANCE;</span><br><span class="line">  </span><br><span class="line">  public final void f1() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  public final void f2() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    Singleton localSingleton = new Singleton();INSTANCE = localSingleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Kotlin语言中对方法进行访问的时候最终其实是通过<strong>INSTANCE</strong>实例进行中转的。</p>
<p>在Kotlin语言中还有一个很常用的object叫做伴随对象。所谓的伴随对象只不过是名字叫做<strong>Companion</strong>的object而已。它主要用于类中生成类似Java的静态变量，Kotlin语言针对这个变量会认为你只是希望生成一个静态变量，而不希望引入多余的类。如果你是和Java语言混合开发的话，可以使用一个注解生成和Java语言静态变量完全一样的效果。</p>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>Kotlin语言中使用object命名的方式的确容易让人误认为只要使用这个关键字就是生成了一个对象。而从上文的表述当中，你会发现，其实不同的使用姿势将产生不同的效果。因此，在日常使用中一定要学会随机应变。如果遇到了不明白的问题，不妨来看看这篇文章是否已经解答了你的问题。如果没有，请在文章下方留言告诉我。</p>
<h2 id="欢迎加入Kotlin交流群"><a href="#欢迎加入Kotlin交流群" class="headerlink" title="欢迎加入Kotlin交流群"></a>欢迎加入Kotlin交流群</h2><p>如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/04/14/kotlin/你是否也被Kotlin语言的object绕晕了呢/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/04/14/kotlin/Kotlin难点解析：extension和this指针/"
                            aria-label=": Kotlin难点解析：extension和this指针"
                        >
                            Kotlin难点解析：extension和this指针
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-04-14T00:11:00+08:00">
	
		    4月 14, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>扩展（extension）是Kotlin语言中使用非常简单的一个特性。这篇文章并不是要讲解扩展的基本用法，而是解决在一些复杂场景中，扩展容易让人产生迷惑的一些问题。除了扩展，本篇文章还将讲解this指针在Kotlin语言中的基础用法。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/703764-119913eaea78702b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="扩展函数难点解析"><a href="#扩展函数难点解析" class="headerlink" title="扩展函数难点解析"></a>扩展函数难点解析</h2><p>大多数场景下，你都能轻松搞定Kotlin扩展。可是，看看下面这个题目，你还能脱口而出，告诉我答案是什么吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">open class E &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class E1: E() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class A &#123;</span><br><span class="line"></span><br><span class="line">    open fun E.f() &#123;</span><br><span class="line">        println(&quot;E.f in A&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open fun E1.f() &#123;</span><br><span class="line">        println(&quot;E1.f in A&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun call(e: E) &#123;</span><br><span class="line">        e.f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A1: A() &#123;</span><br><span class="line"></span><br><span class="line">    override fun E.f() &#123;</span><br><span class="line">        println(&quot;E.f in A1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun E1.f() &#123;</span><br><span class="line">        println(&quot;E1.f in A1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // a）</span><br><span class="line">    A().call(E())</span><br><span class="line"></span><br><span class="line">    // b）</span><br><span class="line">    A1().call(E())</span><br><span class="line"></span><br><span class="line">    // c）</span><br><span class="line">    A().call(E())</span><br><span class="line"></span><br><span class="line">    // d）</span><br><span class="line">    A().call(E1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：请告诉a，b，c，d位置代码执行的输出结果是什么？</p>
<p>对于这个问题，恐怕你在纸上写写画画半天也不一定能给出正确答案吧。关于这个问题，其实我之前的一篇文章 <a href="https://www.jianshu.com/p/d7a40c6a60d1" target="_blank" rel="noopener"> [Kotlin] Lambda and Extension</a> 中有提到过。可是，我认为这篇文章关于这部分的解释不够清晰，有必要再详细阐述一次。</p>
<p>Ok，let’s started。</p>
<p>为了解决这个问题，官方提出了两个新的概念：<strong>dispatch receiver</strong>和<strong>extension receiver</strong>。</p>
<ul>
<li>dispatch receiver：中文翻译为<strong>分发接收者</strong>。所谓的分发接收者，就是声明这个扩展方法所在的类。即：在哪个类中声明，那个类就是你的分发接收者。</li>
<li>extension receiver：中文翻译为<strong>扩展接收者</strong>。所谓的扩展接收者，就是你实际扩展的那个类。举个例子：你针对Int类扩展了一个方法add，这个add方法的扩展接收者就是Int类实例。</li>
</ul>
<p>为了简化，这里我们将<strong>dispatch receiver</strong>简称为<strong>DR</strong>，将<strong>extension receiver</strong>简称为<strong>ER</strong>。</p>
<p>还记得多态的概念吗？多态是一种运行时概念，即对象的类型要等到运行时才能最终确定。因此，一些语言中也将多态叫做类型延迟加载。解决上面这个问题我们需要关注就是扩展函数是否会产生多态行为。</p>
<p>这里我们将产生多态行为的技术叫做<strong>动态解析</strong>，与之相反的行为称之为<strong>静态解析</strong>。</p>
<p>为了解决上面的问题，你需要记住下面这个规则：</p>
<ul>
<li>DR类型是动态解析的</li>
<li>与之相反，ER类型是静态解析的</li>
</ul>
<p>先看上面例子的a、b部分，很显然：</p>
<ul>
<li>a代码中f函数的DR是类A，ER是类E</li>
<li>b代码中f函数的DR是类A1，ER是类E</li>
</ul>
<p>参照上面的规则，由于DR类型是动态解析的。在A1类中我们重写了E的扩展函数f，运行时最终会执行A1类中扩展的f方法。a部分很明显会输出A类中扩展的f方法。因此，最终的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E.f in A</span><br><span class="line">E.f in A1</span><br></pre></td></tr></table></figure>
<p>继续看c、d部分，c、d部分的DR都是A，而对于ER，c、d分别是E、E1。参照上面的规则，ER是静态解析的。在call方法声明的地方，我们传入的对象类型是E，这就决定了无论扩展方法是来自E还是其子类，将始终执行E类的扩展方法。因此，c、d部分将输出同样的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E.f in A</span><br><span class="line">E.f in A</span><br></pre></td></tr></table></figure>
<p>由此可见，如果你牢记上述两条规则，解决问题将变得非常容易。为了加强你的记忆，我用一个表格总结上面的知识点：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">DR</th>
<th style="text-align:center">ER</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">概念</td>
<td style="text-align:center">扩展方法声明所在的类</td>
<td style="text-align:center">声明扩展方法的类</td>
</tr>
<tr>
<td style="text-align:center">解析方式</td>
<td style="text-align:center">动态解析</td>
<td style="text-align:center">静态解析</td>
</tr>
</tbody>
</table>
<p>PS：由于新版本Kotlin中针对扩展函数也加入了override关键字，这非常有助于DR和ER的理解。如果你在使用Kotlin，强烈建议你更新到最新版本。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/703764-ab52dd83e6235da6.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="不太一样的this指针"><a href="#不太一样的this指针" class="headerlink" title="不太一样的this指针"></a>不太一样的this指针</h2><p>在Java语言中，如果你在内部类中需要外部类的引用可以将this写在类名后面。可是，试试看Kotlin，果断不行。</p>
<p>为了获得外部类的引用，Kotlin语言引入了@符号。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    inner class Inner &#123;</span><br><span class="line">        fun f() &#123;</span><br><span class="line">            println(this@Outer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，为了获取外部类的引用，只需要在@后面接外部类的名称即可。</p>
<p>如果对应一个扩展函数，this引用指向是什么呢？先说答案，扩展函数中的this指针指向ER，即实际扩展的那个类对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun Outer.foo() &#123;</span><br><span class="line">  println(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的this指向foo函数的接收者Outer类实例。</p>
<p>this指针还有一种场景是用在lambda表达式中，这是一种比较特殊的使用场景。lambda表达式本身没有任何接收者，如果是在全局声明一个lambda表达式，将不能使用this指针。而如果是在某个类或者扩展方法中使用this指针，将指向实际所在类或者扩展方法的接收者。</p>
<p>如果你习惯了Kotlin语言的这种表达方式，this指针的指向就不再是一个问题了。在你习惯这种用法之前，我用一个表格简单总结一下this指针的用法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">位置</th>
<th style="text-align:center">指向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类中</td>
<td style="text-align:center">默认指向当前类实例，使用@操作符指向具体外部类实例</td>
</tr>
<tr>
<td style="text-align:center">扩展函数</td>
<td style="text-align:center">默认指向扩展函数的接收者</td>
</tr>
<tr>
<td style="text-align:center">lambda表达式</td>
<td style="text-align:center">默认指向实际所在类实例或所在扩展函数的接收者</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于扩展，大多数情况下，你不会遇到文章开头那种复杂的情况。如果遇到了这种情况，只要清楚地区分DR和ER，并牢记DR和ER的解析方式，就能轻松应对了。对于this指针，与Java语言不一样的地方是，为了引用具体类的实例，Kotlin语言使用@符号。个人认为，这种表述方式更自然。如果遇到某些比较复杂的情况，只需要弄清楚接收者，问题就引刃而解了。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/04/14/kotlin/Kotlin难点解析：extension和this指针/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/02/06/kotlin/操作符重载及中缀调用/"
                            aria-label=": Kotlin 操作符重载及中缀调用"
                        >
                            Kotlin 操作符重载及中缀调用
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-02-06T11:39:00+08:00">
	
		    2月 06, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="http://upload-images.jianshu.io/upload_images/703764-0baf2dcfb0baa84f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>操作符重载其实很有意思！但这个概念却很少有人知道，使用操作符重载在某种程度上会给代码的阅读带来一定的麻烦。因此，慎用操作符被认为是一个好习惯。的确，操作符重载是一把双刃剑，既能削铁如泥，也能“引火烧身”，这篇文章将从实用的角度来讲解操作符重载的基本用法。</p>
</blockquote>
<h1 id="支持重载的操作符类型"><a href="#支持重载的操作符类型" class="headerlink" title="支持重载的操作符类型"></a>支持重载的操作符类型</h1><p>Kotlin语言支持重载的操作符类型比较多。以最新版本<strong>1.2.21</strong>为准，目前支持重载的操作符可以归纳为以下几类：</p>
<h1 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h1><h4 id="一元前缀操作符"><a href="#一元前缀操作符" class="headerlink" title="一元前缀操作符"></a>一元前缀操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+a</td>
<td style="text-align:center">a.unaryPlus()</td>
</tr>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">a.unaryMinus()</td>
</tr>
<tr>
<td style="text-align:center">!a</td>
<td style="text-align:center">a.not()</td>
</tr>
</tbody>
</table>
<p>以上三个操作符在日常使用中频率很高，第一个操作符在基本运算中很少使用，第二个操作符就是常见的取反操作，第三个操作符是逻辑取反操作。接下来，我们使用扩展的方式重载这三个操作符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一元操作符</span><br><span class="line"> *</span><br><span class="line"> * @author Scott Smith 2018-02-03 14:11</span><br><span class="line"> */</span><br><span class="line">data class Number(var value: Int)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 重载一元操作符+，使其对Number中实际数据取绝对值</span><br><span class="line"> */</span><br><span class="line">operator fun Number.unaryPlus(): Number &#123;</span><br><span class="line">    this.value = Math.abs(value)</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 重载一元操作符-，使其对Number中实际数据取反</span><br><span class="line"> */</span><br><span class="line">operator fun Number.unaryMinus(): Number &#123;</span><br><span class="line">    this.value = -value</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这个操作符通常是用于逻辑取反，这里用一个没有意义的操作，来模拟重载这个操作符</span><br><span class="line"> * 结果：始终返回Number中实际数据的负值</span><br><span class="line"> */</span><br><span class="line">operator fun Number.not(): Number &#123;</span><br><span class="line">    this.value = -Math.abs(value)</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val number = Number(-3)</span><br><span class="line">    println(&quot;Number value = $&#123;number.value&#125;&quot;)</span><br><span class="line">    println(&quot;After unaryPlus: Number value = $&#123;(+number).value&#125;&quot;)</span><br><span class="line">    println(&quot;After unaryMinus: Number value = $&#123;(-number).value&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    number.value = Math.abs(number.value)</span><br><span class="line">    println(&quot;After unaryNot: Number value = $&#123;(!number).value&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上述代码，将得到如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number value = -3</span><br><span class="line">After unaryPlus: Number value = 3</span><br><span class="line">After unaryMinus: Number value = -3</span><br><span class="line">After unaryNot: Number value = -3</span><br></pre></td></tr></table></figure></p>
<h4 id="自增和自减操作符"><a href="#自增和自减操作符" class="headerlink" title="自增和自减操作符"></a>自增和自减操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a++/++a</td>
<td style="text-align:center">a.inc()</td>
</tr>
<tr>
<td style="text-align:center">a–/–a</td>
<td style="text-align:center">a.dec()</td>
</tr>
</tbody>
</table>
<p>重载这个操作符相对比较难理解，官方文档有一段简短的文字解释，翻译成代码可以这样表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// a++</span><br><span class="line">fun increment(a: Int): Int &#123;</span><br><span class="line">  val a0 = a</span><br><span class="line">  a = a + 1</span><br><span class="line">  return a0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ++a</span><br><span class="line">fun increment(a: Int): Int &#123;</span><br><span class="line">  a = a + 1</span><br><span class="line">  return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看懂上面的代码后，我们换成需要重载的<code>Number</code>类，Kotlin最终会这样处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Number++</span><br><span class="line">fun increment(number: Number): Number &#123;</span><br><span class="line">  val temp = number</span><br><span class="line">  val result = number.inc()</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Number++</span><br><span class="line">fun increment(number: Number): Number &#123;</span><br><span class="line">  return number.inc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，重载<code>Number</code>类自加操作符，我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator fun Number.inc(): Number &#123;</span><br><span class="line">    return Number(this.value + 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重载自减操作符同理，完整代码请参考我的Git版本库：<a href="https://github.com/yuanhoujun/kotlin-samples" target="_blank" rel="noopener">kotlin-samples</a></p>
<h1 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符"></a>二元操作符</h1><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a + b</td>
<td style="text-align:center">a.plus(b)</td>
</tr>
<tr>
<td style="text-align:center">a - b</td>
<td style="text-align:center">a.minus(b)</td>
</tr>
<tr>
<td style="text-align:center">a * b</td>
<td style="text-align:center">a.times(b)</td>
</tr>
<tr>
<td style="text-align:center">a / b</td>
<td style="text-align:center">a.div(b)</td>
</tr>
<tr>
<td style="text-align:center">a % b</td>
<td style="text-align:center">a.rem(b)</td>
</tr>
<tr>
<td style="text-align:center">a..b</td>
<td style="text-align:center">a.rangeTo(b)</td>
</tr>
</tbody>
</table>
<p>前5个操作符相对比较好理解，我们以<code>a + b</code>为例，举个一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 重载Number类的加法运算符</span><br><span class="line">operator fun Number.plus(value: Int): Number &#123;</span><br><span class="line">    return Number(this.value + value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">       println((Number(1) + 2))</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果：</span><br><span class="line">Number value = 3</span><br></pre></td></tr></table></figure></p>
<p>相对比较难理解的是第六个范围运算符，这个操作符主要用于生成一段数据范围。我们认为<code>Number</code>本身就代表一个整型数字，因此，重载<code>Number</code>是一件有意义的事情。直接看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">operator fun Number.rangeTo(to: Number): IntRange &#123;</span><br><span class="line">    return this.value..to.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val startNumber = Number(3)</span><br><span class="line">    val endNumber = Number(9)</span><br><span class="line"></span><br><span class="line">    (startNumber..endNumber).forEach &#123;</span><br><span class="line">        println(&quot;value = $it&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行结果：</span><br><span class="line">value = 3</span><br><span class="line">value = 4</span><br><span class="line">value = 5</span><br><span class="line">value = 6</span><br><span class="line">value = 7</span><br><span class="line">value = 8</span><br><span class="line">value = 9</span><br></pre></td></tr></table></figure></p>
<h4 id="“In”运算符"><a href="#“In”运算符" class="headerlink" title="“In”运算符"></a>“In”运算符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a in b</td>
<td style="text-align:center">b.contains(a)</td>
</tr>
<tr>
<td style="text-align:center">a !in b</td>
<td style="text-align:center">!b.contains(a)</td>
</tr>
</tbody>
</table>
<p>这个操作符相对比较好理解，重载这个操作符可以用于判断某个数据是否在另外一个对象中。我们用一个非常简单的自定义类来模拟集合操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class IntCollection &#123; </span><br><span class="line">    val intList = ArrayList&lt;Int&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重载&quot;in&quot;操作符</span><br><span class="line">operator fun IntCollection.contains(value: Int): Boolean &#123;</span><br><span class="line">    return this.intList.contains(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val intCollection = IntCollection()</span><br><span class="line">    intCollection.add(1, 2, 3)</span><br><span class="line">    println(3 in intCollection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p>
<h4 id="索引访问运算符"><a href="#索引访问运算符" class="headerlink" title="索引访问运算符"></a>索引访问运算符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a[i]</td>
<td style="text-align:center">a.get(i)</td>
</tr>
<tr>
<td style="text-align:center">a[i, j]</td>
<td style="text-align:center">a.get(i, j)</td>
</tr>
<tr>
<td style="text-align:center">a[i_1, …, i_n]</td>
<td style="text-align:center">a.get(i_1, …, i_n)</td>
</tr>
<tr>
<td style="text-align:center">a[i] = b</td>
<td style="text-align:center">a.set(i, b)</td>
</tr>
<tr>
<td style="text-align:center">a[i, j] = b</td>
<td style="text-align:center">a.set(i, j, b)</td>
</tr>
<tr>
<td style="text-align:center">a[i_1, …, i_n] = b</td>
<td style="text-align:center">a.set(i_1, …, i_n, b)</td>
</tr>
</tbody>
</table>
<p>这个操作符很有意思，例如，如果你要访问Map中某个数据，通常是这样的<code>map.get(&quot;key&quot;)</code>，使用索引运算符你还可以这样操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val value = map[&quot;key&quot;]</span><br></pre></td></tr></table></figure></p>
<p>我们继续以<code>IntCollection</code>类为例，尝试重写<code>a[i]</code>和<code>a[i] = b</code>两个运算符，其它运算符同理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 重载a[i]操作符</span><br><span class="line">operator fun IntCollection.get(index: Int): Int &#123;</span><br><span class="line">    return intList[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重载a[i] = b操作符</span><br><span class="line">operator fun IntCollection.set(index: Int, value: Int) &#123;</span><br><span class="line">    intList[index] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val intCollection = IntCollection()</span><br><span class="line">    intCollection.add(1, 2, 3)</span><br><span class="line">    println(intCollection[0])</span><br><span class="line"></span><br><span class="line">    intCollection[2] = 4</span><br><span class="line">    print(intCollection[2])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们用索引运算符来做一点更有意思的事情！新建一个普通的<code>Kotlin</code>类<code>User</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User(var name: String,</span><br><span class="line">           var age: Int) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用下面的方式重载索引运算符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">operator fun User.get(key: String): Any? &#123;</span><br><span class="line">    when(key) &#123;</span><br><span class="line">        &quot;name&quot; -&gt; &#123;</span><br><span class="line">            return this.name</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;age&quot; -&gt; &#123;</span><br><span class="line">            return this.age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">operator fun User.set(key: String, value:Any?) &#123;</span><br><span class="line">    when(key) &#123;</span><br><span class="line">        &quot;name&quot; -&gt; &#123;</span><br><span class="line">            name = value as? String</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;age&quot; -&gt; &#123;</span><br><span class="line">            age = value as? Int</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，你会神奇地发现，一个普通的<code>Kotlin</code>类居然也可以使用索引运算符对成员变量进行操作了，是不是很神奇？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Scott Smith&quot;, 18)</span><br><span class="line">    println(user[&quot;name&quot;])</span><br><span class="line">    user[&quot;age&quot;] = 22</span><br><span class="line">    println(user[&quot;age&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，索引运算符不仅仅可以对集合类数据进行操作，对一个普通的<code>Kotlin</code>类也可以发挥同样的作用。如果你脑洞足够大，你还可以发现更多更神奇的玩法。</p>
<h4 id="调用操作符"><a href="#调用操作符" class="headerlink" title="调用操作符"></a>调用操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a()</td>
<td style="text-align:center">a.invoke()</td>
</tr>
<tr>
<td style="text-align:center">a(i)</td>
<td style="text-align:center">a.invoke(i)</td>
</tr>
<tr>
<td style="text-align:center">a(i, j)</td>
<td style="text-align:center">a.invoke(i, j)</td>
</tr>
<tr>
<td style="text-align:center">a(i_1, ……, i_n)</td>
<td style="text-align:center">a.invoke(i_1, ……, i_n)</td>
</tr>
</tbody>
</table>
<p>重载这个操作符并不难，理解它的应用场景却有一定的难度。为了理解它的应用场景，我们来举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class JsonParser &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">operator fun JsonParser.invoke(json: String): Map&lt;String, Any&gt; &#123;</span><br><span class="line">    val map = Json.parse(json)</span><br><span class="line">    ...</span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以这样调用</span><br><span class="line">val parser = JsonParser()</span><br><span class="line">val map = parser(&quot;&#123;name: \&quot;Scott Smith\&quot;&#125;&quot;)</span><br></pre></td></tr></table></figure></p>
<p>这里的调用有点像省略了一个解析Json数据的方法，难道它仅仅就是这个作用吗？是的，调用操作符其实就这一个作用。如果一个Kotlin类仅仅只有一个方法，直接使用括号调用的确是一个不错的主意。不过，在使用的时候还是要稍微注意一下，避免出现歧义。</p>
<h4 id="广义赋值操作符"><a href="#广义赋值操作符" class="headerlink" title="广义赋值操作符"></a>广义赋值操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a += b</td>
<td style="text-align:center">a.plusAssign(b)</td>
</tr>
<tr>
<td style="text-align:center">a -= b</td>
<td style="text-align:center">a.minusAssign(b)</td>
</tr>
<tr>
<td style="text-align:center">a *= b</td>
<td style="text-align:center">a.timesAssign(b)</td>
</tr>
<tr>
<td style="text-align:center">a /= b</td>
<td style="text-align:center">a.divAssign(b)</td>
</tr>
<tr>
<td style="text-align:center">a %= b</td>
<td style="text-align:center">a.remAssign(b)</td>
</tr>
</tbody>
</table>
<p>这个操作符相对比较好理解，我们以<code>Number</code>类为例，举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 广义赋值运算符</span><br><span class="line">operator fun Number.plusAssign(value: Int) &#123;</span><br><span class="line">    this.value += value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val number = Number(1)</span><br><span class="line">    number += 2</span><br><span class="line">    println(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">Number value = 3</span><br></pre></td></tr></table></figure></p>
<h4 id="相等与不等操作符"><a href="#相等与不等操作符" class="headerlink" title="相等与不等操作符"></a>相等与不等操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a == b</td>
<td style="text-align:center">a?.equals(b) ?: (b === null)</td>
</tr>
<tr>
<td style="text-align:center">a != b</td>
<td style="text-align:center">!(a?.equals(b) ?: (b === null))</td>
</tr>
</tbody>
</table>
<p>重载这个操作符与Java重写equals方法是一样的。不过，这里要注意与Java的区别，在Java端<code>==</code>用于判断两个对象是否是同一对象（指针级别）。而在Kotlin语言中，如果我们不做任何处理，<code>==</code>等同于使用Java对象的<code>equals</code>方法判断两个对象是否相等。</p>
<p>另外，这里还有一种特殊情况，如果左值等于null，这个时候<code>a?.equals(b)</code>将返回null值。因此，这里还增加了<code>?:</code>运算符用于进一步判断，在这个情况下，当且仅当b === null的时候，a、b才有可能相等。因此，才有了上面的对应关系，这里以<code>User</code>类为例举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class User(var name: String?,</span><br><span class="line">           var age: Int?) &#123;</span><br><span class="line"></span><br><span class="line">    operator override fun equals(other: Any?): Boolean &#123;</span><br><span class="line">        if(other is User) &#123;</span><br><span class="line">            return (this.name == other.name) &amp;&amp; (this.age == other.age)</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：这里有一个特殊的地方，与其它操作符不一样的地方是，如果使用扩展的方式尝试重载该操作符，将会报错。因此，如果要重载该操作符，一定要在类中进行重写。</p>
<h4 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a &gt; b</td>
<td style="text-align:center">a.compareTo(b) &gt; 0</td>
</tr>
<tr>
<td style="text-align:center">a &lt; b</td>
<td style="text-align:center">a.compareTo(b) &lt; 0</td>
</tr>
<tr>
<td style="text-align:center">a &gt;= b</td>
<td style="text-align:center">a.compareTo(b) &gt;= 0</td>
</tr>
<tr>
<td style="text-align:center">a &lt;= b</td>
<td style="text-align:center">a.compareTo(b) &lt;= 0</td>
</tr>
</tbody>
</table>
<p>比较操作符是一个在日常使用中频率非常高的操作符，重载这个操作符只需要掌握以上表格中几个规则即可。我们以<code>Number</code>类为例举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator fun Number.compareTo(number: Number): Int &#123;</span><br><span class="line">    return this.value - number.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="属性委托操作符"><a href="#属性委托操作符" class="headerlink" title="属性委托操作符"></a>属性委托操作符</h4><p><strong>属性委托操作符</strong>是一种非常特殊的操作符，其主要用在代理属性中。关于Kotlin代理的知识，如果你还不了解的话，请参考这篇文章<br> <a href="https://www.jianshu.com/p/54a57aac11e6" target="_blank" rel="noopener">Delegation</a>。这篇文章介绍的相对简略，后面会出一篇更详细的文章介绍代理相关的知识。</p>
<h4 id="中缀调用"><a href="#中缀调用" class="headerlink" title="中缀调用"></a>中缀调用</h4><p>看到这里，可能有一些追求更高级玩法的同学会问：Kotlin支持自定义操作符吗？</p>
<p>答案当然是：不能！不过，别失望，<code>infix</code>也许适合你，它其实可以看做一种自定义操作符的实现。这里我们对集合<code>List</code>新增一个扩展方法<code>intersection</code>用于获取两个集合的交集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取两个集合的交集</span><br><span class="line">fun &lt;E&gt; List&lt;E&gt;.interSection(other: List&lt;E&gt;): List&lt;E&gt; &#123;</span><br><span class="line">    val result = ArrayList&lt;E&gt;()</span><br><span class="line">    forEach &#123;</span><br><span class="line">        if(other.contains(it)) &#123;</span><br><span class="line">            result.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们就可以在<code>List</code>及其子类中使用点语法调用了。但，它看起来仍然不像一个操作符。为了让它更像一个操作符，我们继续做点事情：</p>
<ul>
<li>添加<code>infix</code>关键词</li>
<li>将函数名修改为∩（这是数学上获取交集的标记符号）<br>然而，万万没想到，修改完成后居然报错了。Kotlin并不允许直接使用特殊符号作为函数名开头。因此，我们取形近的字母<code>n</code>用于表示函数名：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取两个集合的交集</span><br><span class="line">infix fun &lt;E&gt; List&lt;E&gt;.n(other: List&lt;E&gt;): List&lt;E&gt; &#123;</span><br><span class="line">    val result = ArrayList&lt;E&gt;()</span><br><span class="line">    forEach &#123;</span><br><span class="line">        if(other.contains(it)) &#123;</span><br><span class="line">            result.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>接下来，我们就可以这样调用了<code>val interSection = list1 n list2</code>，怎么样？是不是很像自定义了一个获取交集的操作符<code>n</code>？如果你希望自定义操作符，可以尝试这么做。</p>
<p>其实<code>infix</code>的应用场景还不止这些，接下来，我们再用它完成一件更有意思的事情。</p>
<p>在实际项目开发中，数据库数据到对象的处理是一件繁琐的过程，最麻烦的地方莫过于思维的转换。那我们是否可以在代码中直接使用SQL语句查询对象数据呢？例如这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val users = Select * from User where age &gt; 18</span><br></pre></td></tr></table></figure></p>
<p>纸上学来终觉浅，觉知此事需躬行。有了这个idea，接下来，我们就朝着这个目标努力。<br>一、先声明一个<code>Sql</code>类，准备如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">infix fun select(columnBuilder: ColumnBuilder): Sql &#123;</span><br><span class="line"></span><br><span class="line">infix fun from(entityClass: Class&lt;*&gt;): Sql </span><br><span class="line"></span><br><span class="line">infix fun where(condition: String): Sql </span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; query(): T</span><br></pre></td></tr></table></figure></p>
<p>二、我们的目的是：最终转换到SQL语句形式。因此，增加如下实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class ColumnBuilder(var columns: Array&lt;out String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sql private constructor() &#123;</span><br><span class="line">    var columns = emptyList&lt;String&gt;()</span><br><span class="line">    var entityClass: Class&lt;*&gt;? = null</span><br><span class="line">    var condition: String? = null</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        fun get(): Sql &#123;</span><br><span class="line">            return Sql()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infix fun select(columnBuilder: ColumnBuilder): Sql &#123;</span><br><span class="line">        this.columns = columnBuilder.columns.asList()</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infix fun from(entityClass: Class&lt;*&gt;): Sql &#123;</span><br><span class="line">        this.entityClass = entityClass</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infix fun where(condition: String): Sql &#123;</span><br><span class="line">        this.condition = condition</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun &lt;T&gt; query(): T &#123;</span><br><span class="line">        // 此处省略所有条件判断</span><br><span class="line">        val sqlBuilder = StringBuilder(&quot;select &quot;)</span><br><span class="line"></span><br><span class="line">        val columnBuilder = StringBuilder(&quot;&quot;)</span><br><span class="line">        if(columns.size == 1 &amp;&amp; columns[0] == &quot;*&quot;) &#123;</span><br><span class="line">            columnBuilder.append(&quot;*&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            columns.forEach &#123;</span><br><span class="line">                columnBuilder.append(it).append(&quot;,&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            columnBuilder.delete(columns.size - 1, columns.size)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val sql = sqlBuilder.append(columnBuilder.toString())</span><br><span class="line">                            .append(&quot; from $&#123;entityClass?.simpleName&#125; where &quot;)</span><br><span class="line">                            .append(condition)</span><br><span class="line">                            .toString()</span><br><span class="line">        println(&quot;执行SQL查询：$sql&quot;)</span><br><span class="line"></span><br><span class="line">        return execute(sql)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun &lt;T&gt; execute(sql: String): T &#123;</span><br><span class="line">        // 仅仅用于测试</span><br><span class="line">        return Any() as T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>三、为了看起来更形似，再增加如下两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使其看起来像在数据库作用域中执行</span><br><span class="line">fun database(init: Sql.()-&gt;Unit) &#123;</span><br><span class="line">    init.invoke(Sql.get())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为infix限制，参数不能直接使用可变参数。因此，我们增加这个方法使参数组装看起来更自然</span><br><span class="line">fun columns(vararg columns: String): ColumnBuilder &#123;</span><br><span class="line">    return ColumnBuilder(columns)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，就是见证奇迹的时刻！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    database &#123;</span><br><span class="line">        (select (columns(&quot;*&quot;)) from User::class.java where &quot;age &gt; 18&quot;).query()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">执行SQL查询：select * from User where age &gt; 18</span><br></pre></td></tr></table></figure></p>
<p>为了方便大家查看，我们提取完整执行代码段与SQL语句对比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select          *       from User             where  age &gt; 18</span><br><span class="line">select  (columns(&quot;*&quot;))  from User::class.java where &quot;age &gt; 18&quot;</span><br></pre></td></tr></table></figure></p>
<p>神奇吗？<br>至此，我们就可以直接在代码中愉快地使用类似SQL语句的方式进行方法调用了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章从操作符重载实用的角度讲解了操作符重载的所有相关知识。如文章开头所说，操作符重载是一把双刃剑。用得好事半功倍，用不好事倍功半。因此，我给大家的建议是：使用的时候一定要保证能够自圆其说，简单来说，就是自然。我认为相对于古老的语言C++来说，Kotlin语言操作符重载的设计是非常棒的。如果你知道自己在做什么，我非常推荐你在生产环境中使用操作符重载来简化操作。</p>
<p>本篇文章例子代码点这里：<a href="https://github.com/yuanhoujun/kotlin-samples" target="_blank" rel="noopener">kotlin-samples</a></p>
<hr>
<p>我是欧阳锋，一个热爱Kotlin语言编程的学生。如果你喜欢我的文章，请在文章下方留下你爱的印记。如果你不喜欢我的文章，请先喜欢上我的文章。然后再留下爱的印记！</p>
<p>下次文章再见，拜拜！</p>
<hr>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/02/06/kotlin/操作符重载及中缀调用/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/01/26/kotlin/用Kotlin写Android-Gradle脚本/"
                            aria-label=": 也许你应该试试用Kotlin写Gradle脚本"
                        >
                            也许你应该试试用Kotlin写Gradle脚本
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-26T10:48:00+08:00">
	
		    1月 26, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/杂谈/">杂谈</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="http://upload-images.jianshu.io/upload_images/703764-1ba63891256d9db2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文 | 欧阳锋"></p>
<blockquote>
<p>Android应用开发中，离不开Gradle脚本的构建。大部分Android开发同学忽视了脚本的力量，甚至有很大一部分同学不知道Gradle脚本是什么，用什么语言编写的；当然，也有相当一部分同学知道Gradle脚本是使用Groovy语言编写的，但对于Groovy语言却一窍不通，只是勉强可以看懂Gradle脚本。正所谓，知其然，但并不知其所以然…</p>
</blockquote>
<p>换个角度看问题，熟练掌握Gradle脚本还需要精通Groovy语言，这对Android开发同学来说的确是一个不小的挑战。这种Java + Groovy的开发套餐对于普通的Android开发者来说的确存在一定的知识断层，显而易见的是，部分同学写的Gradle脚本简直“不堪入目”。时间回到去年5月份，Google IO大会上宣布了一个重磅消息，Android官方开始支持使用Kotlin语言进行应用开发。其实，在这个时间节点上，我已经在生产环境使用Kotlin开发Android将近一年。对于我来说，这无疑是一个让人欣喜若狂的消息。但，惊喜还远远不止这些，过了一段时间，我又看到了这篇文章 <a href="https://blog.gradle.org/kotlin-meets-gradle" target="_blank" rel="noopener">Kotlin Meets Gradle</a>。很有诗意的标题：当Gradle邂逅Kotlin，文章的核心意思是：<strong>Gradle团队正在尝试使用Kotlin语言作为Gradle脚本的官方开发语言。</strong></p>
<blockquote>
<p>我想，也许，Android开发者的春天就要到了！</p>
</blockquote>
<h1 id="Why-use-Kotlin"><a href="#Why-use-Kotlin" class="headerlink" title="Why use Kotlin ?"></a>Why use Kotlin ?</h1><p>在写Gradle脚本的时候，最痛苦的莫过于没有任何提示，唯一的调试手段就是使用<strong>print</strong>方法打印调试日志。正如 <a href="https://blog.gradle.org/kotlin-meets-gradle" target="_blank" rel="noopener">Kotlin Meets Gradle</a> 文中所说，当你使用Kotlin语言编写Gradle脚本的时候，你会发现一切都变得有趣起来。突然：</p>
<ul>
<li>脚本代码可以自动补全了</li>
<li>源码之间可以互相跳转了</li>
<li>插件源码更容易看懂了</li>
<li>重构（Refactoring）也可以支持了<br>…</li>
</ul>
<p>当然，惊喜还不止这些，当你开始决定使用Kotlin语言的时候，仿佛一切都变得美好了起来！</p>
<h1 id="Let’s-start"><a href="#Let’s-start" class="headerlink" title="Let’s start"></a>Let’s start</h1><p>好了，废话不多说，接下来我们开始尝试用Kotlin语言编写Gradle脚本。由于当前 <a href="https://github.com/gradle/kotlin-dsl" target="_blank" rel="noopener">kotlin-dsl</a> 正处于预发布状态（<strong>kotlin-dsl</strong>的最新版本是0.14.2，对应Gradle插件版本4.5），IDE的支持也不完善，为了更好的体验该功能，推荐大家使用如下配置：</p>
<h3 id="实验室配置"><a href="#实验室配置" class="headerlink" title="实验室配置"></a>实验室配置</h3><p><strong>操作系统：</strong>macOS 10.13.2<br><strong>Android Studio：</strong> 3.1 Canary 9<br><strong>Gradle Wrapper：</strong> 4.5<br><strong>Gradle Plugin：</strong> 3.1.0-alpha9<br><strong>Kotlin</strong>：1.2.21</p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>首先，按照以往步骤创建一个Android工程：<br><img src="http://upload-images.jianshu.io/upload_images/703764-58f93d293addaba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来，改造开始，Gradle Script Kotlin脚本以<code>.gradle.kts</code>后缀结尾。因此，我们先将工程根目录<code>settings.gradle</code>更名为<code>settings.gradle.kts</code>。<br><img src="http://upload-images.jianshu.io/upload_images/703764-429cf07b4fcaf7bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个地方的错误有两个原因：</p>
<ul>
<li>Kotlin语言中，单引号只能包裹字符，不能包裹字符串</li>
<li>Kotlin语言中，方法调用使用括号。仅在使用<code>infix</code>修饰的方法中可以省略括号。这里显然是一个正常调用方法。因此，我们修改为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include(&quot;app&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>接下来，修改根目录的<code>build.gradle</code>脚本，用同样的方式修改后缀，方法修改为括号调用，修改后的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        // 这里修改为括号调用即可</span><br><span class="line">        classpath(&quot;com.android.tools.build:gradle:3.0.1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：在修改后缀名称的时候IDE会出现警告提示，这里可以忽略，选择<strong>continue</strong>即可。</p>
</blockquote>
<p>由于我们手动修改了<code>build.gradle</code>脚本，为了保证工程可以使用这个脚本，需要在<code>settings.gradle.kts</code>中添加一行代码，让Gradle知道使用<code>build.gradle.kts</code>脚本构建。因此，最后的<code>settings.gradle.kts</code>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include(&quot;app&quot;)</span><br><span class="line">rootProject.buildFileName = &quot;build.gradle.kts&quot;</span><br></pre></td></tr></table></figure></p>
<p>最后一步，修改app模块<code>build.gradle</code>文件，这也是最复杂的一步，修改完后缀名后，你会看到整个脚本全部被红色标识错误：<br><img src="http://upload-images.jianshu.io/upload_images/703764-fcca2611413c7e31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>别慌！还是一样的方式，这里我们先将这里的所有代码注释掉。在最上方逐一对应修改，<code>apply plugin</code>部分修改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(&quot;com.android.application&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，修改<code>android {}</code>闭包部分。这里有两个小技巧，由于目前IDE的支持不是很完善，在输入的时候稍微等待一段时间，IDE会给出相应的提示。另外，如果没有提示，例如<code>android {}</code>闭包就没有任何提示，输入完成后展开右侧gradle面板，选择<code>gradle/buid setup/init</code>，双击执行：<br><img src="http://upload-images.jianshu.io/upload_images/703764-4710f3eea9bac093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在底部面板可以看到任务执行是否成功。注意，即使任务执行成功，脚本依然可能被红色标识，这是IDE支持不完善导致的，可以忽略。</p>
<p>修改完成后的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion(27)</span><br><span class="line">    buildToolsVersion(&quot;27.0.2&quot;)</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId = &quot;com.youngfeng.kotlindsl&quot;</span><br><span class="line">        minSdkVersion(15)</span><br><span class="line">        targetSdkVersion(27)</span><br><span class="line">        versionCode = 1</span><br><span class="line">        versionName = &quot;1.0&quot;</span><br><span class="line">        testInstrumentationRunner = &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        getByName(&quot;release&quot;) &#123;</span><br><span class="line">            isMinifyEnabled = true</span><br><span class="line">            proguardFiles(getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：你在使用的过程中，依然可能会遇到无论如何都不生效的问题。这个时候别着急，使用<code>./gradlew assembleDebug</code>命令调试，查看终端找到错误原因。Windows用户去掉<code>./</code>执行即可。<br><img src="http://upload-images.jianshu.io/upload_images/703764-1e9abe6a47044d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>最后的依赖部分，同样地，全部修改为括号调用即可。这里就不赘述了，文章的最后部分会提供操作视频，在使用过程中有任何问题可以打开操作视频参考，如果依然不能解决，可以在文章下方给我留言，我会在第一时间给你答复。修改后的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(fileTree(mapOf(&quot;dir&quot; to &quot;libs&quot;, &quot;include&quot; to listOf(&quot;*.jar&quot;))))</span><br><span class="line">    implementation(&quot;com.android.support:appcompat-v7:26.1.0&quot;)</span><br><span class="line">    implementation(&quot;com.android.support.constraint:constraint-layout:1.0.2&quot;)</span><br><span class="line">    testImplementation(&quot;junit:junit:4.12&quot;)</span><br><span class="line">    androidTestImplementation(&quot;com.android.support.test:runner:1.0.1&quot;)</span><br><span class="line">    androidTestImplementation(&quot;com.android.support.test.espresso:espresso-core:3.0.1&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的步骤，从Groovy转换到Kotlin的步骤已经全部完成，你可以在终端输入<code>./gradlew assembleDebug</code>测试是否可以正常构建了：<br><img src="http://upload-images.jianshu.io/upload_images/703764-2ec3894242b02f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="统一依赖管理"><a href="#统一依赖管理" class="headerlink" title="统一依赖管理"></a>统一依赖管理</h1><p>上面的步骤虽然完成了脚本的转换，但依赖的管理依然是混乱的，为了实现类似<br> <a href="https://github.com/yuanhoujun/Android_Slide_To_Close" target="_blank" rel="noopener">Snake</a> 工程的统一依赖管理，我们还需要做一些工作。</p>
<p>Gradle官方提供了使用 <a href="https://docs.gradle.org/current/userguide/organizing_build_logic.html#sec:build_sources" target="_blank" rel="noopener">buildSrc</a> 目录实现自定义任务和插件逻辑，这里我们可以使用它完成依赖的统一处理，一个完整的buildSrc目录结构如下：<br><img src="http://upload-images.jianshu.io/upload_images/703764-a000e0ab037ab1a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Deps类中，可以这样定义依赖结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">object deps &#123;</span><br><span class="line">    object plugin &#123;</span><br><span class="line">        val gradle = &quot;com.android.tools.build:gradle:3.1.0-alpha09&quot;</span><br><span class="line">        val kotlin = &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.2.21&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    object kotlin &#123;</span><br><span class="line">        val stdlibJre7 = &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.21&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    object android &#123;</span><br><span class="line">        object support &#123;</span><br><span class="line">            val compat = &quot;com.android.support:appcompat-v7:27.0.2&quot;</span><br><span class="line">            val constraintLayout = &quot;com.android.support.constraint:constraint-layout:1.0.2&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        object test &#123;</span><br><span class="line">            val junit = &quot;junit:junit:4.12&quot;</span><br><span class="line">            val runner = &quot;com.android.support.test:runner:1.0.1&quot;</span><br><span class="line">            val espressoCore = &quot;com.android.support.test.espresso:espresso-core:3.0.1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义之后，我们就可以在脚本中直接引用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(fileTree(mapOf(&quot;dir&quot; to &quot;libs&quot;, &quot;include&quot; to listOf(&quot;*.jar&quot;))))</span><br><span class="line">    implementation(deps.kotlin.stdlibJre7)</span><br><span class="line">    implementation(deps.android.support.compat)</span><br><span class="line">    implementation(deps.android.support.constraintLayout)</span><br><span class="line">    testImplementation(deps.android.test.junit)</span><br><span class="line">    androidTestImplementation(deps.android.test.runner)</span><br><span class="line">    androidTestImplementation(deps.android.test.espressoCore)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是漂亮了许多？</p>
<p>至此，整个转换过程就顺利完成了，为了保证转换的成功率，我推荐使用文章开头的实验室配置。如果版本过低，不保证可以转换成功。最新版本的<strong>kotlin-dsl</strong>会跟随最新版本的Gradle插件发布，因此一定要使用最新版本。另外，目前IDE对kts的支持依然不完善，即使正确的写法也会报错，这个一定要注意，不要被IDE欺骗了。</p>
<h3 id="更详细的操作，请看视频教程"><a href="#更详细的操作，请看视频教程" class="headerlink" title="更详细的操作，请看视频教程"></a>更详细的操作，请看视频教程</h3><p>腾讯视频：<a href="https://v.qq.com/x/page/x0539lvfmm2.html" target="_blank" rel="noopener">用Kotlin写Android Gradle脚本</a></p>
<h4 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h4><p>虽然使用Kotlin语言写脚本是一件非常美妙的事情，但目前依然存在一些问题：</p>
<ul>
<li>IDE支持不完善</li>
<li><a href="https://github.com/gradle/kotlin-dsl" target="_blank" rel="noopener">kotlin-dsl</a> 正在快速开发中，语法变动较大</li>
<li>缺少官方文档</li>
<li>互联网上缺少相关资料，遇到问题很难追踪</li>
</ul>
<p>因此，目前我并不推荐你在生产环境中使用，但可以作为日常学习练手之用。预计1.0版本的发布在今年6月份左右，正式版本发布后，我推荐你立即将Gradle脚本转换到Kotlin语言。</p>
<h4 id="遇到问题，看这里-gt"><a href="#遇到问题，看这里-gt" class="headerlink" title="遇到问题，看这里 ==&gt;"></a>遇到问题，看这里 ==&gt;</h4><p>在使用的过程中，按照文章同样的步骤，你依然可能会遇到很多问题。因此，我为你整理了目前互联网上可以参考的资料，你可以收藏这篇文章。遇到问题别慌，来这里查找答案。</p>
<p>关于<strong>kotlin-dsl</strong>的开发路线图，请看这篇文章：<a href="https://blog.gradle.org/kotlin-scripting-update" target="_blank" rel="noopener">https://blog.gradle.org/kotlin-scripting-update</a></p>
<p>如果你在使用过程中，遇到了任何问题，并且确定是 <strong>kotlin-dsl</strong> 的bug，请点这里：<a href="https://github.com/gradle/kotlin-dsl" target="_blank" rel="noopener">https://github.com/gradle/kotlin-dsl</a> 并推送 <strong>issue</strong></p>
<p>如果你遇到了知识盲点，并且在Google找不到答案。可以来 <a href="https://kotlinlang.slack.com/" target="_blank" rel="noopener">Slack</a>#gradle频道反馈，我在 <a href="https://kotlinlang.slack.com/" target="_blank" rel="noopener">Slack</a> 的昵称是<strong>Scott Smith</strong>，也欢迎你给我发送私信消息。<br><img src="http://upload-images.jianshu.io/upload_images/703764-995957884721bca9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>本篇文章例子完整代码，请点击这里：<a href="https://github.com/yuanhoujun/gradle-script-kotlin-example" target="_blank" rel="noopener">https://github.com/yuanhoujun/gradle-script-kotlin-example</a></p>
<p>kts文档正在编写当中，具体进度，请点这里：<a href="https://github.com/gradle/kotlin-dsl-docs" target="_blank" rel="noopener">https://github.com/gradle/kotlin-dsl-docs</a></p>
<h1 id="欢迎加入Kotlin交流群"><a href="#欢迎加入Kotlin交流群" class="headerlink" title="欢迎加入Kotlin交流群"></a>欢迎加入Kotlin交流群</h1><p>如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/01/26/kotlin/用Kotlin写Android-Gradle脚本/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2016/08/22/kotlin/delegation/"
                            aria-label=": Kotlin 代理模式"
                        >
                            Kotlin 代理模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-08-22T00:25:00+08:00">
	
		    8月 22, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>代理模式是23种经典设计模式之一，代理模式被认为是继承的更好替代解决方案；因为代理比继承更加灵活，在Java语言中，通过反射可以实现动态代理，动态代理可以实现<strong>AOP</strong>编程，即：可以动态地往已有类中添加逻辑；比如：实现事务的自动提交，异常的自动捕获，热修复等等; </p>
<p>在Kotlin语言中，代理模式是默认支持的，不需要任何额外的代码，你只需要记住一个关键字<strong>by</strong>。我们不妨来试一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Base &#123;</span><br><span class="line">    fun sayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaseImpl : Base &#123;</span><br><span class="line">    override fun sayHi() &#123;</span><br><span class="line">        println(&quot;BaseImpl-&gt;sayHi&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Derived(b: Base) : Base by b</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val b = BaseImpl()</span><br><span class="line">    val derived = Derived(b)</span><br><span class="line">    derived.sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里Derived作为BaseImpl的代理类，拥有BaseImpl类中的所有方法，Derived将代理BaseImpl类执行BaseImpl类中的所有方法，就像继承自BaseImpl类一样。这样说起来有点抽象，来看一下Kotlin编译器具体为我们做了一些什么。但是，怎么看呢？教大家一个方法！<br>大家都知道，Kotlin和Java均是JVM语言，最终均转换到同样的Java字节码，这样我们就可以先将Kotlin编译为.class文件，再反编译为.java文件，看看对应的Java代码，我们就可以看到更多的细节。下面是最终反编译生成的Java代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Derived implements Base &#123;</span><br><span class="line">  public Derived(@NotNull Base b) &#123;</span><br><span class="line">    this.$$delegate_0 = b;</span><br><span class="line">  &#125;</span><br><span class="line">  public void sayHi() &#123;</span><br><span class="line">    this.$$delegate_0.sayHi();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们可以清楚地看到，Kotlin编译器为我们动态添加了一个成员变量$$delegate_0，这个成员变量代表被代理的对象，这里对应的是BaseImpl对象，Derived里面的sayHi方法最终调用是代理对象的sayHi方法，即Kotlin编译器帮我们提供了一个非常漂亮的代理模式实现。</p>
<h1 id="代理属性"><a href="#代理属性" class="headerlink" title="代理属性"></a>代理属性</h1><p>在一些情况下，我们可能希望某些属性延迟加载，即在我们正在需要的时候才对它赋值；亦或者我们希望可以随时监听属性值的变化；在上述这些场景中，代理属性就可以发挥作用了。</p>
<p>代理属性的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class DelegateProperty &#123;</span><br><span class="line">	val d: String by Delegate()</span><br><span class="line">&#125;</span><br><span class="line">class Delegate &#123;</span><br><span class="line">    operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;): String &#123;</span><br><span class="line">        return &quot;Invoke getValue() , thisRef = $thisRef , property name = $&#123;property.name&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: String) &#123;</span><br><span class="line">        println(&quot;Invoke setValue() , thisRef = $thisRef , property name = $&#123;property.name&#125; , value = $value&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val dp = DelegatedProperty()</span><br><span class="line">    dp.d = &quot;Value0&quot; // Invoke setValue() , thisRef = DelegatedProperty@2ef1e4fa , property name = d , value = Value0</span><br><span class="line">   </span><br><span class="line">    println(dp.d) // Invoke getValue() , thisRef = DelegatedProperty@2ef1e4fa , property name = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代理是如何实现的呢？我们知道，Kotlin的属性值会自动生成set/get方法，而代理类通过代理set/get方法生成相应的代理方法，这里的方法对应关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// thisRef对应代理对象的引用，property对应代理属性的反射属性封装</span><br><span class="line">// 注意这里的代理方法一定要添加operator关键字，operator关键字是重载操作符关键字，后续的文章中会讲到，敬请期待</span><br><span class="line">get() -&gt; operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;)</span><br><span class="line">set() -&gt; operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: T)</span><br></pre></td></tr></table></figure>
<p>Kotlin标准库提供了一些常用代理的方法实现，即上文提到的几种代理，先来看第一种：延迟加载。</p>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>Kotlin提供了一个lazy方法用于实现延迟加载，lazy方法有一个lambda表达式参数，用于对属性进行初始化赋值，而一旦完成赋值，该lambda表达式将不会再次调用。lambda表达式调用发生在第一次使用该属性的时候，即实现了属性赋值的延迟加载。来看一个简单的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用标准库实现的lazy函数，实现属性的延迟加载</span><br><span class="line">private val lazyValue: String by lazy &#123;</span><br><span class="line">    println(&quot;调用该初始赋值表达式完成赋值&quot;)</span><br><span class="line">    // 这里是实际赋值</span><br><span class="line">    &quot;Hello, world&quot;</span><br><span class="line">&#125;</span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // 仅在第一次会调用lazy方法的lambda表达式</span><br><span class="line">    println(lazyValue) // 打印：调用该初始赋值表达式完成赋值</span><br><span class="line">    println(lazyValue) // 打印： Hello, world, 再次调用将不再调用lambda表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lazy方法是一个线程安全的延迟加载方法，为了加深大家的理解，根据上面的原理，我们尝试自己来实现一个非线程安全的延迟加载方法，看具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private object UNINITIALIZE_VALUE</span><br><span class="line"></span><br><span class="line">class MyLazy&lt;T&gt;(initialize: ()-&gt;T) &#123;</span><br><span class="line">    private var value: Any? = UNINITIALIZE_VALUE</span><br><span class="line">    private val initialize = initialize</span><br><span class="line">    operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;): T &#123;</span><br><span class="line">        if(value == UNINITIALIZE_VALUE) &#123;</span><br><span class="line">            value = initialize()</span><br><span class="line">        &#125;</span><br><span class="line">        return value as T</span><br><span class="line">    &#125;</span><br><span class="line">    operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: T) &#123;</span><br><span class="line">        this.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 为了和标准库区分，使用__lazy命名</span><br><span class="line">fun &lt;T&gt;  __lazy(initialize: () -&gt; T): MyLazy&lt;T&gt; = MyLazy(initialize)</span><br><span class="line"></span><br><span class="line">var lazyValue1 by __lazy &#123;</span><br><span class="line">    println(&quot;自定义lazy初始化赋值表达式被调用&quot;)</span><br><span class="line">    &quot;Hello , world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // 自定义延迟加载函数__lazy</span><br><span class="line">    println(lazyValue1)</span><br><span class="line">    lazyValue1 = &quot;Other value&quot;</span><br><span class="line">    println(lazyValue1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，实现一个延迟加载接口并不复杂，最重要的是要理解延迟加载的过程以及实现原理。总结实现延迟加载接口，需要注意三个地方：</p>
<ul>
<li>需要提供初始化lambda表达式参数，用于初始赋值</li>
<li>需要实现代理属性对象的setValue/getValue方法，如果是val则只需要实现getValue即可</li>
<li>需要严格确保属性不会被多次初始化 </li>
</ul>
<h3 id="Observable属性"><a href="#Observable属性" class="headerlink" title="Observable属性"></a>Observable属性</h3><p>Kotlin标准库还提供了一个可观察属性，这个属性使用观察者模式实现，如果属性值发生变化则会调用相应的回调lambda接口通知使用者，先看一个具体的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var observableValue by Delegates.observable(&quot;Initial value&quot;) &#123;  prop , old , new -&gt;</span><br><span class="line">    println(&quot;$old -&gt; $new&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(observableValue)    // 打印：Initial value</span><br><span class="line">    observableValue = &quot;Hello&quot;   // 打印: Initial value -&gt; Hello</span><br><span class="line">    println(observableValue)    // 打印：Hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的具体实现，感兴趣的同学请参看文章开头的方法进行追踪！</p>
<h3 id="Storing-Properties-in-a-Map"><a href="#Storing-Properties-in-a-Map" class="headerlink" title="Storing Properties in a Map"></a>Storing Properties in a Map</h3><p>这也是Kotlin标准库提供的一个非常有用的特性，它主要用于JSON数据的解析。看官方的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User(val map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">	val name: String by map</span><br><span class="line">	val age: Int by map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val user = User(mapOf(</span><br><span class="line">	&quot;name&quot; to &quot;John Doe&quot;,</span><br><span class="line">	&quot;age&quot; to 25</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>该方法比较简单，这里就不再赘述了！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，关于代理的介绍可以暂时告一段落了！<br>代理模式是一个非常经典设计模式，在解决某些问题中可以发挥事半功倍的效果。幸运的是，Kotlin语言原生支持代理模式，实现代理模式如同声明一个属性一样简单。而且，代理模式的设计也非常漂亮，仅仅使用一个关键字by极尽简约之美。在日常编码中，一定要灵活运用代理模式，比如实现延迟加载，实现属性观察等等。<a href="https://github.com/JakeWharton/kotterknife" target="_blank" rel="noopener">KotterKnife</a> 是一个非常经典的代理模式的实现例子，有兴趣的同学可以clone该仓库，查看源码，领会代理模式的优美。</p>
<h1 id="欢迎加入Kotlin交流群"><a href="#欢迎加入Kotlin交流群" class="headerlink" title="欢迎加入Kotlin交流群"></a>欢迎加入Kotlin交流群</h1><p>如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。</p>
<h1 id="文章源码地址"><a href="#文章源码地址" class="headerlink" title="文章源码地址"></a>文章源码地址</h1><p>Kotliner: <a href="https://github.com/yuanhoujun/Kotliner" target="_blank" rel="noopener">https://github.com/yuanhoujun/Kotliner</a>,<br>别忘了点击仓库右上方的star哦！</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2016/08/22/kotlin/delegation/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 欧阳锋工作室. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
            <h4 id="about-card-name">欧阳锋工作室</h4>
        
            <div id="about-card-bio"><p>Stay hungry, stay foolish</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>深圳一行代码科技有限公司创始人</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                广东深圳
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-uxpinu5umcabfr9aiy0uhzftnioszmvauq3qgkh8evzewnqgit0fhssjlsfq.min.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
