
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="欧阳锋工作室">
    <title>分类: Bug Fix - 欧阳锋工作室</title>
    <meta name="author" content="欧阳锋工作室">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="关注欧阳锋工作室，你想知道的都在这里~">
<meta property="og:type" content="blog">
<meta property="og:title" content="欧阳锋工作室">
<meta property="og:url" content="http://youngfeng.com/categories/Bug-Fix/index.html">
<meta property="og:site_name" content="欧阳锋工作室">
<meta property="og:description" content="关注欧阳锋工作室，你想知道的都在这里~">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欧阳锋工作室">
<meta name="twitter:description" content="关注欧阳锋工作室，你想知道的都在这里~">
    
    
        
    
    
        <meta property="og:image" content="http://youngfeng.com/assets/images/avatar.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-n3h5fvwrba2ezx3jjewg1itrl3r4ognmb0rqhxoh9kr7ltfomtbpdedrggqw.min.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            欧阳锋工作室
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">欧阳锋工作室</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Stay hungry, stay foolish</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/yuanhoujun" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/assets/images/mpwexin.jpg"
                            title="微信公众号"
                        >
                    
                        <i class="sidebar-button-icon fab fa-weixin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微信公众号</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://weibo.com/u/6140262139?is_all=1" target="_blank" rel="noopener" title="微博">
                    
                        <i class="sidebar-button-icon fab fa-weibo" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微博</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:ouyangfeng2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/01/02/bug fix/记一次印象深刻的Bug追踪过程/"
                            aria-label=": 记一次印象深刻的Bug追踪过程"
                        >
                            记一次印象深刻的Bug追踪过程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-02T18:03:00+08:00">
	
		    1月 02, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Bug-Fix/">Bug Fix</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>问题现象：使用安卓手机以小程序的形式分享产品到微信，使用微信打开，产品详情数据无法显示。而使用iPhone分享到微信，却始终可以正常打开，这个时候所有的矛头都指向了安卓同学。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-cdf26125f909ddcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小程序中打开，显示空白"></p>
<p>逻辑设计说明：这里的分享数据来自H5接口，通过<code>addJavascriptInterface</code>自定义接口完成H5和Java端的数据传递，产品ID来自后台接口获取。</p>
<p>这个时候，安卓同学首先做出了响应，通过调试拿到了JS端的数据，以下是这位小陈同学的截图消息：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-bd7a8a062dfab805.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android调试结果"></p>
<p>小陈同学这个时候把问题抛给了Web前端同学小徐，以为小徐传递了科学计数法的ID字符串。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-4dcd326299b5e4d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>大家看小陈同学的截图，图中的ID是使用字符串接收的，这个时候我已经完全排除问题出现在安卓端的可能性了。于是，我问小徐，H5有对参数进行处理吗？得到的答案如下：<br><img src="http://upload-images.jianshu.io/upload_images/703764-a28fd422fa316bcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>大家看到图中，我已经给出了确定的答案，认为问题来自于后台。因为，后台同学之前的确出现过对ID进行toInt处理最终转换为负数的情况。现在在传递时出现这种低级错误的概率应该也挺高的。这段话抛出去之后，团队炸开了锅，有同学认为大家在互相推诿…</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-4ec531bb958ae6be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其实，还有很长的截图，这里没有展示出来。群里提到最多的一句话就是：<code>iOS没问题啊</code>。就连我们的运维同学以及UI设计同学都加入了“讨伐”队伍，种种迹象似乎都指向了安卓同学。这个时候，我们的安卓同学真是“哑巴吃黄连，有苦说不出”，心里的潜台词肯定是：我TM的就用<code>string</code>接收了一下，我招谁惹谁了我！</p>
<p>但其实出现这种不知所踪的情况，完全可以理解，大家大都集中在单一平台开发，对于其它环节的理解难免有偏差。其实，用常识来理解这个问题的话，的确后台的概率比较大，前端同学对ID进行运算处理的概率几乎为0，这一点即使是刚刚入行的新手也不太可能。而我一直苦等的后台同学却迟迟没有响应，我目前始终无法确定问题到底来自于后台还是Web前端。直到我终于看到了下面的截图。<br><img src="http://upload-images.jianshu.io/upload_images/703764-fc7196333abaedbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个时候，我终于有九成的把握确定问题来自于Web前端了。可是，我知道我不能明说。前端同学已经在聊天记录中给出了证据，在Chrome的控制台打印出了正常的id值，到了安卓端却出现了异常。前端同学这个时候心里也有了一个定性结论，问题来自安卓端。这个时候，我只能亲自上场，而恰好我在外面，正在办理深圳户口，比较不便。于是，我微信给小陈发消息，嘱咐它把详情页的源码“爬”下来，我回来看看源码。</p>
<p>回到家的时候，我问小陈html源码是否已经“爬”了下来，他给我发来截图，我意识到前端使用了https协议，没法获取html源码。于是，我想了一个办法，在源码中嵌入一段代码，通过代码的形式获取WebView产品详情页的数据。这个方法果然奏效，不一会儿，小陈就发来了页面的html源码。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-de788a95449192ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>哎哟，我的天哪！混淆后的代码简直不堪入目，不过还好，我可以搜索方法关键字<code>showShareView</code>。可是，很遗憾没有搜索到，事件的绑定被放到了JS代码中。在这段源码中，我注意到一个文件名已经被混淆的JS文件，我猜想代码应该就在这里。可是，怎样抓到具体的方法呢？</p>
<p>灵机一动！我之前在代码中让小陈把Debug权限开发给了H5，这次正好可以派上用场。可是，对于混淆后的代码，我心里依然有点打退堂鼓。</p>
<p>连上手机，在Chrome浏览器中输入chrome://inpsect，点击相应链接，非常顺利地进入了调试界面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-753ad81eaaf2318d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在控制台的Source中，我通过关键词搜索找到了混淆后的JS代码片段，在方法名前面增加了一个断点，等调试到底方法位置的时候。这个时候已经获取到了JS的上下文，直接通过<code>this.gid</code>打印出了当前产品ID信息，居然是一个非常正常的整型数字。大家注意，这已经是一个在安卓端出问题的产品了，在JS端居然显示是正常的。这个时候，我的大脑非常转动，我的第一感觉应该是<code>webkit</code>内核看到接收的字符串全是数字做了”自以为是“的转换。于是，我给出了团队如下的答案：<br><img src="http://upload-images.jianshu.io/upload_images/703764-02b3c3a21e2b0569.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>为了进一步确定我的猜想，我让小陈写了一个简单的Demo，通过JS接口传递一个非常大的数字字符串给Java端，看接收是否异常。不一会儿，我就得到了答案：<br><img src="http://upload-images.jianshu.io/upload_images/703764-64ba7132c99d0a56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>至此，我终于基本确定问题的原因了！<br>猜测：JS在传递数据给安卓端的时候，应该是使用了基本数据类型。而<code>webkit</code>内核在处理的时候可能是以JS端数据类型为准，在传递到Java端时候做了转换。</p>
<p>为了验证这个猜想，我使用<code>typeof</code>打印id的数据类型，得到了如下结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-7615a576bf35a125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>于是，我告诉小徐，问题来自于你没有传递正确的数据类型给安卓端。其实这是比较危险的，不同CPU可以容纳的最大整型值是不一样的。如果iOS端和安卓处理一致，也是以JS端数据类型为准，只不过iOS的CPU字节宽度较大，恰好在iPhone高端机型上面没有出现而低端机型出现的话。其实问题依然存在，而如果iOS的确是以Native端数据类型为准。这就根本不是一个问题。但答案虽然给了团队，可是小徐仍然一脸狐疑，没有经验的CTO也是跟着一脸狐疑，加上解决问题的时间较长。小徐在发布更新的时候也遇到了问题，导致更新失败，问题持续，整个问题一直在持续。</p>
<p>这个时候，我告诉小徐，你发布更新后先别着急，确定更新成功后再告诉团队小伙伴。</p>
<p>一直到确定更新成功，我们再次尝试分享，问题终于引刃而解！</p>
<blockquote>
<p>问题虽然解决了，可是，安卓系统为什么要这样处理呢？为什么不能以Native端数据类型为准呢？带着这个疑问，我开始查看安卓源码。</p>
</blockquote>
<p>阅读安卓源码是一个痛苦的过程，随着系统版本的升级，安卓系统的兼容性代码越来越多，这给阅读带来了极大的困难。加上安卓系统本身源码量巨大，阅读源码就像在一个巨大的森林中寻找宝藏一样。这个时候，其实你非常容易迷路，而我知道，只要我坚信我想要什么，就一定可以找到。</p>
<p>这里我们以<code>addJavascriptInterface</code>这个方法作为突破口，进入源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void addJavascriptInterface(Object object, String name) &#123;</span><br><span class="line">       checkThread();</span><br><span class="line">       mProvider.addJavascriptInterface(object, name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>额，mProvider是什么鬼？难道WebView只是一个傀儡，真正处理业务的其实是mProvider？是的，没错！WebView只不过是一个壳而已！可是，mProvider的实现到底是什么呢？带着这个疑问，我们看到了如下mProvider实例创建的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void ensureProviderCreated() &#123;</span><br><span class="line">      checkThread();</span><br><span class="line">      if (mProvider == null) &#123;</span><br><span class="line">          // As this can get called during the base class constructor chain, pass the minimum</span><br><span class="line">          // number of dependencies here; the rest are deferred to init().</span><br><span class="line">          mProvider = getFactory().createWebView(this, new PrivateAccess());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static WebViewFactoryProvider getFactory() &#123;</span><br><span class="line">      return WebViewFactory.getProvider();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>又出现了一个工厂方法，别怕，继续往下追踪：<br>getProvider方法较长，我们截取部分，看下面源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static WebViewFactoryProvider getProvider() &#123;</span><br><span class="line">        synchronized (sProviderLock) &#123;</span><br><span class="line">            // For now the main purpose of this function (and the factory abstraction) is to keep</span><br><span class="line">            // us honest and minimize usage of WebView internals when binding the proxy.</span><br><span class="line">            if (sProviderInstance != null) return sProviderInstance;</span><br><span class="line"></span><br><span class="line">            final int uid = android.os.Process.myUid();</span><br><span class="line">            if (uid == android.os.Process.ROOT_UID || uid == android.os.Process.SYSTEM_UID</span><br><span class="line">                    || uid == android.os.Process.PHONE_UID || uid == android.os.Process.NFC_UID</span><br><span class="line">                    || uid == android.os.Process.BLUETOOTH_UID) &#123;</span><br><span class="line">                throw new UnsupportedOperationException(</span><br><span class="line">                        &quot;For security reasons, WebView is not allowed in privileged processes&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_WEBVIEW, &quot;WebViewFactory.getProvider()&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;WebViewFactoryProvider&gt; providerClass = getProviderClass();</span><br><span class="line">                Method staticFactory = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    staticFactory = providerClass.getMethod(</span><br><span class="line">                        CHROMIUM_WEBVIEW_FACTORY_METHOD, WebViewDelegate.class);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Log.w(LOGTAG, &quot;error instantiating provider with static factory method&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的单用户检测，安全调用之类的代码就先忽略了。集中注意力看Provider实例创建的代码，大家可以看到，这里的创建其实通过反射调用创建的。这里有一个关键的方法<code>getProviderClass()</code>，这个方法可能获取到真正的Provider类对象，跟踪这个方法调用，我们看到了如下的调用过程：<br><code>getProviderClass() -&gt; getWebViewProviderClass</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;WebViewFactoryProvider&gt; getWebViewProviderClass(ClassLoader clazzLoader)</span><br><span class="line">           throws ClassNotFoundException &#123;</span><br><span class="line">       return (Class&lt;WebViewFactoryProvider&gt;) Class.forName(CHROMIUM_WEBVIEW_FACTORY,</span><br><span class="line">               true, clazzLoader);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>看到了吗？<code>CHROMIUM_WEBVIEW_FACTORY</code> 这才是真正的<code>WebViewFactoryProvider</code>类声明，跟进这个常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final String CHROMIUM_WEBVIEW_FACTORY = &quot;com.android.webview.chromium.WebViewChromiumFactoryProviderForO&quot;;</span><br></pre></td></tr></table></figure></p>
<p>从命名ForO来看，这个类恰好是用于最新版本Android系统<code>Oreo</code>的。没错，这里我们就从最新版本的源码入手，找到真正的问题”元凶“。</p>
<p>可是，这个代码在哪里呢？你搜索安卓源码，根本搜索不到该类，这是为什么呢？也许你已经猜到了，其实这段代码就来自于Chrome核心工程 <strong>chromium</strong>。这段代码，大家通过谷歌搜索找找看，这里我们以官方版本的代码为准：<br><a href="https://chromium.googlesource.com/chromium/src.git/+/28cc253ce347f9a58a0e7c6b7b249c239c4b2669/android_webview/glue/java/src/com/android/webview/chromium/WebViewChromiumFactoryProviderForO.java" target="_blank" rel="noopener">WebViewChromiumFactoryProviderForO</a></p>
<p>具体代码很简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.android.webview.chromium;</span><br><span class="line">class WebViewChromiumFactoryProviderForO extends WebViewChromiumFactoryProvider &#123;</span><br><span class="line">    public static WebViewChromiumFactoryProvider create(android.webkit.WebViewDelegate delegate) &#123;</span><br><span class="line">        return new WebViewChromiumFactoryProviderForO(delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    protected WebViewChromiumFactoryProviderForO(android.webkit.WebViewDelegate delegate) &#123;</span><br><span class="line">        super(delegate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LOL，可是，你以为真的很简单吗？其实不然，实现在父类，跟进父类。这个时候千万保持清醒，别跟丢了哦。我们想要的是Provider的创建过程，这个是Provider工厂类的真正类型，由它完成WebViewProvider的创建。</p>
<p>如果你已经忘了，我们再来回顾一下刚刚创建WebViewProvider的代码，别走神，看这里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void ensureProviderCreated() &#123;</span><br><span class="line">      checkThread();</span><br><span class="line">      if (mProvider == null) &#123;</span><br><span class="line">          // As this can get called during the base class constructor chain, pass the minimum</span><br><span class="line">          // number of dependencies here; the rest are deferred to init().</span><br><span class="line">          mProvider = getFactory().createWebView(this, new PrivateAccess());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到了吗？这里拿到工厂类之后，调用了createWebView方法创建了Provider对象。那好办了，我们在<code>WebViewChromiumFactoryProviderForO</code>的父类<code>WebViewChromiumFactoryProvider</code>直接搜索<code>createWebView</code>方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public WebViewProvider createWebView(WebView webView, WebView.PrivateAccess privateAccess) &#123;</span><br><span class="line">        return new WebViewChromium(this, webView, privateAccess, mShouldDisableThreadChecking);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>怎么样，这段代码熟悉吗？这里直接返回了一个WebViewChromium对象，也就是说，WebView的所有操作，都由WebViewChromium帮忙完成。好吧，我们继续跟进这个类。可是跟进这个类做什么呢？哈哈，忘了吧，我们的目的是寻找<code>addJavascriptInterface</code>实现。稍等，容我先擦一把汗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void addJavascriptInterface(final Object obj, final String interfaceName) &#123;</span><br><span class="line">      if (checkNeedsPost()) &#123;</span><br><span class="line">          mFactory.addTask(new Runnable() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void run() &#123;</span><br><span class="line">                  addJavascriptInterface(obj, interfaceName);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      mAwContents.addJavascriptInterface(obj, interfaceName);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>稍微瞅一眼这个方法<code>checkNeedsPost</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected boolean checkNeedsPost() &#123;</span><br><span class="line">       boolean needsPost = !mFactory.hasStarted() || !ThreadUtils.runningOnUiThread();</span><br><span class="line">       if (!needsPost &amp;&amp; mAwContents == null) &#123;</span><br><span class="line">           throw new IllegalStateException(&quot;AwContents must be created if we are not posting!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       return needsPost;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>简单理解一下，如果已经启动或者调用该方法的线程不在UI线程，则需要post到UI线程中去，这里很明显，我们的调用是在UI线程中。因此，我们之间走下面的分支: <code>mAwContents.addJavascriptInterface(obj, interfaceName);</code>。那么，问题来了，AwContent又是什么鬼？在哪里创建的呢？</p>
<p>仔细查找这个类，我们发现AwContent是在initForReal方法中被创建的。而initForReal调用来自init方法。可是，init方法是在哪里调用的呢？答案是：WebView。看下面的截图：<br><img src="http://upload-images.jianshu.io/upload_images/703764-d2adacd680391f4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>OK，继续往下，看AwContent是怎么创建的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void initForReal() &#123;</span><br><span class="line">       AwContentsStatics.setRecordFullDocument(sRecordWholeDocumentEnabledByApi</span><br><span class="line">               || mAppTargetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP);</span><br><span class="line">       mAwContents = new AwContents(mFactory.getBrowserContextOnUiThread(), mWebView, mContext,</span><br><span class="line">               new InternalAccessAdapter(), new WebViewNativeDrawGLFunctorFactory(),</span><br><span class="line">               mContentsClientAdapter, mWebSettings.getAwSettings(),</span><br><span class="line">               new AwContents.DependencyFactory() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public AutofillProvider createAutofillProvider(</span><br><span class="line">                           Context context, ViewGroup containerView) &#123;</span><br><span class="line">                       return mFactory.createAutofillProvider(context, mWebView);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">       if (mAppTargetSdkVersion &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">           // On KK and above, favicons are automatically downloaded as the method</span><br><span class="line">           // old apps use to enable that behavior is deprecated.</span><br><span class="line">           AwContents.setShouldDownloadFavicons();</span><br><span class="line">       &#125;</span><br><span class="line">       if (mAppTargetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">           // Prior to Lollipop, JavaScript objects injected via addJavascriptInterface</span><br><span class="line">           // were not inspectable.</span><br><span class="line">           mAwContents.disableJavascriptInterfacesInspection();</span><br><span class="line">       &#125;</span><br><span class="line">       // TODO: This assumes AwContents ignores second Paint param.</span><br><span class="line">       mAwContents.setLayerType(mWebView.getLayerType(), null);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一些版本兼容判断，与本文探讨主题无关，先忽略。好了，看到这里，大家是不是感觉被安卓源码忽悠的团团转，最开始我们天真地以为真正的调用来自WebView，安卓系统告诉我们来自WebViewProvider，我们以为这应该就是头了。可是现在又出现了一个AwContent。那么，它是不是真正的最终调用者呢？继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @see ContentViewCore#addPossiblyUnsafeJavascriptInterface(Object, String, Class)</span><br><span class="line">     */</span><br><span class="line">    @SuppressLint(&quot;NewApi&quot;)  // JavascriptInterface requires API level 17.</span><br><span class="line">    public void addJavascriptInterface(Object object, String name) &#123;</span><br><span class="line">        if (TRACE) Log.i(TAG, &quot;%s addJavascriptInterface=%s&quot;, this, name);</span><br><span class="line">        if (isDestroyedOrNoOperation(WARN)) return;</span><br><span class="line">        Class&lt;? extends Annotation&gt; requiredAnnotation = null;</span><br><span class="line">        if (mAppTargetSdkVersion &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123;</span><br><span class="line">            requiredAnnotation = JavascriptInterface.class;</span><br><span class="line">        &#125;</span><br><span class="line">        mContentViewCore.addPossiblyUnsafeJavascriptInterface(object, name, requiredAnnotation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我擦，又来了一个调用对象<code>mContentViewCore</code>。Relax，继续往下看，看它的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void addPossiblyUnsafeJavascriptInterface(Object object, String name,</span><br><span class="line">        Class&lt;? extends Annotation&gt; requiredAnnotation) &#123;</span><br><span class="line">    if (mNativeContentViewCore != 0 &amp;&amp; object != null) &#123;</span><br><span class="line">        mJavaScriptInterfaces.put(name, object);</span><br><span class="line">        nativeAddJavascriptInterface(mNativeContentViewCore, object, name, requiredAnnotation,</span><br><span class="line">                mRetainedJavaScriptObjects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看方法名，nativeAddJavascriptInterface看起来最终调用来自于Native，继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private native void nativeAddJavascriptInterface(int nativeContentViewCoreImpl, Object object,</span><br><span class="line">         String name, Class requiredAnnotation, HashSet&lt;Object&gt; retainedObjectSet);</span><br></pre></td></tr></table></figure></p>
<p>接下来看C++代码，这里的中间调用过程没有深究，但最终应该是来到了这里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">static void AddJavascriptInterface(JNIEnv *env, jobject obj, jint nativeFramePointer,</span><br><span class="line">        jobject javascriptObj, jstring interfaceName)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef ANDROID_INSTRUMENT</span><br><span class="line">    TimeCounterAuto counter(TimeCounter::NativeCallbackTimeCounter);</span><br><span class="line">#endif</span><br><span class="line">    WebCore::Frame* pFrame = 0;</span><br><span class="line">    if (nativeFramePointer == 0)</span><br><span class="line">        pFrame = GET_NATIVE_FRAME(env, obj);</span><br><span class="line">    else</span><br><span class="line">        pFrame = (WebCore::Frame*)nativeFramePointer;</span><br><span class="line">    LOG_ASSERT(pFrame, &quot;nativeAddJavascriptInterface must take a valid frame pointer!&quot;);</span><br><span class="line">    JavaVM* vm;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;vm);</span><br><span class="line">    LOGV(&quot;::WebCore:: addJSInterface: %p&quot;, pFrame);</span><br><span class="line">#if USE(JSC)</span><br><span class="line">    // Copied from qwebframe.cpp</span><br><span class="line">    JSC::JSLock lock(false);</span><br><span class="line">    WebCore::JSDOMWindow *window = WebCore::toJSDOMWindow(pFrame);</span><br><span class="line">    if (window) &#123;</span><br><span class="line">        JSC::Bindings::RootObject *root = pFrame-&gt;script()-&gt;bindingRootObject();</span><br><span class="line">        JSC::Bindings::setJavaVM(vm);</span><br><span class="line">        // Add the binding to JS environment</span><br><span class="line">        JSC::ExecState* exec = window-&gt;globalExec();</span><br><span class="line">        JSC::JSObject *addedObject = WeakJavaInstance::create(javascriptObj,</span><br><span class="line">                root)-&gt;createRuntimeObject(exec);</span><br><span class="line">        const jchar* s = env-&gt;GetStringChars(interfaceName, NULL);</span><br><span class="line">        if (s) &#123;</span><br><span class="line">            // Add the binding name to the window&apos;s table of child objects.</span><br><span class="line">            JSC::PutPropertySlot slot;</span><br><span class="line">            window-&gt;put(exec, JSC::Identifier(exec, (const UChar *)s, </span><br><span class="line">                    env-&gt;GetStringLength(interfaceName)), addedObject, slot);</span><br><span class="line">            env-&gt;ReleaseStringChars(interfaceName, s);</span><br><span class="line">            checkException(env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif  // USE(JSC)</span><br><span class="line">#if USE(V8)</span><br><span class="line">    if (pFrame) &#123;</span><br><span class="line">        const char* name = JSC::Bindings::getCharactersFromJStringInEnv(env, interfaceName);</span><br><span class="line">        NPObject* obj = JSC::Bindings::JavaInstanceToNPObject(new JSC::Bindings::JavaInstance(javascriptObj));</span><br><span class="line">        pFrame-&gt;script()-&gt;bindToWindowObject(pFrame, name, obj);</span><br><span class="line">        // JavaInstanceToNPObject calls NPN_RetainObject on the</span><br><span class="line">        // returned one (see CreateV8ObjectForNPObject in V8NPObject.cpp).</span><br><span class="line">        // BindToWindowObject also increases obj&apos;s ref count and decrease</span><br><span class="line">        // the ref count when the object is not reachable from JavaScript</span><br><span class="line">        // side. Code here must release the reference count increased by</span><br><span class="line">        // JavaInstanceToNPObject.</span><br><span class="line">        _NPN_ReleaseObject(obj);</span><br><span class="line">        JSC::Bindings::releaseCharactersForJString(interfaceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的代码量较大，我们主要关注下面这一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window-&gt;put(exec, JSC::Identifier(exec, (const UChar *)s, </span><br><span class="line">                   env-&gt;GetStringLength(interfaceName)), addedObject, slot);</span><br></pre></td></tr></table></figure></p>
<p>最终数据的处理原来来自于C++端的window对象，这又是什么呢？继续看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebCore::JSDOMWindow *window = WebCore::toJSDOMWindow(pFrame);</span><br></pre></td></tr></table></figure></p>
<p>这是在WebCore命名空间下面的<code>JSDOMWindow</code>对象，看到这里，其实大多数同学应该已经都没有兴趣看下去了。这实在是一个冗长的调用过程，而且在阅读源码过程中，我们还忽略多进程调用，忽略各种细节。对此，关于这段源码的阅读，我们暂且告一段落，等时间充裕，我再来补充。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次的问题牵扯了移动端、Web前端和后台，这种跨平台的问题解决起来的确存在很大的困难。其实，我已经很长时间没有写JS了，仅仅在几个月前使用RN的时候有了解一些ES6的语法。凭借刚刚工作时仅有的2个月JS经验，加上在多方面知识的累积，总算顺利解决了问题。其实，根据我的经验来看，越是看起来无头绪的问题，往往越是一个极其简单的问题。为了避免出现这种问题，在编码过程中，必须小心翼翼。尽量多检查几次，避免出现类似这样的错误。另外，要尝试接受不一样的观点，如果你一开始就接受了其他人的观点，在解决问题上就会有很强的目的性，解决问题的速度也就更快。</p>
<blockquote>
<p>最后，新的一年里，祝大家万事如意，阖家欢乐，工作顺顺利利，身体健健康康。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/01/02/bug fix/记一次印象深刻的Bug追踪过程/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 欧阳锋工作室. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
            <h4 id="about-card-name">欧阳锋工作室</h4>
        
            <div id="about-card-bio"><p>Stay hungry, stay foolish</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>深圳一行代码科技有限公司创始人</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                广东深圳
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-uxpinu5umcabfr9aiy0uhzftnioszmvauq3qgkh8evzewnqgit0fhssjlsfq.min.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
