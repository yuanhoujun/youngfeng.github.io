
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="欧阳锋工作室">
    <title>归档 - 欧阳锋工作室</title>
    <meta name="author" content="欧阳锋工作室">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="关注欧阳锋工作室，你想知道的都在这里~">
<meta property="og:type" content="blog">
<meta property="og:title" content="欧阳锋工作室">
<meta property="og:url" content="http://youngfeng.com/archives/page/3/index.html">
<meta property="og:site_name" content="欧阳锋工作室">
<meta property="og:description" content="关注欧阳锋工作室，你想知道的都在这里~">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欧阳锋工作室">
<meta name="twitter:description" content="关注欧阳锋工作室，你想知道的都在这里~">
    
    
        
    
    
        <meta property="og:image" content="http://youngfeng.com/assets/images/avatar.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-n3h5fvwrba2ezx3jjewg1itrl3r4ognmb0rqhxoh9kr7ltfomtbpdedrggqw.min.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            欧阳锋工作室
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">欧阳锋工作室</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Stay hungry, stay foolish</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="搜索"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/yuanhoujun" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/assets/images/mpwexin.jpg"
                            title="微信公众号"
                        >
                    
                        <i class="sidebar-button-icon fab fa-weixin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微信公众号</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://weibo.com/u/6140262139?is_all=1" target="_blank" rel="noopener" title="微博">
                    
                        <i class="sidebar-button-icon fab fa-weibo" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微博</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:ouyangfeng2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/01/26/kotlin/用Kotlin写Android-Gradle脚本/"
                            aria-label=": 也许你应该试试用Kotlin写Gradle脚本"
                        >
                            也许你应该试试用Kotlin写Gradle脚本
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-26T10:48:00+08:00">
	
		    1月 26, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/杂谈/">杂谈</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="http://upload-images.jianshu.io/upload_images/703764-1ba63891256d9db2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文 | 欧阳锋"></p>
<blockquote>
<p>Android应用开发中，离不开Gradle脚本的构建。大部分Android开发同学忽视了脚本的力量，甚至有很大一部分同学不知道Gradle脚本是什么，用什么语言编写的；当然，也有相当一部分同学知道Gradle脚本是使用Groovy语言编写的，但对于Groovy语言却一窍不通，只是勉强可以看懂Gradle脚本。正所谓，知其然，但并不知其所以然…</p>
</blockquote>
<p>换个角度看问题，熟练掌握Gradle脚本还需要精通Groovy语言，这对Android开发同学来说的确是一个不小的挑战。这种Java + Groovy的开发套餐对于普通的Android开发者来说的确存在一定的知识断层，显而易见的是，部分同学写的Gradle脚本简直“不堪入目”。时间回到去年5月份，Google IO大会上宣布了一个重磅消息，Android官方开始支持使用Kotlin语言进行应用开发。其实，在这个时间节点上，我已经在生产环境使用Kotlin开发Android将近一年。对于我来说，这无疑是一个让人欣喜若狂的消息。但，惊喜还远远不止这些，过了一段时间，我又看到了这篇文章 <a href="https://blog.gradle.org/kotlin-meets-gradle" target="_blank" rel="noopener">Kotlin Meets Gradle</a>。很有诗意的标题：当Gradle邂逅Kotlin，文章的核心意思是：<strong>Gradle团队正在尝试使用Kotlin语言作为Gradle脚本的官方开发语言。</strong></p>
<blockquote>
<p>我想，也许，Android开发者的春天就要到了！</p>
</blockquote>
<h1 id="Why-use-Kotlin"><a href="#Why-use-Kotlin" class="headerlink" title="Why use Kotlin ?"></a>Why use Kotlin ?</h1><p>在写Gradle脚本的时候，最痛苦的莫过于没有任何提示，唯一的调试手段就是使用<strong>print</strong>方法打印调试日志。正如 <a href="https://blog.gradle.org/kotlin-meets-gradle" target="_blank" rel="noopener">Kotlin Meets Gradle</a> 文中所说，当你使用Kotlin语言编写Gradle脚本的时候，你会发现一切都变得有趣起来。突然：</p>
<ul>
<li>脚本代码可以自动补全了</li>
<li>源码之间可以互相跳转了</li>
<li>插件源码更容易看懂了</li>
<li>重构（Refactoring）也可以支持了<br>…</li>
</ul>
<p>当然，惊喜还不止这些，当你开始决定使用Kotlin语言的时候，仿佛一切都变得美好了起来！</p>
<h1 id="Let’s-start"><a href="#Let’s-start" class="headerlink" title="Let’s start"></a>Let’s start</h1><p>好了，废话不多说，接下来我们开始尝试用Kotlin语言编写Gradle脚本。由于当前 <a href="https://github.com/gradle/kotlin-dsl" target="_blank" rel="noopener">kotlin-dsl</a> 正处于预发布状态（<strong>kotlin-dsl</strong>的最新版本是0.14.2，对应Gradle插件版本4.5），IDE的支持也不完善，为了更好的体验该功能，推荐大家使用如下配置：</p>
<h3 id="实验室配置"><a href="#实验室配置" class="headerlink" title="实验室配置"></a>实验室配置</h3><p><strong>操作系统：</strong>macOS 10.13.2<br><strong>Android Studio：</strong> 3.1 Canary 9<br><strong>Gradle Wrapper：</strong> 4.5<br><strong>Gradle Plugin：</strong> 3.1.0-alpha9<br><strong>Kotlin</strong>：1.2.21</p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>首先，按照以往步骤创建一个Android工程：<br><img src="http://upload-images.jianshu.io/upload_images/703764-58f93d293addaba0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来，改造开始，Gradle Script Kotlin脚本以<code>.gradle.kts</code>后缀结尾。因此，我们先将工程根目录<code>settings.gradle</code>更名为<code>settings.gradle.kts</code>。<br><img src="http://upload-images.jianshu.io/upload_images/703764-429cf07b4fcaf7bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个地方的错误有两个原因：</p>
<ul>
<li>Kotlin语言中，单引号只能包裹字符，不能包裹字符串</li>
<li>Kotlin语言中，方法调用使用括号。仅在使用<code>infix</code>修饰的方法中可以省略括号。这里显然是一个正常调用方法。因此，我们修改为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include(&quot;app&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>接下来，修改根目录的<code>build.gradle</code>脚本，用同样的方式修改后缀，方法修改为括号调用，修改后的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        // 这里修改为括号调用即可</span><br><span class="line">        classpath(&quot;com.android.tools.build:gradle:3.0.1&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：在修改后缀名称的时候IDE会出现警告提示，这里可以忽略，选择<strong>continue</strong>即可。</p>
</blockquote>
<p>由于我们手动修改了<code>build.gradle</code>脚本，为了保证工程可以使用这个脚本，需要在<code>settings.gradle.kts</code>中添加一行代码，让Gradle知道使用<code>build.gradle.kts</code>脚本构建。因此，最后的<code>settings.gradle.kts</code>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include(&quot;app&quot;)</span><br><span class="line">rootProject.buildFileName = &quot;build.gradle.kts&quot;</span><br></pre></td></tr></table></figure></p>
<p>最后一步，修改app模块<code>build.gradle</code>文件，这也是最复杂的一步，修改完后缀名后，你会看到整个脚本全部被红色标识错误：<br><img src="http://upload-images.jianshu.io/upload_images/703764-fcca2611413c7e31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>别慌！还是一样的方式，这里我们先将这里的所有代码注释掉。在最上方逐一对应修改，<code>apply plugin</code>部分修改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(&quot;com.android.application&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，修改<code>android {}</code>闭包部分。这里有两个小技巧，由于目前IDE的支持不是很完善，在输入的时候稍微等待一段时间，IDE会给出相应的提示。另外，如果没有提示，例如<code>android {}</code>闭包就没有任何提示，输入完成后展开右侧gradle面板，选择<code>gradle/buid setup/init</code>，双击执行：<br><img src="http://upload-images.jianshu.io/upload_images/703764-4710f3eea9bac093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在底部面板可以看到任务执行是否成功。注意，即使任务执行成功，脚本依然可能被红色标识，这是IDE支持不完善导致的，可以忽略。</p>
<p>修改完成后的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion(27)</span><br><span class="line">    buildToolsVersion(&quot;27.0.2&quot;)</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId = &quot;com.youngfeng.kotlindsl&quot;</span><br><span class="line">        minSdkVersion(15)</span><br><span class="line">        targetSdkVersion(27)</span><br><span class="line">        versionCode = 1</span><br><span class="line">        versionName = &quot;1.0&quot;</span><br><span class="line">        testInstrumentationRunner = &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        getByName(&quot;release&quot;) &#123;</span><br><span class="line">            isMinifyEnabled = true</span><br><span class="line">            proguardFiles(getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：你在使用的过程中，依然可能会遇到无论如何都不生效的问题。这个时候别着急，使用<code>./gradlew assembleDebug</code>命令调试，查看终端找到错误原因。Windows用户去掉<code>./</code>执行即可。<br><img src="http://upload-images.jianshu.io/upload_images/703764-1e9abe6a47044d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>最后的依赖部分，同样地，全部修改为括号调用即可。这里就不赘述了，文章的最后部分会提供操作视频，在使用过程中有任何问题可以打开操作视频参考，如果依然不能解决，可以在文章下方给我留言，我会在第一时间给你答复。修改后的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(fileTree(mapOf(&quot;dir&quot; to &quot;libs&quot;, &quot;include&quot; to listOf(&quot;*.jar&quot;))))</span><br><span class="line">    implementation(&quot;com.android.support:appcompat-v7:26.1.0&quot;)</span><br><span class="line">    implementation(&quot;com.android.support.constraint:constraint-layout:1.0.2&quot;)</span><br><span class="line">    testImplementation(&quot;junit:junit:4.12&quot;)</span><br><span class="line">    androidTestImplementation(&quot;com.android.support.test:runner:1.0.1&quot;)</span><br><span class="line">    androidTestImplementation(&quot;com.android.support.test.espresso:espresso-core:3.0.1&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的步骤，从Groovy转换到Kotlin的步骤已经全部完成，你可以在终端输入<code>./gradlew assembleDebug</code>测试是否可以正常构建了：<br><img src="http://upload-images.jianshu.io/upload_images/703764-2ec3894242b02f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="统一依赖管理"><a href="#统一依赖管理" class="headerlink" title="统一依赖管理"></a>统一依赖管理</h1><p>上面的步骤虽然完成了脚本的转换，但依赖的管理依然是混乱的，为了实现类似<br> <a href="https://github.com/yuanhoujun/Android_Slide_To_Close" target="_blank" rel="noopener">Snake</a> 工程的统一依赖管理，我们还需要做一些工作。</p>
<p>Gradle官方提供了使用 <a href="https://docs.gradle.org/current/userguide/organizing_build_logic.html#sec:build_sources" target="_blank" rel="noopener">buildSrc</a> 目录实现自定义任务和插件逻辑，这里我们可以使用它完成依赖的统一处理，一个完整的buildSrc目录结构如下：<br><img src="http://upload-images.jianshu.io/upload_images/703764-a000e0ab037ab1a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Deps类中，可以这样定义依赖结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">object deps &#123;</span><br><span class="line">    object plugin &#123;</span><br><span class="line">        val gradle = &quot;com.android.tools.build:gradle:3.1.0-alpha09&quot;</span><br><span class="line">        val kotlin = &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.2.21&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    object kotlin &#123;</span><br><span class="line">        val stdlibJre7 = &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.21&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    object android &#123;</span><br><span class="line">        object support &#123;</span><br><span class="line">            val compat = &quot;com.android.support:appcompat-v7:27.0.2&quot;</span><br><span class="line">            val constraintLayout = &quot;com.android.support.constraint:constraint-layout:1.0.2&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        object test &#123;</span><br><span class="line">            val junit = &quot;junit:junit:4.12&quot;</span><br><span class="line">            val runner = &quot;com.android.support.test:runner:1.0.1&quot;</span><br><span class="line">            val espressoCore = &quot;com.android.support.test.espresso:espresso-core:3.0.1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义之后，我们就可以在脚本中直接引用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(fileTree(mapOf(&quot;dir&quot; to &quot;libs&quot;, &quot;include&quot; to listOf(&quot;*.jar&quot;))))</span><br><span class="line">    implementation(deps.kotlin.stdlibJre7)</span><br><span class="line">    implementation(deps.android.support.compat)</span><br><span class="line">    implementation(deps.android.support.constraintLayout)</span><br><span class="line">    testImplementation(deps.android.test.junit)</span><br><span class="line">    androidTestImplementation(deps.android.test.runner)</span><br><span class="line">    androidTestImplementation(deps.android.test.espressoCore)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是漂亮了许多？</p>
<p>至此，整个转换过程就顺利完成了，为了保证转换的成功率，我推荐使用文章开头的实验室配置。如果版本过低，不保证可以转换成功。最新版本的<strong>kotlin-dsl</strong>会跟随最新版本的Gradle插件发布，因此一定要使用最新版本。另外，目前IDE对kts的支持依然不完善，即使正确的写法也会报错，这个一定要注意，不要被IDE欺骗了。</p>
<h3 id="更详细的操作，请看视频教程"><a href="#更详细的操作，请看视频教程" class="headerlink" title="更详细的操作，请看视频教程"></a>更详细的操作，请看视频教程</h3><p>腾讯视频：<a href="https://v.qq.com/x/page/x0539lvfmm2.html" target="_blank" rel="noopener">用Kotlin写Android Gradle脚本</a></p>
<h4 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h4><p>虽然使用Kotlin语言写脚本是一件非常美妙的事情，但目前依然存在一些问题：</p>
<ul>
<li>IDE支持不完善</li>
<li><a href="https://github.com/gradle/kotlin-dsl" target="_blank" rel="noopener">kotlin-dsl</a> 正在快速开发中，语法变动较大</li>
<li>缺少官方文档</li>
<li>互联网上缺少相关资料，遇到问题很难追踪</li>
</ul>
<p>因此，目前我并不推荐你在生产环境中使用，但可以作为日常学习练手之用。预计1.0版本的发布在今年6月份左右，正式版本发布后，我推荐你立即将Gradle脚本转换到Kotlin语言。</p>
<h4 id="遇到问题，看这里-gt"><a href="#遇到问题，看这里-gt" class="headerlink" title="遇到问题，看这里 ==&gt;"></a>遇到问题，看这里 ==&gt;</h4><p>在使用的过程中，按照文章同样的步骤，你依然可能会遇到很多问题。因此，我为你整理了目前互联网上可以参考的资料，你可以收藏这篇文章。遇到问题别慌，来这里查找答案。</p>
<p>关于<strong>kotlin-dsl</strong>的开发路线图，请看这篇文章：<a href="https://blog.gradle.org/kotlin-scripting-update" target="_blank" rel="noopener">https://blog.gradle.org/kotlin-scripting-update</a></p>
<p>如果你在使用过程中，遇到了任何问题，并且确定是 <strong>kotlin-dsl</strong> 的bug，请点这里：<a href="https://github.com/gradle/kotlin-dsl" target="_blank" rel="noopener">https://github.com/gradle/kotlin-dsl</a> 并推送 <strong>issue</strong></p>
<p>如果你遇到了知识盲点，并且在Google找不到答案。可以来 <a href="https://kotlinlang.slack.com/" target="_blank" rel="noopener">Slack</a>#gradle频道反馈，我在 <a href="https://kotlinlang.slack.com/" target="_blank" rel="noopener">Slack</a> 的昵称是<strong>Scott Smith</strong>，也欢迎你给我发送私信消息。<br><img src="http://upload-images.jianshu.io/upload_images/703764-995957884721bca9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>本篇文章例子完整代码，请点击这里：<a href="https://github.com/yuanhoujun/gradle-script-kotlin-example" target="_blank" rel="noopener">https://github.com/yuanhoujun/gradle-script-kotlin-example</a></p>
<p>kts文档正在编写当中，具体进度，请点这里：<a href="https://github.com/gradle/kotlin-dsl-docs" target="_blank" rel="noopener">https://github.com/gradle/kotlin-dsl-docs</a></p>
<h1 id="欢迎加入Kotlin交流群"><a href="#欢迎加入Kotlin交流群" class="headerlink" title="欢迎加入Kotlin交流群"></a>欢迎加入Kotlin交流群</h1><p>如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/01/26/kotlin/用Kotlin写Android-Gradle脚本/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/01/02/bug fix/记一次印象深刻的Bug追踪过程/"
                            aria-label=": 记一次印象深刻的Bug追踪过程"
                        >
                            记一次印象深刻的Bug追踪过程
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-01-02T18:03:00+08:00">
	
		    1月 02, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Bug-Fix/">Bug Fix</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>问题现象：使用安卓手机以小程序的形式分享产品到微信，使用微信打开，产品详情数据无法显示。而使用iPhone分享到微信，却始终可以正常打开，这个时候所有的矛头都指向了安卓同学。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-cdf26125f909ddcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小程序中打开，显示空白"></p>
<p>逻辑设计说明：这里的分享数据来自H5接口，通过<code>addJavascriptInterface</code>自定义接口完成H5和Java端的数据传递，产品ID来自后台接口获取。</p>
<p>这个时候，安卓同学首先做出了响应，通过调试拿到了JS端的数据，以下是这位小陈同学的截图消息：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-bd7a8a062dfab805.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android调试结果"></p>
<p>小陈同学这个时候把问题抛给了Web前端同学小徐，以为小徐传递了科学计数法的ID字符串。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-4dcd326299b5e4d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>大家看小陈同学的截图，图中的ID是使用字符串接收的，这个时候我已经完全排除问题出现在安卓端的可能性了。于是，我问小徐，H5有对参数进行处理吗？得到的答案如下：<br><img src="http://upload-images.jianshu.io/upload_images/703764-a28fd422fa316bcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>大家看到图中，我已经给出了确定的答案，认为问题来自于后台。因为，后台同学之前的确出现过对ID进行toInt处理最终转换为负数的情况。现在在传递时出现这种低级错误的概率应该也挺高的。这段话抛出去之后，团队炸开了锅，有同学认为大家在互相推诿…</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-4ec531bb958ae6be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其实，还有很长的截图，这里没有展示出来。群里提到最多的一句话就是：<code>iOS没问题啊</code>。就连我们的运维同学以及UI设计同学都加入了“讨伐”队伍，种种迹象似乎都指向了安卓同学。这个时候，我们的安卓同学真是“哑巴吃黄连，有苦说不出”，心里的潜台词肯定是：我TM的就用<code>string</code>接收了一下，我招谁惹谁了我！</p>
<p>但其实出现这种不知所踪的情况，完全可以理解，大家大都集中在单一平台开发，对于其它环节的理解难免有偏差。其实，用常识来理解这个问题的话，的确后台的概率比较大，前端同学对ID进行运算处理的概率几乎为0，这一点即使是刚刚入行的新手也不太可能。而我一直苦等的后台同学却迟迟没有响应，我目前始终无法确定问题到底来自于后台还是Web前端。直到我终于看到了下面的截图。<br><img src="http://upload-images.jianshu.io/upload_images/703764-fc7196333abaedbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这个时候，我终于有九成的把握确定问题来自于Web前端了。可是，我知道我不能明说。前端同学已经在聊天记录中给出了证据，在Chrome的控制台打印出了正常的id值，到了安卓端却出现了异常。前端同学这个时候心里也有了一个定性结论，问题来自安卓端。这个时候，我只能亲自上场，而恰好我在外面，正在办理深圳户口，比较不便。于是，我微信给小陈发消息，嘱咐它把详情页的源码“爬”下来，我回来看看源码。</p>
<p>回到家的时候，我问小陈html源码是否已经“爬”了下来，他给我发来截图，我意识到前端使用了https协议，没法获取html源码。于是，我想了一个办法，在源码中嵌入一段代码，通过代码的形式获取WebView产品详情页的数据。这个方法果然奏效，不一会儿，小陈就发来了页面的html源码。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-de788a95449192ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>哎哟，我的天哪！混淆后的代码简直不堪入目，不过还好，我可以搜索方法关键字<code>showShareView</code>。可是，很遗憾没有搜索到，事件的绑定被放到了JS代码中。在这段源码中，我注意到一个文件名已经被混淆的JS文件，我猜想代码应该就在这里。可是，怎样抓到具体的方法呢？</p>
<p>灵机一动！我之前在代码中让小陈把Debug权限开发给了H5，这次正好可以派上用场。可是，对于混淆后的代码，我心里依然有点打退堂鼓。</p>
<p>连上手机，在Chrome浏览器中输入chrome://inpsect，点击相应链接，非常顺利地进入了调试界面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-753ad81eaaf2318d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在控制台的Source中，我通过关键词搜索找到了混淆后的JS代码片段，在方法名前面增加了一个断点，等调试到底方法位置的时候。这个时候已经获取到了JS的上下文，直接通过<code>this.gid</code>打印出了当前产品ID信息，居然是一个非常正常的整型数字。大家注意，这已经是一个在安卓端出问题的产品了，在JS端居然显示是正常的。这个时候，我的大脑非常转动，我的第一感觉应该是<code>webkit</code>内核看到接收的字符串全是数字做了”自以为是“的转换。于是，我给出了团队如下的答案：<br><img src="http://upload-images.jianshu.io/upload_images/703764-02b3c3a21e2b0569.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>为了进一步确定我的猜想，我让小陈写了一个简单的Demo，通过JS接口传递一个非常大的数字字符串给Java端，看接收是否异常。不一会儿，我就得到了答案：<br><img src="http://upload-images.jianshu.io/upload_images/703764-64ba7132c99d0a56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>至此，我终于基本确定问题的原因了！<br>猜测：JS在传递数据给安卓端的时候，应该是使用了基本数据类型。而<code>webkit</code>内核在处理的时候可能是以JS端数据类型为准，在传递到Java端时候做了转换。</p>
<p>为了验证这个猜想，我使用<code>typeof</code>打印id的数据类型，得到了如下结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-7615a576bf35a125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>于是，我告诉小徐，问题来自于你没有传递正确的数据类型给安卓端。其实这是比较危险的，不同CPU可以容纳的最大整型值是不一样的。如果iOS端和安卓处理一致，也是以JS端数据类型为准，只不过iOS的CPU字节宽度较大，恰好在iPhone高端机型上面没有出现而低端机型出现的话。其实问题依然存在，而如果iOS的确是以Native端数据类型为准。这就根本不是一个问题。但答案虽然给了团队，可是小徐仍然一脸狐疑，没有经验的CTO也是跟着一脸狐疑，加上解决问题的时间较长。小徐在发布更新的时候也遇到了问题，导致更新失败，问题持续，整个问题一直在持续。</p>
<p>这个时候，我告诉小徐，你发布更新后先别着急，确定更新成功后再告诉团队小伙伴。</p>
<p>一直到确定更新成功，我们再次尝试分享，问题终于引刃而解！</p>
<blockquote>
<p>问题虽然解决了，可是，安卓系统为什么要这样处理呢？为什么不能以Native端数据类型为准呢？带着这个疑问，我开始查看安卓源码。</p>
</blockquote>
<p>阅读安卓源码是一个痛苦的过程，随着系统版本的升级，安卓系统的兼容性代码越来越多，这给阅读带来了极大的困难。加上安卓系统本身源码量巨大，阅读源码就像在一个巨大的森林中寻找宝藏一样。这个时候，其实你非常容易迷路，而我知道，只要我坚信我想要什么，就一定可以找到。</p>
<p>这里我们以<code>addJavascriptInterface</code>这个方法作为突破口，进入源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void addJavascriptInterface(Object object, String name) &#123;</span><br><span class="line">       checkThread();</span><br><span class="line">       mProvider.addJavascriptInterface(object, name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>额，mProvider是什么鬼？难道WebView只是一个傀儡，真正处理业务的其实是mProvider？是的，没错！WebView只不过是一个壳而已！可是，mProvider的实现到底是什么呢？带着这个疑问，我们看到了如下mProvider实例创建的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void ensureProviderCreated() &#123;</span><br><span class="line">      checkThread();</span><br><span class="line">      if (mProvider == null) &#123;</span><br><span class="line">          // As this can get called during the base class constructor chain, pass the minimum</span><br><span class="line">          // number of dependencies here; the rest are deferred to init().</span><br><span class="line">          mProvider = getFactory().createWebView(this, new PrivateAccess());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static WebViewFactoryProvider getFactory() &#123;</span><br><span class="line">      return WebViewFactory.getProvider();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>又出现了一个工厂方法，别怕，继续往下追踪：<br>getProvider方法较长，我们截取部分，看下面源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static WebViewFactoryProvider getProvider() &#123;</span><br><span class="line">        synchronized (sProviderLock) &#123;</span><br><span class="line">            // For now the main purpose of this function (and the factory abstraction) is to keep</span><br><span class="line">            // us honest and minimize usage of WebView internals when binding the proxy.</span><br><span class="line">            if (sProviderInstance != null) return sProviderInstance;</span><br><span class="line"></span><br><span class="line">            final int uid = android.os.Process.myUid();</span><br><span class="line">            if (uid == android.os.Process.ROOT_UID || uid == android.os.Process.SYSTEM_UID</span><br><span class="line">                    || uid == android.os.Process.PHONE_UID || uid == android.os.Process.NFC_UID</span><br><span class="line">                    || uid == android.os.Process.BLUETOOTH_UID) &#123;</span><br><span class="line">                throw new UnsupportedOperationException(</span><br><span class="line">                        &quot;For security reasons, WebView is not allowed in privileged processes&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_WEBVIEW, &quot;WebViewFactory.getProvider()&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Class&lt;WebViewFactoryProvider&gt; providerClass = getProviderClass();</span><br><span class="line">                Method staticFactory = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    staticFactory = providerClass.getMethod(</span><br><span class="line">                        CHROMIUM_WEBVIEW_FACTORY_METHOD, WebViewDelegate.class);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Log.w(LOGTAG, &quot;error instantiating provider with static factory method&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的单用户检测，安全调用之类的代码就先忽略了。集中注意力看Provider实例创建的代码，大家可以看到，这里的创建其实通过反射调用创建的。这里有一个关键的方法<code>getProviderClass()</code>，这个方法可能获取到真正的Provider类对象，跟踪这个方法调用，我们看到了如下的调用过程：<br><code>getProviderClass() -&gt; getWebViewProviderClass</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;WebViewFactoryProvider&gt; getWebViewProviderClass(ClassLoader clazzLoader)</span><br><span class="line">           throws ClassNotFoundException &#123;</span><br><span class="line">       return (Class&lt;WebViewFactoryProvider&gt;) Class.forName(CHROMIUM_WEBVIEW_FACTORY,</span><br><span class="line">               true, clazzLoader);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>看到了吗？<code>CHROMIUM_WEBVIEW_FACTORY</code> 这才是真正的<code>WebViewFactoryProvider</code>类声明，跟进这个常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final String CHROMIUM_WEBVIEW_FACTORY = &quot;com.android.webview.chromium.WebViewChromiumFactoryProviderForO&quot;;</span><br></pre></td></tr></table></figure></p>
<p>从命名ForO来看，这个类恰好是用于最新版本Android系统<code>Oreo</code>的。没错，这里我们就从最新版本的源码入手，找到真正的问题”元凶“。</p>
<p>可是，这个代码在哪里呢？你搜索安卓源码，根本搜索不到该类，这是为什么呢？也许你已经猜到了，其实这段代码就来自于Chrome核心工程 <strong>chromium</strong>。这段代码，大家通过谷歌搜索找找看，这里我们以官方版本的代码为准：<br><a href="https://chromium.googlesource.com/chromium/src.git/+/28cc253ce347f9a58a0e7c6b7b249c239c4b2669/android_webview/glue/java/src/com/android/webview/chromium/WebViewChromiumFactoryProviderForO.java" target="_blank" rel="noopener">WebViewChromiumFactoryProviderForO</a></p>
<p>具体代码很简单，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.android.webview.chromium;</span><br><span class="line">class WebViewChromiumFactoryProviderForO extends WebViewChromiumFactoryProvider &#123;</span><br><span class="line">    public static WebViewChromiumFactoryProvider create(android.webkit.WebViewDelegate delegate) &#123;</span><br><span class="line">        return new WebViewChromiumFactoryProviderForO(delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    protected WebViewChromiumFactoryProviderForO(android.webkit.WebViewDelegate delegate) &#123;</span><br><span class="line">        super(delegate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LOL，可是，你以为真的很简单吗？其实不然，实现在父类，跟进父类。这个时候千万保持清醒，别跟丢了哦。我们想要的是Provider的创建过程，这个是Provider工厂类的真正类型，由它完成WebViewProvider的创建。</p>
<p>如果你已经忘了，我们再来回顾一下刚刚创建WebViewProvider的代码，别走神，看这里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void ensureProviderCreated() &#123;</span><br><span class="line">      checkThread();</span><br><span class="line">      if (mProvider == null) &#123;</span><br><span class="line">          // As this can get called during the base class constructor chain, pass the minimum</span><br><span class="line">          // number of dependencies here; the rest are deferred to init().</span><br><span class="line">          mProvider = getFactory().createWebView(this, new PrivateAccess());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到了吗？这里拿到工厂类之后，调用了createWebView方法创建了Provider对象。那好办了，我们在<code>WebViewChromiumFactoryProviderForO</code>的父类<code>WebViewChromiumFactoryProvider</code>直接搜索<code>createWebView</code>方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public WebViewProvider createWebView(WebView webView, WebView.PrivateAccess privateAccess) &#123;</span><br><span class="line">        return new WebViewChromium(this, webView, privateAccess, mShouldDisableThreadChecking);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>怎么样，这段代码熟悉吗？这里直接返回了一个WebViewChromium对象，也就是说，WebView的所有操作，都由WebViewChromium帮忙完成。好吧，我们继续跟进这个类。可是跟进这个类做什么呢？哈哈，忘了吧，我们的目的是寻找<code>addJavascriptInterface</code>实现。稍等，容我先擦一把汗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void addJavascriptInterface(final Object obj, final String interfaceName) &#123;</span><br><span class="line">      if (checkNeedsPost()) &#123;</span><br><span class="line">          mFactory.addTask(new Runnable() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void run() &#123;</span><br><span class="line">                  addJavascriptInterface(obj, interfaceName);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      mAwContents.addJavascriptInterface(obj, interfaceName);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>稍微瞅一眼这个方法<code>checkNeedsPost</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected boolean checkNeedsPost() &#123;</span><br><span class="line">       boolean needsPost = !mFactory.hasStarted() || !ThreadUtils.runningOnUiThread();</span><br><span class="line">       if (!needsPost &amp;&amp; mAwContents == null) &#123;</span><br><span class="line">           throw new IllegalStateException(&quot;AwContents must be created if we are not posting!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       return needsPost;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>简单理解一下，如果已经启动或者调用该方法的线程不在UI线程，则需要post到UI线程中去，这里很明显，我们的调用是在UI线程中。因此，我们之间走下面的分支: <code>mAwContents.addJavascriptInterface(obj, interfaceName);</code>。那么，问题来了，AwContent又是什么鬼？在哪里创建的呢？</p>
<p>仔细查找这个类，我们发现AwContent是在initForReal方法中被创建的。而initForReal调用来自init方法。可是，init方法是在哪里调用的呢？答案是：WebView。看下面的截图：<br><img src="http://upload-images.jianshu.io/upload_images/703764-d2adacd680391f4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>OK，继续往下，看AwContent是怎么创建的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void initForReal() &#123;</span><br><span class="line">       AwContentsStatics.setRecordFullDocument(sRecordWholeDocumentEnabledByApi</span><br><span class="line">               || mAppTargetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP);</span><br><span class="line">       mAwContents = new AwContents(mFactory.getBrowserContextOnUiThread(), mWebView, mContext,</span><br><span class="line">               new InternalAccessAdapter(), new WebViewNativeDrawGLFunctorFactory(),</span><br><span class="line">               mContentsClientAdapter, mWebSettings.getAwSettings(),</span><br><span class="line">               new AwContents.DependencyFactory() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public AutofillProvider createAutofillProvider(</span><br><span class="line">                           Context context, ViewGroup containerView) &#123;</span><br><span class="line">                       return mFactory.createAutofillProvider(context, mWebView);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">       if (mAppTargetSdkVersion &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">           // On KK and above, favicons are automatically downloaded as the method</span><br><span class="line">           // old apps use to enable that behavior is deprecated.</span><br><span class="line">           AwContents.setShouldDownloadFavicons();</span><br><span class="line">       &#125;</span><br><span class="line">       if (mAppTargetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">           // Prior to Lollipop, JavaScript objects injected via addJavascriptInterface</span><br><span class="line">           // were not inspectable.</span><br><span class="line">           mAwContents.disableJavascriptInterfacesInspection();</span><br><span class="line">       &#125;</span><br><span class="line">       // TODO: This assumes AwContents ignores second Paint param.</span><br><span class="line">       mAwContents.setLayerType(mWebView.getLayerType(), null);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一些版本兼容判断，与本文探讨主题无关，先忽略。好了，看到这里，大家是不是感觉被安卓源码忽悠的团团转，最开始我们天真地以为真正的调用来自WebView，安卓系统告诉我们来自WebViewProvider，我们以为这应该就是头了。可是现在又出现了一个AwContent。那么，它是不是真正的最终调用者呢？继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @see ContentViewCore#addPossiblyUnsafeJavascriptInterface(Object, String, Class)</span><br><span class="line">     */</span><br><span class="line">    @SuppressLint(&quot;NewApi&quot;)  // JavascriptInterface requires API level 17.</span><br><span class="line">    public void addJavascriptInterface(Object object, String name) &#123;</span><br><span class="line">        if (TRACE) Log.i(TAG, &quot;%s addJavascriptInterface=%s&quot;, this, name);</span><br><span class="line">        if (isDestroyedOrNoOperation(WARN)) return;</span><br><span class="line">        Class&lt;? extends Annotation&gt; requiredAnnotation = null;</span><br><span class="line">        if (mAppTargetSdkVersion &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123;</span><br><span class="line">            requiredAnnotation = JavascriptInterface.class;</span><br><span class="line">        &#125;</span><br><span class="line">        mContentViewCore.addPossiblyUnsafeJavascriptInterface(object, name, requiredAnnotation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我擦，又来了一个调用对象<code>mContentViewCore</code>。Relax，继续往下看，看它的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void addPossiblyUnsafeJavascriptInterface(Object object, String name,</span><br><span class="line">        Class&lt;? extends Annotation&gt; requiredAnnotation) &#123;</span><br><span class="line">    if (mNativeContentViewCore != 0 &amp;&amp; object != null) &#123;</span><br><span class="line">        mJavaScriptInterfaces.put(name, object);</span><br><span class="line">        nativeAddJavascriptInterface(mNativeContentViewCore, object, name, requiredAnnotation,</span><br><span class="line">                mRetainedJavaScriptObjects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看方法名，nativeAddJavascriptInterface看起来最终调用来自于Native，继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private native void nativeAddJavascriptInterface(int nativeContentViewCoreImpl, Object object,</span><br><span class="line">         String name, Class requiredAnnotation, HashSet&lt;Object&gt; retainedObjectSet);</span><br></pre></td></tr></table></figure></p>
<p>接下来看C++代码，这里的中间调用过程没有深究，但最终应该是来到了这里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">static void AddJavascriptInterface(JNIEnv *env, jobject obj, jint nativeFramePointer,</span><br><span class="line">        jobject javascriptObj, jstring interfaceName)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef ANDROID_INSTRUMENT</span><br><span class="line">    TimeCounterAuto counter(TimeCounter::NativeCallbackTimeCounter);</span><br><span class="line">#endif</span><br><span class="line">    WebCore::Frame* pFrame = 0;</span><br><span class="line">    if (nativeFramePointer == 0)</span><br><span class="line">        pFrame = GET_NATIVE_FRAME(env, obj);</span><br><span class="line">    else</span><br><span class="line">        pFrame = (WebCore::Frame*)nativeFramePointer;</span><br><span class="line">    LOG_ASSERT(pFrame, &quot;nativeAddJavascriptInterface must take a valid frame pointer!&quot;);</span><br><span class="line">    JavaVM* vm;</span><br><span class="line">    env-&gt;GetJavaVM(&amp;vm);</span><br><span class="line">    LOGV(&quot;::WebCore:: addJSInterface: %p&quot;, pFrame);</span><br><span class="line">#if USE(JSC)</span><br><span class="line">    // Copied from qwebframe.cpp</span><br><span class="line">    JSC::JSLock lock(false);</span><br><span class="line">    WebCore::JSDOMWindow *window = WebCore::toJSDOMWindow(pFrame);</span><br><span class="line">    if (window) &#123;</span><br><span class="line">        JSC::Bindings::RootObject *root = pFrame-&gt;script()-&gt;bindingRootObject();</span><br><span class="line">        JSC::Bindings::setJavaVM(vm);</span><br><span class="line">        // Add the binding to JS environment</span><br><span class="line">        JSC::ExecState* exec = window-&gt;globalExec();</span><br><span class="line">        JSC::JSObject *addedObject = WeakJavaInstance::create(javascriptObj,</span><br><span class="line">                root)-&gt;createRuntimeObject(exec);</span><br><span class="line">        const jchar* s = env-&gt;GetStringChars(interfaceName, NULL);</span><br><span class="line">        if (s) &#123;</span><br><span class="line">            // Add the binding name to the window&apos;s table of child objects.</span><br><span class="line">            JSC::PutPropertySlot slot;</span><br><span class="line">            window-&gt;put(exec, JSC::Identifier(exec, (const UChar *)s, </span><br><span class="line">                    env-&gt;GetStringLength(interfaceName)), addedObject, slot);</span><br><span class="line">            env-&gt;ReleaseStringChars(interfaceName, s);</span><br><span class="line">            checkException(env);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif  // USE(JSC)</span><br><span class="line">#if USE(V8)</span><br><span class="line">    if (pFrame) &#123;</span><br><span class="line">        const char* name = JSC::Bindings::getCharactersFromJStringInEnv(env, interfaceName);</span><br><span class="line">        NPObject* obj = JSC::Bindings::JavaInstanceToNPObject(new JSC::Bindings::JavaInstance(javascriptObj));</span><br><span class="line">        pFrame-&gt;script()-&gt;bindToWindowObject(pFrame, name, obj);</span><br><span class="line">        // JavaInstanceToNPObject calls NPN_RetainObject on the</span><br><span class="line">        // returned one (see CreateV8ObjectForNPObject in V8NPObject.cpp).</span><br><span class="line">        // BindToWindowObject also increases obj&apos;s ref count and decrease</span><br><span class="line">        // the ref count when the object is not reachable from JavaScript</span><br><span class="line">        // side. Code here must release the reference count increased by</span><br><span class="line">        // JavaInstanceToNPObject.</span><br><span class="line">        _NPN_ReleaseObject(obj);</span><br><span class="line">        JSC::Bindings::releaseCharactersForJString(interfaceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的代码量较大，我们主要关注下面这一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window-&gt;put(exec, JSC::Identifier(exec, (const UChar *)s, </span><br><span class="line">                   env-&gt;GetStringLength(interfaceName)), addedObject, slot);</span><br></pre></td></tr></table></figure></p>
<p>最终数据的处理原来来自于C++端的window对象，这又是什么呢？继续看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebCore::JSDOMWindow *window = WebCore::toJSDOMWindow(pFrame);</span><br></pre></td></tr></table></figure></p>
<p>这是在WebCore命名空间下面的<code>JSDOMWindow</code>对象，看到这里，其实大多数同学应该已经都没有兴趣看下去了。这实在是一个冗长的调用过程，而且在阅读源码过程中，我们还忽略多进程调用，忽略各种细节。对此，关于这段源码的阅读，我们暂且告一段落，等时间充裕，我再来补充。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次的问题牵扯了移动端、Web前端和后台，这种跨平台的问题解决起来的确存在很大的困难。其实，我已经很长时间没有写JS了，仅仅在几个月前使用RN的时候有了解一些ES6的语法。凭借刚刚工作时仅有的2个月JS经验，加上在多方面知识的累积，总算顺利解决了问题。其实，根据我的经验来看，越是看起来无头绪的问题，往往越是一个极其简单的问题。为了避免出现这种问题，在编码过程中，必须小心翼翼。尽量多检查几次，避免出现类似这样的错误。另外，要尝试接受不一样的观点，如果你一开始就接受了其他人的观点，在解决问题上就会有很强的目的性，解决问题的速度也就更快。</p>
<blockquote>
<p>最后，新的一年里，祝大家万事如意，阖家欢乐，工作顺顺利利，身体健健康康。</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/01/02/bug fix/记一次印象深刻的Bug追踪过程/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2016/08/22/kotlin/delegation/"
                            aria-label=": Kotlin 代理模式"
                        >
                            Kotlin 代理模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2016-08-22T00:25:00+08:00">
	
		    8月 22, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>代理模式是23种经典设计模式之一，代理模式被认为是继承的更好替代解决方案；因为代理比继承更加灵活，在Java语言中，通过反射可以实现动态代理，动态代理可以实现<strong>AOP</strong>编程，即：可以动态地往已有类中添加逻辑；比如：实现事务的自动提交，异常的自动捕获，热修复等等; </p>
<p>在Kotlin语言中，代理模式是默认支持的，不需要任何额外的代码，你只需要记住一个关键字<strong>by</strong>。我们不妨来试一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Base &#123;</span><br><span class="line">    fun sayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaseImpl : Base &#123;</span><br><span class="line">    override fun sayHi() &#123;</span><br><span class="line">        println(&quot;BaseImpl-&gt;sayHi&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Derived(b: Base) : Base by b</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val b = BaseImpl()</span><br><span class="line">    val derived = Derived(b)</span><br><span class="line">    derived.sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里Derived作为BaseImpl的代理类，拥有BaseImpl类中的所有方法，Derived将代理BaseImpl类执行BaseImpl类中的所有方法，就像继承自BaseImpl类一样。这样说起来有点抽象，来看一下Kotlin编译器具体为我们做了一些什么。但是，怎么看呢？教大家一个方法！<br>大家都知道，Kotlin和Java均是JVM语言，最终均转换到同样的Java字节码，这样我们就可以先将Kotlin编译为.class文件，再反编译为.java文件，看看对应的Java代码，我们就可以看到更多的细节。下面是最终反编译生成的Java代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Derived implements Base &#123;</span><br><span class="line">  public Derived(@NotNull Base b) &#123;</span><br><span class="line">    this.$$delegate_0 = b;</span><br><span class="line">  &#125;</span><br><span class="line">  public void sayHi() &#123;</span><br><span class="line">    this.$$delegate_0.sayHi();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们可以清楚地看到，Kotlin编译器为我们动态添加了一个成员变量$$delegate_0，这个成员变量代表被代理的对象，这里对应的是BaseImpl对象，Derived里面的sayHi方法最终调用是代理对象的sayHi方法，即Kotlin编译器帮我们提供了一个非常漂亮的代理模式实现。</p>
<h1 id="代理属性"><a href="#代理属性" class="headerlink" title="代理属性"></a>代理属性</h1><p>在一些情况下，我们可能希望某些属性延迟加载，即在我们正在需要的时候才对它赋值；亦或者我们希望可以随时监听属性值的变化；在上述这些场景中，代理属性就可以发挥作用了。</p>
<p>代理属性的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class DelegateProperty &#123;</span><br><span class="line">	val d: String by Delegate()</span><br><span class="line">&#125;</span><br><span class="line">class Delegate &#123;</span><br><span class="line">    operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;): String &#123;</span><br><span class="line">        return &quot;Invoke getValue() , thisRef = $thisRef , property name = $&#123;property.name&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: String) &#123;</span><br><span class="line">        println(&quot;Invoke setValue() , thisRef = $thisRef , property name = $&#123;property.name&#125; , value = $value&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val dp = DelegatedProperty()</span><br><span class="line">    dp.d = &quot;Value0&quot; // Invoke setValue() , thisRef = DelegatedProperty@2ef1e4fa , property name = d , value = Value0</span><br><span class="line">   </span><br><span class="line">    println(dp.d) // Invoke getValue() , thisRef = DelegatedProperty@2ef1e4fa , property name = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代理是如何实现的呢？我们知道，Kotlin的属性值会自动生成set/get方法，而代理类通过代理set/get方法生成相应的代理方法，这里的方法对应关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// thisRef对应代理对象的引用，property对应代理属性的反射属性封装</span><br><span class="line">// 注意这里的代理方法一定要添加operator关键字，operator关键字是重载操作符关键字，后续的文章中会讲到，敬请期待</span><br><span class="line">get() -&gt; operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;)</span><br><span class="line">set() -&gt; operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: T)</span><br></pre></td></tr></table></figure>
<p>Kotlin标准库提供了一些常用代理的方法实现，即上文提到的几种代理，先来看第一种：延迟加载。</p>
<h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>Kotlin提供了一个lazy方法用于实现延迟加载，lazy方法有一个lambda表达式参数，用于对属性进行初始化赋值，而一旦完成赋值，该lambda表达式将不会再次调用。lambda表达式调用发生在第一次使用该属性的时候，即实现了属性赋值的延迟加载。来看一个简单的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用标准库实现的lazy函数，实现属性的延迟加载</span><br><span class="line">private val lazyValue: String by lazy &#123;</span><br><span class="line">    println(&quot;调用该初始赋值表达式完成赋值&quot;)</span><br><span class="line">    // 这里是实际赋值</span><br><span class="line">    &quot;Hello, world&quot;</span><br><span class="line">&#125;</span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // 仅在第一次会调用lazy方法的lambda表达式</span><br><span class="line">    println(lazyValue) // 打印：调用该初始赋值表达式完成赋值</span><br><span class="line">    println(lazyValue) // 打印： Hello, world, 再次调用将不再调用lambda表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lazy方法是一个线程安全的延迟加载方法，为了加深大家的理解，根据上面的原理，我们尝试自己来实现一个非线程安全的延迟加载方法，看具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private object UNINITIALIZE_VALUE</span><br><span class="line"></span><br><span class="line">class MyLazy&lt;T&gt;(initialize: ()-&gt;T) &#123;</span><br><span class="line">    private var value: Any? = UNINITIALIZE_VALUE</span><br><span class="line">    private val initialize = initialize</span><br><span class="line">    operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;): T &#123;</span><br><span class="line">        if(value == UNINITIALIZE_VALUE) &#123;</span><br><span class="line">            value = initialize()</span><br><span class="line">        &#125;</span><br><span class="line">        return value as T</span><br><span class="line">    &#125;</span><br><span class="line">    operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: T) &#123;</span><br><span class="line">        this.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 为了和标准库区分，使用__lazy命名</span><br><span class="line">fun &lt;T&gt;  __lazy(initialize: () -&gt; T): MyLazy&lt;T&gt; = MyLazy(initialize)</span><br><span class="line"></span><br><span class="line">var lazyValue1 by __lazy &#123;</span><br><span class="line">    println(&quot;自定义lazy初始化赋值表达式被调用&quot;)</span><br><span class="line">    &quot;Hello , world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // 自定义延迟加载函数__lazy</span><br><span class="line">    println(lazyValue1)</span><br><span class="line">    lazyValue1 = &quot;Other value&quot;</span><br><span class="line">    println(lazyValue1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，实现一个延迟加载接口并不复杂，最重要的是要理解延迟加载的过程以及实现原理。总结实现延迟加载接口，需要注意三个地方：</p>
<ul>
<li>需要提供初始化lambda表达式参数，用于初始赋值</li>
<li>需要实现代理属性对象的setValue/getValue方法，如果是val则只需要实现getValue即可</li>
<li>需要严格确保属性不会被多次初始化 </li>
</ul>
<h3 id="Observable属性"><a href="#Observable属性" class="headerlink" title="Observable属性"></a>Observable属性</h3><p>Kotlin标准库还提供了一个可观察属性，这个属性使用观察者模式实现，如果属性值发生变化则会调用相应的回调lambda接口通知使用者，先看一个具体的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var observableValue by Delegates.observable(&quot;Initial value&quot;) &#123;  prop , old , new -&gt;</span><br><span class="line">    println(&quot;$old -&gt; $new&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(observableValue)    // 打印：Initial value</span><br><span class="line">    observableValue = &quot;Hello&quot;   // 打印: Initial value -&gt; Hello</span><br><span class="line">    println(observableValue)    // 打印：Hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的具体实现，感兴趣的同学请参看文章开头的方法进行追踪！</p>
<h3 id="Storing-Properties-in-a-Map"><a href="#Storing-Properties-in-a-Map" class="headerlink" title="Storing Properties in a Map"></a>Storing Properties in a Map</h3><p>这也是Kotlin标准库提供的一个非常有用的特性，它主要用于JSON数据的解析。看官方的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User(val map: Map&lt;String, Any?&gt;) &#123;</span><br><span class="line">	val name: String by map</span><br><span class="line">	val age: Int by map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val user = User(mapOf(</span><br><span class="line">	&quot;name&quot; to &quot;John Doe&quot;,</span><br><span class="line">	&quot;age&quot; to 25</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>该方法比较简单，这里就不再赘述了！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，关于代理的介绍可以暂时告一段落了！<br>代理模式是一个非常经典设计模式，在解决某些问题中可以发挥事半功倍的效果。幸运的是，Kotlin语言原生支持代理模式，实现代理模式如同声明一个属性一样简单。而且，代理模式的设计也非常漂亮，仅仅使用一个关键字by极尽简约之美。在日常编码中，一定要灵活运用代理模式，比如实现延迟加载，实现属性观察等等。<a href="https://github.com/JakeWharton/kotterknife" target="_blank" rel="noopener">KotterKnife</a> 是一个非常经典的代理模式的实现例子，有兴趣的同学可以clone该仓库，查看源码，领会代理模式的优美。</p>
<h1 id="欢迎加入Kotlin交流群"><a href="#欢迎加入Kotlin交流群" class="headerlink" title="欢迎加入Kotlin交流群"></a>欢迎加入Kotlin交流群</h1><p>如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。</p>
<h1 id="文章源码地址"><a href="#文章源码地址" class="headerlink" title="文章源码地址"></a>文章源码地址</h1><p>Kotliner: <a href="https://github.com/yuanhoujun/Kotliner" target="_blank" rel="noopener">https://github.com/yuanhoujun/Kotliner</a>,<br>别忘了点击仓库右上方的star哦！</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2016/08/22/kotlin/delegation/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/page/2/"
                aria-label="上一页"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一页</span>
            </a>
          </li>
        
        
        <li class="pagination-number">第 3 页 共 3 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 欧阳锋工作室. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
            <h4 id="about-card-name">欧阳锋工作室</h4>
        
            <div id="about-card-bio"><p>Stay hungry, stay foolish</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>深圳一行代码科技有限公司创始人</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                广东深圳
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-uxpinu5umcabfr9aiy0uhzftnioszmvauq3qgkh8evzewnqgit0fhssjlsfq.min.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
