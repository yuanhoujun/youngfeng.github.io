
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="欧阳锋工作室">
    <title>归档: 2018/2 - 欧阳锋工作室</title>
    <meta name="author" content="欧阳锋工作室">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="关注欧阳锋工作室，你想知道的都在这里~">
<meta property="og:type" content="blog">
<meta property="og:title" content="欧阳锋工作室">
<meta property="og:url" content="http://youngfeng.com/archives/2018/02/index.html">
<meta property="og:site_name" content="欧阳锋工作室">
<meta property="og:description" content="关注欧阳锋工作室，你想知道的都在这里~">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欧阳锋工作室">
<meta name="twitter:description" content="关注欧阳锋工作室，你想知道的都在这里~">
    
    
        
    
    
        <meta property="og:image" content="http://youngfeng.com/assets/images/avatar.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-n3h5fvwrba2ezx3jjewg1itrl3r4ognmb0rqhxoh9kr7ltfomtbpdedrggqw.min.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            欧阳锋工作室
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">欧阳锋工作室</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Stay hungry, stay foolish</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/yuanhoujun" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/assets/images/mpwexin.jpg"
                            title="微信公众号"
                        >
                    
                        <i class="sidebar-button-icon fab fa-weixin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微信公众号</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://weibo.com/u/6140262139?is_all=1" target="_blank" rel="noopener" title="微博">
                    
                        <i class="sidebar-button-icon fab fa-weibo" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微博</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:ouyangfeng2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/02/28/about ouyangfeng/欧阳锋档案馆/"
                            aria-label=": 欧阳锋档案馆"
                        >
                            欧阳锋档案馆
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-02-28T22:24:00+08:00">
	
		    2月 28, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/关于欧阳锋/">关于欧阳锋</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>你好，欢迎来到欧阳锋档案馆！你可能已经看过了我的一些文章，但对应欧阳锋工作室可能依然比较陌生。这篇文章主要记录当前欧阳锋工作室的主要关注渠道，以及最新的一些进展。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-379667eaf372fef7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文 | 欧阳锋"></p>
<h1 id="关注渠道"><a href="#关注渠道" class="headerlink" title="关注渠道"></a>关注渠道</h1><p>官方网站：<a href="http://www.youngfeng.com" target="_blank" rel="noopener">http://www.youngfeng.com</a></p>
<p>微信公众号：<strong>欧阳锋工作室</strong>(微信号：OuyangfengOffice)</p>
<p>新浪微博：<a href="https://weibo.com/u/6140262139?refer_flag=1001030201_" target="_blank" rel="noopener">欧阳锋工作室</a></p>
<p>GitHub：<a href="https://github.com/yuanhoujun" target="_blank" rel="noopener">https://github.com/yuanhoujun</a></p>
<p>简书：<a href="https://www.jianshu.com/u/db019edd34b4" target="_blank" rel="noopener">https://www.jianshu.com/u/db019edd34b4</a></p>
<h1 id="交流群"><a href="#交流群" class="headerlink" title="交流群"></a>交流群</h1><p>iOS交流群：468167089<br>Kotlin语言交流群：329673958</p>
<hr>
<p>我是欧阳锋，我期待着与你的邂逅 &lt;&lt; </p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/02/28/about ouyangfeng/欧阳锋档案馆/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/02/15/about ouyangfeng/2017年终总结/"
                            aria-label=": 2017年终总结"
                        >
                            2017年终总结
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-02-15T23:59:00+08:00">
	
		    2月 15, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/关于欧阳锋/">关于欧阳锋</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="http://upload-images.jianshu.io/upload_images/703764-4df72af2723c2087.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Yes, I&#39;m ready"></p>
<blockquote>
<p>2017年对于我来说，是收获的一年。这一年，我放弃了一份稳定的工作，去尝试了一份生死未卜的事业。我以为我会后悔，相反，我很庆幸这个决定。虽然，失去了稳定，却在跌宕起伏中收获了不一样的精彩…</p>
</blockquote>
<p>这一年，我在公司主要负责移动部门技术管理工作。移动部门技术同学水平参差不齐、管理涣散是前期遇到的最大的一个问题。为此，我制定了一个简单的计划：</p>
<ul>
<li>定期工作汇报</li>
<li>技术培训</li>
<li>代码Review</li>
<li>定期会议</li>
</ul>
<h2 id="定期工作汇报"><a href="#定期工作汇报" class="headerlink" title="定期工作汇报"></a>定期工作汇报</h2><p>定期工作汇报的效果是显著的，在汇报工作的过程中，通过互相对比，彼此会看到自己的不足，加以改进。在工作汇报的设计上，我没有采用日报的形式，我认为日报有点太过机械化了，甚至有可能导致一定的负面情绪。因此，我把工作汇报集中在周二和周四，仅仅两天的时间既不会太紧凑，也不会太松散。虽然工作汇报在团队中形成了一个良好的氛围，但因为技术实力薄弱带来的问题依然暴露了很多。以至于在团队中出现了一些负面情绪，前端同学在抱怨后端开发，后端开发也在推责前端，气氛一度紧张。在这样一种情形下，我认为技术培训工作已经迫在眉睫了。</p>
<h2 id="技术培训"><a href="#技术培训" class="headerlink" title="技术培训"></a>技术培训</h2><p>技术培训工作是这一年最用心的工作之一，培训的核心主要集中在Kotlin语言。团队中几乎所有的同学对Kotlin语言都是陌生的，仅仅停留在最基础的用法上面，这显然不行！针对这个问题，我将培训内容集中在Kotlin重难点攻克上面。</p>
<p>回顾过去一年，我大约进行了十多次技术培训，内容包括：</p>
<ul>
<li>Kotlin基础知识</li>
<li>Kotlin难点攻克</li>
<li>Git基础用法（针对公司全员）</li>
<li>Android常见问题解决方案</li>
<li>从Swift看Kotlin</li>
<li>基础网络知识</li>
<li>基础调试技巧培训（adb，gradle，Linux)</li>
</ul>
<p>其中一部分内容是作为技术分享课程进行的，准备这些课程其实并不容易。但依然有极少数同学对于培训课程不屑一顾，即使在课堂上再三强调过的问题，在实际开发中依然屡屡再犯。为此，在技术层面上，我想我还需要做更多的工作。</p>
<h2 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h2><p>与往常不一样，这一次我决定使用Pull Request的方式合并代码。这样，我可以对每一次提交进行Code Review。每一次的Pull Request我都会逐行检查，并且会对每一次的打回整理一个完整的文档描述问题出在哪里。</p>
<p>不得不说，Code Review的效果是显著的，团队中一些代码风格很差的同学。经过几次代码被打回的洗礼之后，代码风格有了很大的改善。然而，遗憾的是，后期由于工作过于繁忙，这个部分的工作也慢慢取消了。</p>
<p>整体而言，Code Review的确带动了团队整体编码水平的提升。编码能力提高之后，问题减少了许多。不过，由于前期遗留的一些老问题，导致部分低级错误依然在犯，真是让人心力交瘁。与此同时，团队中另外一个问题也慢慢暴露了出来。你可以很明显地感觉到，团队整体的凝聚力、核心价值观是缺失的，以至于针对同一个问题每个人的聚焦点完全不一样。部分同学采取“当一天和尚撞一天钟”的做法。因此，我认为核心价值观的建设必须尽快搞起来。</p>
<h2 id="定期会议"><a href="#定期会议" class="headerlink" title="定期会议"></a>定期会议</h2><p>为了建立团队核心价值观，我决定定期开展一些会议。然而，由于时间的关系，仅组织了几场会议。但在每次例会结束的时候，我都会做一些核心价值观引导。我一直认为，一个没有核心价值观的公司是一个不完整的公司。这有点类似于“精神出轨”和“肉体出轨”，两者都非常可怕，在IT公司，“精神出轨”的最终症状往往就是“肉体出轨”。但核心价值观的建设是一个漫长的过程，每次会议开完，总感觉收效甚微。内心就像嚼一块过期的臭豆腐，五味杂陈。为此，我改变了策略，决定先带动部分同学，再通过部分同学带动其他同学。有点像旧社会的“让一部分人先富起来”的感觉。这一部分的工作真是举步维艰，不过，好在最后的结果还不错。最终，大部分同学都形成了统一的价值观。</p>
<p>以上，是过去一年我在工作上所做的一些尝试，其实都是一些老生常谈的套路，但实践下来的效果其实还不错。</p>
<p>回首2017年，的确是完全献给工作的一年。这一年，我常常奋战到深夜，即使在周末，也是如此。这一年，我几乎没有出去旅游，甚至于几公里外的徒步都没有。相对往年，时间显得更加稀缺，但与此同时带来的回报也是双倍的。在团队管理上，我有了新的见解；在技术上，我也有了新的突破；在人际关系处理上，我也有了新的进步。</p>
<p>伴随收获随之而来的就是遗憾，这一年主要有两个遗憾。第一个遗憾，对于团队，始终感觉有些亏欠。这一年，我给团队的关键词是“技术”。因此，在团队感情集结、团队建设方面做的工作太少。以至于直到年尾，大家对彼此依然有些陌生，这不得不说是一个很大的遗憾。第二个遗憾，是对自己，17年我给自己定的关键词是“运动”。然而，由于工作的繁忙，锻炼并没有按计划进行，以至于体质一再下降，这不得不说又是一个遗憾，这一部分希望2018年能够及时弥补上来。</p>
<p>明天就是农历2018年了，突然意识到，我已经三十岁了，虽然我很不愿意承认。三十而立，我希望自己可以有一些新的突破。因此，我给自己的2018预设了几个目标，希望在2019年之前可以顺利完成。</p>
<p>最后，感谢所有陪伴我度过2017年的小伙伴们，2018年我会更加努力，让你看到一个更优秀的欧阳锋。这一年我给自己定的年度关键字是“稳”，无论是在事业上，还是在身体上，亦或者是其它方面，都希望可以稳扎稳打、稳步向前。</p>
<p>我是欧阳锋，即使而立之年，我依然相信，只要坚持做一件事情，就一定会成功。我始终偏爱那些无畏困难、不问前程、坚持不懈的人们。我始终怀揣着梦想，2018年我会从“新”出发。2018，祝福正在看文章的你，也能高挂云帆，傲视沧海。</p>
<p>遇见欧阳锋，希望你没有后悔，2018年再见。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/02/15/about ouyangfeng/2017年终总结/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/02/06/kotlin/操作符重载及中缀调用/"
                            aria-label=": Kotlin 操作符重载及中缀调用"
                        >
                            Kotlin 操作符重载及中缀调用
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-02-06T11:39:00+08:00">
	
		    2月 06, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><img src="http://upload-images.jianshu.io/upload_images/703764-0baf2dcfb0baa84f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>操作符重载其实很有意思！但这个概念却很少有人知道，使用操作符重载在某种程度上会给代码的阅读带来一定的麻烦。因此，慎用操作符被认为是一个好习惯。的确，操作符重载是一把双刃剑，既能削铁如泥，也能“引火烧身”，这篇文章将从实用的角度来讲解操作符重载的基本用法。</p>
</blockquote>
<h1 id="支持重载的操作符类型"><a href="#支持重载的操作符类型" class="headerlink" title="支持重载的操作符类型"></a>支持重载的操作符类型</h1><p>Kotlin语言支持重载的操作符类型比较多。以最新版本<strong>1.2.21</strong>为准，目前支持重载的操作符可以归纳为以下几类：</p>
<h1 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h1><h4 id="一元前缀操作符"><a href="#一元前缀操作符" class="headerlink" title="一元前缀操作符"></a>一元前缀操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+a</td>
<td style="text-align:center">a.unaryPlus()</td>
</tr>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">a.unaryMinus()</td>
</tr>
<tr>
<td style="text-align:center">!a</td>
<td style="text-align:center">a.not()</td>
</tr>
</tbody>
</table>
<p>以上三个操作符在日常使用中频率很高，第一个操作符在基本运算中很少使用，第二个操作符就是常见的取反操作，第三个操作符是逻辑取反操作。接下来，我们使用扩展的方式重载这三个操作符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一元操作符</span><br><span class="line"> *</span><br><span class="line"> * @author Scott Smith 2018-02-03 14:11</span><br><span class="line"> */</span><br><span class="line">data class Number(var value: Int)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 重载一元操作符+，使其对Number中实际数据取绝对值</span><br><span class="line"> */</span><br><span class="line">operator fun Number.unaryPlus(): Number &#123;</span><br><span class="line">    this.value = Math.abs(value)</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 重载一元操作符-，使其对Number中实际数据取反</span><br><span class="line"> */</span><br><span class="line">operator fun Number.unaryMinus(): Number &#123;</span><br><span class="line">    this.value = -value</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这个操作符通常是用于逻辑取反，这里用一个没有意义的操作，来模拟重载这个操作符</span><br><span class="line"> * 结果：始终返回Number中实际数据的负值</span><br><span class="line"> */</span><br><span class="line">operator fun Number.not(): Number &#123;</span><br><span class="line">    this.value = -Math.abs(value)</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val number = Number(-3)</span><br><span class="line">    println(&quot;Number value = $&#123;number.value&#125;&quot;)</span><br><span class="line">    println(&quot;After unaryPlus: Number value = $&#123;(+number).value&#125;&quot;)</span><br><span class="line">    println(&quot;After unaryMinus: Number value = $&#123;(-number).value&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    number.value = Math.abs(number.value)</span><br><span class="line">    println(&quot;After unaryNot: Number value = $&#123;(!number).value&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上述代码，将得到如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number value = -3</span><br><span class="line">After unaryPlus: Number value = 3</span><br><span class="line">After unaryMinus: Number value = -3</span><br><span class="line">After unaryNot: Number value = -3</span><br></pre></td></tr></table></figure></p>
<h4 id="自增和自减操作符"><a href="#自增和自减操作符" class="headerlink" title="自增和自减操作符"></a>自增和自减操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a++/++a</td>
<td style="text-align:center">a.inc()</td>
</tr>
<tr>
<td style="text-align:center">a–/–a</td>
<td style="text-align:center">a.dec()</td>
</tr>
</tbody>
</table>
<p>重载这个操作符相对比较难理解，官方文档有一段简短的文字解释，翻译成代码可以这样表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// a++</span><br><span class="line">fun increment(a: Int): Int &#123;</span><br><span class="line">  val a0 = a</span><br><span class="line">  a = a + 1</span><br><span class="line">  return a0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ++a</span><br><span class="line">fun increment(a: Int): Int &#123;</span><br><span class="line">  a = a + 1</span><br><span class="line">  return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看懂上面的代码后，我们换成需要重载的<code>Number</code>类，Kotlin最终会这样处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Number++</span><br><span class="line">fun increment(number: Number): Number &#123;</span><br><span class="line">  val temp = number</span><br><span class="line">  val result = number.inc()</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Number++</span><br><span class="line">fun increment(number: Number): Number &#123;</span><br><span class="line">  return number.inc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，重载<code>Number</code>类自加操作符，我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator fun Number.inc(): Number &#123;</span><br><span class="line">    return Number(this.value + 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重载自减操作符同理，完整代码请参考我的Git版本库：<a href="https://github.com/yuanhoujun/kotlin-samples" target="_blank" rel="noopener">kotlin-samples</a></p>
<h1 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符"></a>二元操作符</h1><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a + b</td>
<td style="text-align:center">a.plus(b)</td>
</tr>
<tr>
<td style="text-align:center">a - b</td>
<td style="text-align:center">a.minus(b)</td>
</tr>
<tr>
<td style="text-align:center">a * b</td>
<td style="text-align:center">a.times(b)</td>
</tr>
<tr>
<td style="text-align:center">a / b</td>
<td style="text-align:center">a.div(b)</td>
</tr>
<tr>
<td style="text-align:center">a % b</td>
<td style="text-align:center">a.rem(b)</td>
</tr>
<tr>
<td style="text-align:center">a..b</td>
<td style="text-align:center">a.rangeTo(b)</td>
</tr>
</tbody>
</table>
<p>前5个操作符相对比较好理解，我们以<code>a + b</code>为例，举个一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 重载Number类的加法运算符</span><br><span class="line">operator fun Number.plus(value: Int): Number &#123;</span><br><span class="line">    return Number(this.value + value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">       println((Number(1) + 2))</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果：</span><br><span class="line">Number value = 3</span><br></pre></td></tr></table></figure></p>
<p>相对比较难理解的是第六个范围运算符，这个操作符主要用于生成一段数据范围。我们认为<code>Number</code>本身就代表一个整型数字，因此，重载<code>Number</code>是一件有意义的事情。直接看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">operator fun Number.rangeTo(to: Number): IntRange &#123;</span><br><span class="line">    return this.value..to.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val startNumber = Number(3)</span><br><span class="line">    val endNumber = Number(9)</span><br><span class="line"></span><br><span class="line">    (startNumber..endNumber).forEach &#123;</span><br><span class="line">        println(&quot;value = $it&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行结果：</span><br><span class="line">value = 3</span><br><span class="line">value = 4</span><br><span class="line">value = 5</span><br><span class="line">value = 6</span><br><span class="line">value = 7</span><br><span class="line">value = 8</span><br><span class="line">value = 9</span><br></pre></td></tr></table></figure></p>
<h4 id="“In”运算符"><a href="#“In”运算符" class="headerlink" title="“In”运算符"></a>“In”运算符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a in b</td>
<td style="text-align:center">b.contains(a)</td>
</tr>
<tr>
<td style="text-align:center">a !in b</td>
<td style="text-align:center">!b.contains(a)</td>
</tr>
</tbody>
</table>
<p>这个操作符相对比较好理解，重载这个操作符可以用于判断某个数据是否在另外一个对象中。我们用一个非常简单的自定义类来模拟集合操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class IntCollection &#123; </span><br><span class="line">    val intList = ArrayList&lt;Int&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重载&quot;in&quot;操作符</span><br><span class="line">operator fun IntCollection.contains(value: Int): Boolean &#123;</span><br><span class="line">    return this.intList.contains(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val intCollection = IntCollection()</span><br><span class="line">    intCollection.add(1, 2, 3)</span><br><span class="line">    println(3 in intCollection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p>
<h4 id="索引访问运算符"><a href="#索引访问运算符" class="headerlink" title="索引访问运算符"></a>索引访问运算符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a[i]</td>
<td style="text-align:center">a.get(i)</td>
</tr>
<tr>
<td style="text-align:center">a[i, j]</td>
<td style="text-align:center">a.get(i, j)</td>
</tr>
<tr>
<td style="text-align:center">a[i_1, …, i_n]</td>
<td style="text-align:center">a.get(i_1, …, i_n)</td>
</tr>
<tr>
<td style="text-align:center">a[i] = b</td>
<td style="text-align:center">a.set(i, b)</td>
</tr>
<tr>
<td style="text-align:center">a[i, j] = b</td>
<td style="text-align:center">a.set(i, j, b)</td>
</tr>
<tr>
<td style="text-align:center">a[i_1, …, i_n] = b</td>
<td style="text-align:center">a.set(i_1, …, i_n, b)</td>
</tr>
</tbody>
</table>
<p>这个操作符很有意思，例如，如果你要访问Map中某个数据，通常是这样的<code>map.get(&quot;key&quot;)</code>，使用索引运算符你还可以这样操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val value = map[&quot;key&quot;]</span><br></pre></td></tr></table></figure></p>
<p>我们继续以<code>IntCollection</code>类为例，尝试重写<code>a[i]</code>和<code>a[i] = b</code>两个运算符，其它运算符同理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 重载a[i]操作符</span><br><span class="line">operator fun IntCollection.get(index: Int): Int &#123;</span><br><span class="line">    return intList[index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重载a[i] = b操作符</span><br><span class="line">operator fun IntCollection.set(index: Int, value: Int) &#123;</span><br><span class="line">    intList[index] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val intCollection = IntCollection()</span><br><span class="line">    intCollection.add(1, 2, 3)</span><br><span class="line">    println(intCollection[0])</span><br><span class="line"></span><br><span class="line">    intCollection[2] = 4</span><br><span class="line">    print(intCollection[2])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们用索引运算符来做一点更有意思的事情！新建一个普通的<code>Kotlin</code>类<code>User</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User(var name: String,</span><br><span class="line">           var age: Int) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用下面的方式重载索引运算符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">operator fun User.get(key: String): Any? &#123;</span><br><span class="line">    when(key) &#123;</span><br><span class="line">        &quot;name&quot; -&gt; &#123;</span><br><span class="line">            return this.name</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;age&quot; -&gt; &#123;</span><br><span class="line">            return this.age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">operator fun User.set(key: String, value:Any?) &#123;</span><br><span class="line">    when(key) &#123;</span><br><span class="line">        &quot;name&quot; -&gt; &#123;</span><br><span class="line">            name = value as? String</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;age&quot; -&gt; &#123;</span><br><span class="line">            age = value as? Int</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，你会神奇地发现，一个普通的<code>Kotlin</code>类居然也可以使用索引运算符对成员变量进行操作了，是不是很神奇？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Scott Smith&quot;, 18)</span><br><span class="line">    println(user[&quot;name&quot;])</span><br><span class="line">    user[&quot;age&quot;] = 22</span><br><span class="line">    println(user[&quot;age&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，索引运算符不仅仅可以对集合类数据进行操作，对一个普通的<code>Kotlin</code>类也可以发挥同样的作用。如果你脑洞足够大，你还可以发现更多更神奇的玩法。</p>
<h4 id="调用操作符"><a href="#调用操作符" class="headerlink" title="调用操作符"></a>调用操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a()</td>
<td style="text-align:center">a.invoke()</td>
</tr>
<tr>
<td style="text-align:center">a(i)</td>
<td style="text-align:center">a.invoke(i)</td>
</tr>
<tr>
<td style="text-align:center">a(i, j)</td>
<td style="text-align:center">a.invoke(i, j)</td>
</tr>
<tr>
<td style="text-align:center">a(i_1, ……, i_n)</td>
<td style="text-align:center">a.invoke(i_1, ……, i_n)</td>
</tr>
</tbody>
</table>
<p>重载这个操作符并不难，理解它的应用场景却有一定的难度。为了理解它的应用场景，我们来举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class JsonParser &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">operator fun JsonParser.invoke(json: String): Map&lt;String, Any&gt; &#123;</span><br><span class="line">    val map = Json.parse(json)</span><br><span class="line">    ...</span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以这样调用</span><br><span class="line">val parser = JsonParser()</span><br><span class="line">val map = parser(&quot;&#123;name: \&quot;Scott Smith\&quot;&#125;&quot;)</span><br></pre></td></tr></table></figure></p>
<p>这里的调用有点像省略了一个解析Json数据的方法，难道它仅仅就是这个作用吗？是的，调用操作符其实就这一个作用。如果一个Kotlin类仅仅只有一个方法，直接使用括号调用的确是一个不错的主意。不过，在使用的时候还是要稍微注意一下，避免出现歧义。</p>
<h4 id="广义赋值操作符"><a href="#广义赋值操作符" class="headerlink" title="广义赋值操作符"></a>广义赋值操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a += b</td>
<td style="text-align:center">a.plusAssign(b)</td>
</tr>
<tr>
<td style="text-align:center">a -= b</td>
<td style="text-align:center">a.minusAssign(b)</td>
</tr>
<tr>
<td style="text-align:center">a *= b</td>
<td style="text-align:center">a.timesAssign(b)</td>
</tr>
<tr>
<td style="text-align:center">a /= b</td>
<td style="text-align:center">a.divAssign(b)</td>
</tr>
<tr>
<td style="text-align:center">a %= b</td>
<td style="text-align:center">a.remAssign(b)</td>
</tr>
</tbody>
</table>
<p>这个操作符相对比较好理解，我们以<code>Number</code>类为例，举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 广义赋值运算符</span><br><span class="line">operator fun Number.plusAssign(value: Int) &#123;</span><br><span class="line">    this.value += value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val number = Number(1)</span><br><span class="line">    number += 2</span><br><span class="line">    println(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">Number value = 3</span><br></pre></td></tr></table></figure></p>
<h4 id="相等与不等操作符"><a href="#相等与不等操作符" class="headerlink" title="相等与不等操作符"></a>相等与不等操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a == b</td>
<td style="text-align:center">a?.equals(b) ?: (b === null)</td>
</tr>
<tr>
<td style="text-align:center">a != b</td>
<td style="text-align:center">!(a?.equals(b) ?: (b === null))</td>
</tr>
</tbody>
</table>
<p>重载这个操作符与Java重写equals方法是一样的。不过，这里要注意与Java的区别，在Java端<code>==</code>用于判断两个对象是否是同一对象（指针级别）。而在Kotlin语言中，如果我们不做任何处理，<code>==</code>等同于使用Java对象的<code>equals</code>方法判断两个对象是否相等。</p>
<p>另外，这里还有一种特殊情况，如果左值等于null，这个时候<code>a?.equals(b)</code>将返回null值。因此，这里还增加了<code>?:</code>运算符用于进一步判断，在这个情况下，当且仅当b === null的时候，a、b才有可能相等。因此，才有了上面的对应关系，这里以<code>User</code>类为例举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class User(var name: String?,</span><br><span class="line">           var age: Int?) &#123;</span><br><span class="line"></span><br><span class="line">    operator override fun equals(other: Any?): Boolean &#123;</span><br><span class="line">        if(other is User) &#123;</span><br><span class="line">            return (this.name == other.name) &amp;&amp; (this.age == other.age)</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：这里有一个特殊的地方，与其它操作符不一样的地方是，如果使用扩展的方式尝试重载该操作符，将会报错。因此，如果要重载该操作符，一定要在类中进行重写。</p>
<h4 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h4><table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a &gt; b</td>
<td style="text-align:center">a.compareTo(b) &gt; 0</td>
</tr>
<tr>
<td style="text-align:center">a &lt; b</td>
<td style="text-align:center">a.compareTo(b) &lt; 0</td>
</tr>
<tr>
<td style="text-align:center">a &gt;= b</td>
<td style="text-align:center">a.compareTo(b) &gt;= 0</td>
</tr>
<tr>
<td style="text-align:center">a &lt;= b</td>
<td style="text-align:center">a.compareTo(b) &lt;= 0</td>
</tr>
</tbody>
</table>
<p>比较操作符是一个在日常使用中频率非常高的操作符，重载这个操作符只需要掌握以上表格中几个规则即可。我们以<code>Number</code>类为例举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">operator fun Number.compareTo(number: Number): Int &#123;</span><br><span class="line">    return this.value - number.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="属性委托操作符"><a href="#属性委托操作符" class="headerlink" title="属性委托操作符"></a>属性委托操作符</h4><p><strong>属性委托操作符</strong>是一种非常特殊的操作符，其主要用在代理属性中。关于Kotlin代理的知识，如果你还不了解的话，请参考这篇文章<br> <a href="https://www.jianshu.com/p/54a57aac11e6" target="_blank" rel="noopener">Delegation</a>。这篇文章介绍的相对简略，后面会出一篇更详细的文章介绍代理相关的知识。</p>
<h4 id="中缀调用"><a href="#中缀调用" class="headerlink" title="中缀调用"></a>中缀调用</h4><p>看到这里，可能有一些追求更高级玩法的同学会问：Kotlin支持自定义操作符吗？</p>
<p>答案当然是：不能！不过，别失望，<code>infix</code>也许适合你，它其实可以看做一种自定义操作符的实现。这里我们对集合<code>List</code>新增一个扩展方法<code>intersection</code>用于获取两个集合的交集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取两个集合的交集</span><br><span class="line">fun &lt;E&gt; List&lt;E&gt;.interSection(other: List&lt;E&gt;): List&lt;E&gt; &#123;</span><br><span class="line">    val result = ArrayList&lt;E&gt;()</span><br><span class="line">    forEach &#123;</span><br><span class="line">        if(other.contains(it)) &#123;</span><br><span class="line">            result.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们就可以在<code>List</code>及其子类中使用点语法调用了。但，它看起来仍然不像一个操作符。为了让它更像一个操作符，我们继续做点事情：</p>
<ul>
<li>添加<code>infix</code>关键词</li>
<li>将函数名修改为∩（这是数学上获取交集的标记符号）<br>然而，万万没想到，修改完成后居然报错了。Kotlin并不允许直接使用特殊符号作为函数名开头。因此，我们取形近的字母<code>n</code>用于表示函数名：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取两个集合的交集</span><br><span class="line">infix fun &lt;E&gt; List&lt;E&gt;.n(other: List&lt;E&gt;): List&lt;E&gt; &#123;</span><br><span class="line">    val result = ArrayList&lt;E&gt;()</span><br><span class="line">    forEach &#123;</span><br><span class="line">        if(other.contains(it)) &#123;</span><br><span class="line">            result.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>接下来，我们就可以这样调用了<code>val interSection = list1 n list2</code>，怎么样？是不是很像自定义了一个获取交集的操作符<code>n</code>？如果你希望自定义操作符，可以尝试这么做。</p>
<p>其实<code>infix</code>的应用场景还不止这些，接下来，我们再用它完成一件更有意思的事情。</p>
<p>在实际项目开发中，数据库数据到对象的处理是一件繁琐的过程，最麻烦的地方莫过于思维的转换。那我们是否可以在代码中直接使用SQL语句查询对象数据呢？例如这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val users = Select * from User where age &gt; 18</span><br></pre></td></tr></table></figure></p>
<p>纸上学来终觉浅，觉知此事需躬行。有了这个idea，接下来，我们就朝着这个目标努力。<br>一、先声明一个<code>Sql</code>类，准备如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">infix fun select(columnBuilder: ColumnBuilder): Sql &#123;</span><br><span class="line"></span><br><span class="line">infix fun from(entityClass: Class&lt;*&gt;): Sql </span><br><span class="line"></span><br><span class="line">infix fun where(condition: String): Sql </span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; query(): T</span><br></pre></td></tr></table></figure></p>
<p>二、我们的目的是：最终转换到SQL语句形式。因此，增加如下实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class ColumnBuilder(var columns: Array&lt;out String&gt;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sql private constructor() &#123;</span><br><span class="line">    var columns = emptyList&lt;String&gt;()</span><br><span class="line">    var entityClass: Class&lt;*&gt;? = null</span><br><span class="line">    var condition: String? = null</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        fun get(): Sql &#123;</span><br><span class="line">            return Sql()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infix fun select(columnBuilder: ColumnBuilder): Sql &#123;</span><br><span class="line">        this.columns = columnBuilder.columns.asList()</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infix fun from(entityClass: Class&lt;*&gt;): Sql &#123;</span><br><span class="line">        this.entityClass = entityClass</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infix fun where(condition: String): Sql &#123;</span><br><span class="line">        this.condition = condition</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun &lt;T&gt; query(): T &#123;</span><br><span class="line">        // 此处省略所有条件判断</span><br><span class="line">        val sqlBuilder = StringBuilder(&quot;select &quot;)</span><br><span class="line"></span><br><span class="line">        val columnBuilder = StringBuilder(&quot;&quot;)</span><br><span class="line">        if(columns.size == 1 &amp;&amp; columns[0] == &quot;*&quot;) &#123;</span><br><span class="line">            columnBuilder.append(&quot;*&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            columns.forEach &#123;</span><br><span class="line">                columnBuilder.append(it).append(&quot;,&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            columnBuilder.delete(columns.size - 1, columns.size)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val sql = sqlBuilder.append(columnBuilder.toString())</span><br><span class="line">                            .append(&quot; from $&#123;entityClass?.simpleName&#125; where &quot;)</span><br><span class="line">                            .append(condition)</span><br><span class="line">                            .toString()</span><br><span class="line">        println(&quot;执行SQL查询：$sql&quot;)</span><br><span class="line"></span><br><span class="line">        return execute(sql)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun &lt;T&gt; execute(sql: String): T &#123;</span><br><span class="line">        // 仅仅用于测试</span><br><span class="line">        return Any() as T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>三、为了看起来更形似，再增加如下两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使其看起来像在数据库作用域中执行</span><br><span class="line">fun database(init: Sql.()-&gt;Unit) &#123;</span><br><span class="line">    init.invoke(Sql.get())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为infix限制，参数不能直接使用可变参数。因此，我们增加这个方法使参数组装看起来更自然</span><br><span class="line">fun columns(vararg columns: String): ColumnBuilder &#123;</span><br><span class="line">    return ColumnBuilder(columns)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，就是见证奇迹的时刻！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    database &#123;</span><br><span class="line">        (select (columns(&quot;*&quot;)) from User::class.java where &quot;age &gt; 18&quot;).query()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出结果：</span><br><span class="line">执行SQL查询：select * from User where age &gt; 18</span><br></pre></td></tr></table></figure></p>
<p>为了方便大家查看，我们提取完整执行代码段与SQL语句对比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select          *       from User             where  age &gt; 18</span><br><span class="line">select  (columns(&quot;*&quot;))  from User::class.java where &quot;age &gt; 18&quot;</span><br></pre></td></tr></table></figure></p>
<p>神奇吗？<br>至此，我们就可以直接在代码中愉快地使用类似SQL语句的方式进行方法调用了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章从操作符重载实用的角度讲解了操作符重载的所有相关知识。如文章开头所说，操作符重载是一把双刃剑。用得好事半功倍，用不好事倍功半。因此，我给大家的建议是：使用的时候一定要保证能够自圆其说，简单来说，就是自然。我认为相对于古老的语言C++来说，Kotlin语言操作符重载的设计是非常棒的。如果你知道自己在做什么，我非常推荐你在生产环境中使用操作符重载来简化操作。</p>
<p>本篇文章例子代码点这里：<a href="https://github.com/yuanhoujun/kotlin-samples" target="_blank" rel="noopener">kotlin-samples</a></p>
<hr>
<p>我是欧阳锋，一个热爱Kotlin语言编程的学生。如果你喜欢我的文章，请在文章下方留下你爱的印记。如果你不喜欢我的文章，请先喜欢上我的文章。然后再留下爱的印记！</p>
<p>下次文章再见，拜拜！</p>
<hr>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/02/06/kotlin/操作符重载及中缀调用/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/02/01/develop tools/关于Git，你真的学会了吗？/"
                            aria-label=": 关于Git，你真的学会了吗？"
                        >
                            关于Git，你真的学会了吗？
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-02-01T22:13:00+08:00">
	
		    2月 01, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/开发工具/">开发工具</a>, <a class="category-link" href="/categories/开发工具/Git/">Git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>“锋哥，Git有什么可说的，不就是<code>git add</code>添加，<code>git commit</code>提交嘛”  听说我要写一篇Git教程，小明不屑一顾地说。<br>“…”。</p>
<p>小明是我的一个学生。目前，是一名Android开发工程师。</p>
<p>过了几天，我又再次见到了小明。</p>
<p>“锋哥，今天，我在Github新建了一个版本库，本地提交后推送远程的时候，却被拒绝了，是怎么回事？”</p>
<p>以下是小明的操作记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Init commit&quot;</span><br><span class="line">git remote add origin git@github.com:xiaoming/xxx.git</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p>
<p>以上操作触发了下面的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">From git@github.com:xiaoming/xxx.git</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line">fatal: refusing to merge unrelated histories</span><br></pre></td></tr></table></figure></p>
<p>“小明，注意看最后一句提示。翻译成中文的意思是 ‘拒绝合并不相关的历史’，这个问题有两个方案可以处理。”</p>
<ul>
<li><p><code>git pull</code>命令其实是触发了拉取<code>git fetch</code>和合并<code>git merge</code>两个操作。而本地的版本库和远程版本库在第一次拉取或推送完成之前是毫不相关的，Git为了避免不必要的合并，默认不允许进行这样的操作。但你可以手动添加<code>--allow-unrelated-histories</code>强制进行合并，这是方案一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>
</li>
<li><p>再来看方案二，从你上面的操作来看，你只是在本地初始化了一个版本库，并完成了基础的提交。接下来，你希望和远程版本库建立关联，将提交推送到远程。这种情况下，其实你可能并不需要远程的默认数据（通常是一个空的README文件）。所以，你可以添加<code>-f</code>参数，将提交强制提交并覆盖远程版本库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>小明若有所思地点点头，这是小明第一次遇到Git问题。我想，接下来他应该会比较顺利了。</p>
<p>没想到，过了几天，我又收到了小明的消息。这一次，他发来的是对Git的抱怨。</p>
<p>“锋哥，Git好讨厌，提交日志出现了错误，也不能修改。你知道搜狗输入法有时候不够智能，输入太快不小心就输错了…😓” </p>
<p>“🙂，你这孩子，别轻易下结论哈。其实，Git是允许修改提交记录的。使用Git最舒服的一点就是：Git永远都会给你反悔的机会。这一点，其它的版本控制工具是做不到的！”</p>
<p>“哦，原来是这样啊！那快说说看，要怎么做？” 小明已经一副迫不及待的表情了。</p>
<p>“<code>git commit</code>命令中有一个参数叫<code>--amend</code>就是为解决这个问题而生的。因此，如果是最近的提交，你只需要按照下面的命令操作即可。”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m &quot;这是新的提交日志&quot;</span><br></pre></td></tr></table></figure>
<p>看完我的消息，小明给我发来一个微笑的表情。小明的抱怨让我想起一句好气又好笑的农村俗语 “屙屎不出怪茅坑”，哈哈。</p>
<p>本以为一切可以风平浪静了。没想到，过了一个月左右，突然接到了小明的紧急电话。电话那头，小明似乎心情很急躁。</p>
<p>“锋哥，我不小心进行了还原操作，我写的代码全丢了。几千行的代码啊，明天晚上就要发版本了，有办法找回来吗？”</p>
<p>听到这个消息，我心里盘算，大约有50%的概率应该是找不回来了。这孩子比较粗心，可能根本就没提交到版本库。但如果他正好提交到了版本库，兴许还有救。因此，我安慰他说 “小明，别急！你打开TeamViewer，我远程帮你看看”</p>
<p>连上机器后，我使用<code>history</code>命令看到小明在提交之后使用了<code>git reset --hard xxx</code>命令进行重置。<code>--hard</code>是<code>git reset</code>命令中唯一一个不安全的操作，它会真正地销毁数据，以至于你在<code>git log</code>中完全看不到操作日志。可是，Git真的很聪明，它还保存了另外一份日志叫<code>reflog</code>，这个日志记录了你每次修改HEAD的操作。因此，你可以通过下面的命令对数据进行还原：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">// 使用这个命令，你看到的日志大概是这样</span><br><span class="line">c8278f9 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to c8278f9914a91e3aca6ab0993b48073ba1e41b2b</span><br><span class="line">3e59423 HEAD@&#123;1&#125;: commit: a</span><br><span class="line">c8278f9 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (amend): v2 update</span><br><span class="line">2dc167b HEAD@&#123;3&#125;: commit: v2</span><br><span class="line">2e342e9 HEAD@&#123;4&#125;: commit (initial): Init commit</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们在版本<code>3e59423</code>进行了<code>git reset</code>操作，最新版本是<code>3e59423</code>。因此，我们可以再次通过<code>git reset</code>命令回到这个版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 3e59423</span><br></pre></td></tr></table></figure></p>
<p>以上操作完成后，你会惊喜地发现，丢失的数据居然神奇般地回来了。</p>
<p>“🌺 🌺 🌺”</p>
<p>“下次别这样操作了哈。另外，你怎么一次性丢失这么多代码。一定要记得勤提交。” 小明出现这样的问题，与平时的不规范操作也是分不开的。因此，最后我还不忘嘱咐了他一句。</p>
<p>“好的，我知道了。对了，我一个还有比较疑惑的问题。<code>git checkout</code>和<code>git reset</code>到底有啥区别？我以前用SVN的时候<code>git checkout</code>是用来检出代码的，在Git中可以用它切换分支或者指定版本，但<code>git reset</code>同样可以做到。难道两者是完全一样的吗？” 小明在QQ中给我发来了回复消息。</p>
<p>“这是一个比较有深度的问题，解释这个问题需要一点时间。接下来，你仔细听”</p>
<h2 id="理解Git工作空间"><a href="#理解Git工作空间" class="headerlink" title="理解Git工作空间"></a>理解Git工作空间</h2><p>理解这个问题之前，先来简单学习一些Git基础知识。Git有三种状态：</p>
<ul>
<li>已提交（commited）：数据已完全保存到本地数据库中</li>
<li>已修改（modified）：修改了文件，但还没有保存到数据库中</li>
<li>已暂存（staged)：对一个已修改的文件做了标记，将包含在下一次提交的版本快照中</li>
</ul>
<p>这三种状态对应Git三个工作区域：Git版本库、暂存区和工作区<br><img src="http://upload-images.jianshu.io/upload_images/703764-6459c27004beb536.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Git版本库是Git用来保存项目的元数据和对象数据库的地方，使用<code>git clone</code>命令时拷贝的就是这里的数据。</p>
<p>工作目录是对某个版本独立检出的内容，这些数据可以供你使用和修改。</p>
<p>暂存区在Git内部对应一个名为index的文件，它保存了下次将要提交的文件列表信息。因此，暂存区有时候也被叫作 “索引”。</p>
<p>一个基础的Git工作流程如下：<br>1）在工作区修改文件<br>2）使用<code>git add</code>将文件添加到暂存区，也就是记录到<code>index</code>文件中<br>3）使用<code>git commit</code>将暂存区中记录的文件列表，使用快照永久地保存到Git版本库中</p>
<h2 id="理解HEAD"><a href="#理解HEAD" class="headerlink" title="理解HEAD"></a>理解HEAD</h2><p>解释这个问题，你还需要简单理解HEAD是什么。简单来说，HEAD是当前分支引用的指针，它永远指向该分支上最后一次提交。为了让你更容易理解HEAD，你可以将HEAD看作上一次提交数据的快照。</p>
<p>如果你感兴趣，你可以使用一个底层命令来查看当前HEAD的快照信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git ls-tree -r HEAD</span><br><span class="line"></span><br><span class="line">100644 blob aca4b576b7d4534266cb818ab1191d91887508b9	demo/src/main/java/com/youngfeng/snake/demo/Constant.java</span><br><span class="line">100644 blob b8691ec87867b180e6ffc8dd5a7e85747698630d	demo/src/main/java/com/youngfeng/snake/demo/SnakeApplication.java</span><br><span class="line">100644 blob 9a70557b761171ca196196a7c94a26ebbec89bb1	demo/src/main/java/com/youngfeng/snake/demo/activities/FirstActivity.java</span><br><span class="line">100644 blob fab8d2f5cb65129df09185c5bd210d20484154ce	demo/src/main/java/com/youngfeng/snake/demo/activities/SecondActivity.java</span><br><span class="line">100644 blob a7509233ecd8fe6c646f8585f756c74842ef0216	demo/src/main/java/com/youngfeng/snake/demo/activities/SplashActivity.java</span><br></pre></td></tr></table></figure></p>
<p>这里简单解释一下每个字段的意思：100644表示文件模式，其对应一个普通文件。blob表示Git内部存储对象数据类型，另外还有一种数据类型tree，对应一个树对象，中间较长的字符串对应当前文件的SHA-1值，这部分不需要记住，简单了解即可。</p>
<p>所以，简单来说，HEAD对应一个树形结构，存储了当前分支所有的Git对象快照：<br><img src="http://upload-images.jianshu.io/upload_images/703764-639a489c0930506a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我们用一个表格简单来总结一下以上知识点：</p>
<table>
<thead>
<tr>
<th style="text-align:center">HEAD</th>
<th style="text-align:center">Index(暂存区)</th>
<th style="text-align:center">工作区</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">上一次提交的快照，下一次提交的父节点</td>
<td style="text-align:center">预期的下一次提交快照</td>
<td style="text-align:center">当前正在操作的沙盒目录</td>
</tr>
</tbody>
</table>
<p>理解<code>git reset</code>和<code>git checkout</code>区别主要是理解Git内部是怎么操作以上三棵树的。</p>
<p>接下来，我们用一个简单的例子来看一下使用<code>git reset</code>到底发生了什么。先创建一个Git版本库并触发三次提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git init repo</span><br><span class="line">touch file.txt</span><br><span class="line">git add file.txt</span><br><span class="line">git commit -m &quot;v1&quot;</span><br><span class="line"></span><br><span class="line">echo v2 &gt; file.txt</span><br><span class="line">git add file.txt</span><br><span class="line">git commit -m &quot;v2&quot;</span><br><span class="line"></span><br><span class="line">echo v3 &gt; file.txt</span><br><span class="line">git add file.txt</span><br><span class="line">git commit -m &quot;v3&quot;</span><br></pre></td></tr></table></figure></p>
<p>以上操作完成后，版本库现在看起来是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/703764-553e3fc8b81023c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来执行命令<code>git reset 14ad152</code>看看会发生什么。以下是命令执行完成后看到的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git log --abbrev-commit --pretty=oneline</span><br><span class="line">### This is output ###</span><br><span class="line">14ad152 (HEAD -&gt; master) v2</span><br><span class="line">bcc49f4 v1</span><br><span class="line"></span><br><span class="line">git status -s</span><br><span class="line">### This is output ###</span><br><span class="line"> M file.txt</span><br><span class="line"></span><br><span class="line">cat file.txt</span><br><span class="line">### This is output ###</span><br><span class="line">v3</span><br></pre></td></tr></table></figure></p>
<p>可以看到版本库中文件版本回退到了V2，工作区文件内容同之前的版本V3一致；为了确认暂存区发生了什么变化，我们再使用一个底层命令对比一下暂存区数据和版本库数据是否一致：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看暂存区信息</span><br><span class="line">git ls-files -s</span><br><span class="line">### This is output ###</span><br><span class="line">100644 8c1384d825dbbe41309b7dc18ee7991a9085c46e 0	file.txt</span><br><span class="line"></span><br><span class="line"># 查看版本库快照信息</span><br><span class="line">git ls-tree -r HEAD</span><br><span class="line">### This is output ###</span><br><span class="line">100644 blob 8c1384d825dbbe41309b7dc18ee7991a9085c46e	file.txt</span><br></pre></td></tr></table></figure></p>
<p>可以看到当前版本库和暂存区信息是完全一致的，HEAD指向了v2提交，用一个图形来表示整个过程，应该是这样：<br><img src="http://upload-images.jianshu.io/upload_images/703764-5d21495a27e774c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>看一眼上图，理解一下刚刚发生的事情：首先，HEAD指针发生了移动，指向了V2，并撤销了上一次提交。目前，版本库和暂存区都保存的是第二次提交的记录，工作区却保存了最近一次修改。稍微联想一下，你就会发现，这次的<code>git reset</code>命令恰好是最近一次提交的逆向操作。让数据完全回到了上一次提交前的状态。所以，如果你想撤销最近一次提交，可以这么做。</p>
<h4 id="增加–soft参数测试"><a href="#增加–soft参数测试" class="headerlink" title="增加–soft参数测试"></a>增加–soft参数测试</h4><p>以上是我们对<code>git reset</code>命令的第一次尝试，在下一轮尝试前，先执行<code>git help reset</code>看看<code>reset</code>命令的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;...</span><br><span class="line">git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;...]</span><br><span class="line">git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure></p>
<p>看最后一句发现，<code>reset</code>命令后面还可以接5个不同的参数: <code>--soft</code>、<code>--mixed</code>、<code>--hard</code> 、<code>--merge</code>、<code>--keep</code>。这里我们主要关注前面三个，其中<code>--mixed</code>其实刚刚已经尝试过，它和不带参数的<code>git reset</code>命令是同样的效果。换而言之，<code>--mixed</code>是<code>git reset</code>命令的默认行为。接下来执行<code>git reset --soft 14ad152</code>看看会发生什么。命令执行完成后，按照惯例，我们同样使用基础命令看看发生了什么变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git log --abbrev-commit --pretty=oneline</span><br><span class="line">### This is output ###</span><br><span class="line">14ad152 (HEAD -&gt; master) v2</span><br><span class="line">bcc49f4 v1</span><br><span class="line"></span><br><span class="line">git status -s</span><br><span class="line">### This is output ###</span><br><span class="line">M  file.txt</span><br><span class="line"></span><br><span class="line">cat file.txt</span><br><span class="line">### This is output ###</span><br><span class="line">v3</span><br></pre></td></tr></table></figure></p>
<p>奇怪了？为什么会和上次不带任何参数的执行结果完全一致？难道Git出现了设计错误。相信你看到结果一定会有这样的疑问，其实不然！因为，这里我用文本粘贴了输出结果，忽略了命令的字体颜色，其实这里第二条命令输出结果中的M颜色与上一次执行结果是不一样的。为了让你看到不同，看下面的截图：<br><img src="http://upload-images.jianshu.io/upload_images/703764-c76ba02b7fb8b5ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这个颜色表示：file.txt文件已经被添加到了暂存区，使用<code>git commit</code>命令就可以完成提交。为了严谨，我们依然使用上面的底层命令看看版本库和暂存区信息是否一致。注意：这里的结果应该是不一致才对，因为版本库记录的文件版本是v2，而暂存区记录的文件版本其实是v3。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git ls-tree -r HEAD</span><br><span class="line">### This is output ###</span><br><span class="line">100644 blob 8c1384d825dbbe41309b7dc18ee7991a9085c46e	file.txt</span><br><span class="line"></span><br><span class="line">git ls-files -s</span><br><span class="line">### This is output ###</span><br><span class="line">100644 29ef827e8a45b1039d908884aae4490157bcb2b4 0	file.txt</span><br></pre></td></tr></table></figure></p>
<p>可以看到，两个命令执行输出的SHA-1并不一致，验证了我们的猜想。</p>
<p>这里我们可以得出一个结论：<code>--soft</code>和默认行为(<code>--mixed</code>)不一样的地方是：<code>--soft</code>会将工作区的最新文件版本再做一步操作，添加到暂存区。使用这个命令可以用来合并提交。即：如果你在某一次提交中有未完成的工作，而你反悔了，你可以使用这个命令撤销提交，等工作做完后继续一次性完成提交。</p>
<h4 id="增加–hard参数测试"><a href="#增加–hard参数测试" class="headerlink" title="增加–hard参数测试"></a>增加–hard参数测试</h4><p>接下来我们对最后一个参数进行测试，这也是小明在使用过程出现问题的一个参数。执行命令<code>git reset --hard 14ad152</code>，看看发生了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git log --abbrev-commit --pretty=oneline</span><br><span class="line">### This is output ###</span><br><span class="line">14ad152 (HEAD -&gt; master) v2</span><br><span class="line">bcc49f4 v1</span><br><span class="line"></span><br><span class="line">git status -s</span><br><span class="line">### This is output ###</span><br><span class="line">&gt;&gt;&gt; No output &lt;&lt;&lt;</span><br><span class="line"></span><br><span class="line">cat file.txt</span><br><span class="line">v2</span><br></pre></td></tr></table></figure></p>
<p>注意看，这次使用<code>git status -s</code>完全看不到输出，这就证明：当前工作区，暂存区，版本库数据是完全一致的。查看文件内容，发现文件回到了v2版本。通常情况下，如果你看到这种情况，一定会吓一跳，你最近一次提交的数据居然完全丢失了。的确，这是Git命令中少有的几个真正销毁数据的命令之一。除非你非常清楚地知道自己在做什么，否则，请尽量不要使用这个命令！</p>
<p>我们依然用一张图，完整地描述这个命令到底发什么了什么：<br><img src="http://upload-images.jianshu.io/upload_images/703764-dea7f52471f35ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到，相对于默认行为，<code>--hard</code>将工作区的数据也还原到了V2版本，以至于V3版本的提交已经完全丢失。</p>
<h1 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h1><p>接下来看<code>git checkout</code>,  按照惯例，先执行<code>git checkout 14ad152</code>看看会发生什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git log --abbrev-commit --pretty=oneline</span><br><span class="line">### This is output ###</span><br><span class="line">14ad152 (HEAD -&gt; master) v2</span><br><span class="line">bcc49f4 v1</span><br><span class="line"></span><br><span class="line">git status -s</span><br><span class="line">### This is output ###</span><br><span class="line">&gt;&gt;&gt; No output &lt;&lt;&lt;</span><br><span class="line"></span><br><span class="line">cat file.txt</span><br><span class="line">v2</span><br></pre></td></tr></table></figure></p>
<p>可以看到，又出现了神奇的一幕，这一次<code>git checkout</code>命令的执行结果的确和<code>git reset --hard</code>完全一致。这是否意味着两者就没有任何区别了呢？当然也不是。严格来说，两者有两个“本质”的区别：</p>
<ul>
<li>相对而言，<code>git checkout</code>对工作目录是安全的，它不会将工作区已经修改的文件还原，<code>git reset</code>则不管三七二十一一股脑全部还原。</li>
<li>另外一个比较重要的区别是，<code>git checkout</code>并不移动HEAD分支的指向，它是通过直接修改HEAD引用来完成指针的指向。</li>
</ul>
<p>第二个不同点相对比较难理解，我们用一张图来更直观地展示二者的区别：<br><img src="http://upload-images.jianshu.io/upload_images/703764-c0e4b18961fe668f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>简单来说，<code>git reset</code>会通过移动指针来完成HEAD的指向，而<code>git checkout</code>则通过直接修改HEAD本身来完成指向的移动。</p>
<h1 id="命令作用于部分文件"><a href="#命令作用于部分文件" class="headerlink" title="命令作用于部分文件"></a>命令作用于部分文件</h1><p><code>git reset</code>和<code>git checkout</code>还可以作用于一个文件，或者部分文件，即带文件路径执行。这种情况下，两个命令的表现不太一样。我们来试试看，先执行<code>git reset 14ad15 -- file.txt</code>命令尝试将文件恢复到V2版本。命令执行完成，按照惯例用一些基础命令来看看发生了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git log --abbrev-commit --pretty=oneline</span><br><span class="line">### This is output ###</span><br><span class="line">4521405 (HEAD -&gt; master) v3</span><br><span class="line">14ad152 v2</span><br><span class="line">bcc49f4 v1</span><br><span class="line"></span><br><span class="line">git status -v</span><br><span class="line">### This is output ###</span><br><span class="line">diff --git a/file.txt b/file.txt</span><br><span class="line">index 29ef827..8c1384d 100644</span><br><span class="line">--- a/file.txt</span><br><span class="line">+++ b/file.txt</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-v3</span><br><span class="line">+v2</span><br><span class="line"></span><br><span class="line">cat file.txt</span><br><span class="line">v3</span><br></pre></td></tr></table></figure></p>
<p>可以看到，版本库和工作区的数据都没有发生变化。唯一发生变化的是暂存区，暂存区记录下一次提交的改动将导致数据从V3恢复到V2版本!<br><img src="http://upload-images.jianshu.io/upload_images/703764-d9199360f0dbe0b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这里我们可以这样理解：执行这条命令后，Git先将暂存区和工作区的文件版本恢复到V2，再将工作区的文件版本恢复到V3。与<code>--hard</code>不一样的地方是：这个命令并不会覆盖工作区已经修改的文件，是安全操作。</p>
<p>执行带路径的<code>git checkout</code>命令和<code>git reset</code>命令有一些细微的差别，相对于<code>git reset</code>，<code>git checkout</code>带路径执行会覆盖工作区已经修改的内容，导致数据丢失，是一个非安全操作。</p>
<p>针对上面的所有实验，我们用一个简单的表格来总结他们的区别，以及操作是否安全：</p>
<h4 id="不带路径执行"><a href="#不带路径执行" class="headerlink" title="不带路径执行"></a>不带路径执行</h4><table>
<thead>
<tr>
<th style="text-align:center">命令行</th>
<th style="text-align:center">HEAD</th>
<th style="text-align:center">暂存区</th>
<th style="text-align:center">工作区</th>
<th style="text-align:center">目录安全</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">git reset [–mixed]</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">git reset –soft</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">git reset –hard</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center">git checkout</td>
<td style="text-align:center">Modify</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<h4 id="带路径执行"><a href="#带路径执行" class="headerlink" title="带路径执行"></a>带路径执行</h4><table>
<thead>
<tr>
<th style="text-align:center">命令行</th>
<th style="text-align:center">HEAD</th>
<th style="text-align:center">暂存区</th>
<th style="text-align:center">工作区</th>
<th style="text-align:center">目录安全</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">git reset –</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center">git checkout</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
</tr>
</tbody>
</table>
<p><strong>注意：执行非目录安全的命令操作的时候，一定要慎重，除非你非常清楚自己在做什么！</strong></p>
<p>“小明，你明白了吗？” 消息发送过去之后，等了很久却一直没有响应。<br>“哎，这孩子！估计听睡着了… 😆”</p>
<p>自从这次问到Git的问题后，已经两年过去了，小明再没有问到关于Git的问题。而就在昨天，突然又收到了小明的消息。</p>
<h1 id="也许你应该试试Git-Flow"><a href="#也许你应该试试Git-Flow" class="headerlink" title="也许你应该试试Git Flow"></a>也许你应该试试Git Flow</h1><p>“锋哥，我现在已经是Android Leader了。现在安卓团队一共6个人，我们现在在做一个社交类应用，在Git管理方面我还是发现了一些问题。其中一个问题就是，现在版本库有好多分支，其中开发主要在develop分支。主干分支是master主要用于版本发布。可还有一些分支却显得非常混乱，有什么办法改善这种情况吗？”</p>
<p>“关于Git的分支设计，目前有一个公认比较好的设计叫 <a href="https://github.com/nvie/gitflow" target="_blank" rel="noopener">Git Flow模型</a>。关于Git Flow模型，你可以查看这篇文章 <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">http://nvie.com/posts/a-successful-git-branching-model/</a> 了解一下”</p>
<h1 id="一个idea，一次提交"><a href="#一个idea，一次提交" class="headerlink" title="一个idea，一次提交"></a>一个idea，一次提交</h1><p>“好的！还有一个困扰了我很久的问题是，大家的提交日志写的比较笼统。在查找问题的时候非常不便，而且大部分同学一次性提交好多文件，导致解决问题的时候不能准确定位到具体是哪一次提交导致的。我告诉大家，一次提交改动要尽可能小。但当别人问到具体的提交规则的时候我又不知道从何说起…”</p>
<p>“这是一个很好的问题 。中国程序员普遍存在的一个问题是，恨不得把这辈子能提交的代码一次性搞定。甚至有人用多次提交太麻烦的借口来搪塞问责人。简单来说，可以用一句话概括提交原则：一个idea，一次提交。另外，你说的没错，提交必须尽可能小，注释必须尽可能表述准确！”</p>
<p>给小明讲了这么多Git，我忍不住半开玩笑地问他，“小明，你现在还觉得Git简单吗？”</p>
<p>小明发了一个无奈的表情！说道，“以前是我才疏学浅，略知皮毛，不知道Git原来还有这么多玩法，忍不住为Git的发明者点赞了。对了，锋哥，Git到底是谁开发的？”</p>
<h2 id="Git的最大功臣，其实不是Linus"><a href="#Git的最大功臣，其实不是Linus" class="headerlink" title="Git的最大功臣，其实不是Linus"></a>Git的最大功臣，其实不是Linus</h2><p>”关于Git的故事，互联网上其实已经烂大街了。我简单给你介绍一下吧！Git的诞生其实是一个偶然，其初始使命是为Linux内核代码管理服务的。早年的时候Linux内核源码是用Bitkeeper版本控制工具管理的。可是，后来因为某些利益关系，Bitkeeper要求Linux社区付费使用。这一举动激怒了Linus，也就是Linux的创始人，他决定自己开发一个分布式版本控制系统。几周时间下来，Git的雏形就诞生了，并且开始在Linux社区中应用开来。虽然Linus是Git的创始人，可是背后的最大功臣却是一个日本人 <a href="https://en.wikipedia.org/wiki/Junio_Hamano" target="_blank" rel="noopener">Junio C Hamano</a>。Linus在Git开源版本库的提交只有258次，而Junio C Hamano却提交了4000多次。也就是说，在Linus开发后不久项目的管理权就交给了这个日本人。关于 <a href="https://en.wikipedia.org/wiki/Junio_Hamano" target="_blank" rel="noopener">Junio C Hamano</a>，你感兴趣的话可以Google了解一下。他现在在Google工作，如同Linus一样非常低调。“</p>
<p>“这个故事也告诉我：不要用技术去挑战一个程序员 @_@ ”</p>
<p>这个故事讲完，小明与Git的故事就已经告一段落了。其实，还有一些比较常见的问题，小明并没有问到过。这里，我为你准备了一个附录，给你介绍一些常用的小命令帮你解决日常小问题。它很有用，一定要拿笔记下来，或者收藏这篇文章备用。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p><strong>问题一：公司的Git服务器是搭建在一个内网服务器上面的，我想把代码同时提交到OsChina上面，以便在家拉取代码，远程办公，怎么办？</strong><br>Git本身是一个分布式的版本管理系统，实现这个需求非常简单，使用<code>git remote add</code>命令添加多个远程版本库关联即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add company git@xxx</span><br><span class="line">git remote add home git@xxx</span><br></pre></td></tr></table></figure></p>
<p><strong>问题二：在拉取远程代码的时候，如果本地有代码还没有提交，Git就会提示先提交代码到版本库。可暂时我又不想提交，怎么办？</strong><br>针对这个问题，Git提供了一个临时区域用于保存不想提交的记录，对应的命令是<code>git stash</code>。通常情况下，你可以这样操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 将暂时还不想提交的数据保存到临时区域，保存成功后，工作区将和版本库完全一致</span><br><span class="line">git stash</span><br><span class="line"># 还原stash数据到工作区</span><br><span class="line">git stash apply</span><br><span class="line"># 以上操作完成后，stash数据依然保存在临时区域中，为了删除这部分数据，使用如下命令即可。</span><br><span class="line">git stash drop</span><br><span class="line"># 如果你想在还原数据的同时从临时区域删除数据，可以这样操作：</span><br><span class="line">git statsh pop</span><br><span class="line"># 以上两个命令如果不接任何参数将删除掉所有的临时区域数据，如果你只想删除其中一条记录，指定对应索引数据即可。</span><br><span class="line">git stash pop/drop stash@&#123;index&#125;</span><br><span class="line"># 查看临时区域所有数据，使用如下命令：</span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure></p>
<p><strong>问题三：作为项目负责人，我希望迅速找出问题代码的“元凶”，有什么办法吗？</strong><br>针对这个问题，最好的答案是<code>git blame</code>，使用这个命令并指定具体文件它将显示文件每一行代码的最近修改记录，你可以清晰地看到最近代码的修改人。</p>
<p><strong>问题四：部分Team Leader会要求使用<code>git rebase</code>合并代码，这有什么好处吗？</strong><br>我们用一个简单的思维来理解这个问题，最常见的合并操作是使用<code>git merge</code>，而这样操作会在合并分支生成一次新的提交，并且会严格记录分支提交日志，在长期开发过程中，日志就会呈现多条线路展示，给阅读带来一定的障碍。而使用<code>git rebase</code>会使整体代码提交记录始终像在单一分支开发一样，仅使用一条线路展示。但使用<code>git rebase</code>是有一定陷阱的，这个问题需要一定的时间才能说清楚，如果需要了解两个命令的详细区别，我推荐你阅读这篇文章 <a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase" target="_blank" rel="noopener">Rebase 代替合并</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Git是一个非常优秀的版本控制系统，我极力推荐你在日常开发中使用。这篇文章从小明的角度解释了几个常见问题的解决方案，毫无悬念地，你可能还会遇到其它的一些问题。遇到问题，你可以尝试使用Google搜索解决方案；也可以在文章下方给我留言，我非常乐意为你解答Git问题。</p>
<hr>
<p>我是欧阳锋，版本控制，我使用Git。了解欧阳锋，从这里开始：<a href="http://www.youngfeng.com/2018/02/28/about%20ouyangfeng/%E6%AC%A7%E9%98%B3%E9%94%8B%E6%A1%A3%E6%A1%88%E9%A6%86/" target="_blank" rel="noopener">欧阳锋档案馆</a>。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/02/01/develop tools/关于Git，你真的学会了吗？/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">第 1 页 共 1 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 欧阳锋工作室. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
            <h4 id="about-card-name">欧阳锋工作室</h4>
        
            <div id="about-card-bio"><p>Stay hungry, stay foolish</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>深圳一行代码科技有限公司创始人</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                广东深圳
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-uxpinu5umcabfr9aiy0uhzftnioszmvauq3qgkh8evzewnqgit0fhssjlsfq.min.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
