<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin 操作符重载及中缀调用]]></title>
    <url>%2F2018%2F02%2F06%2Fkotlin%2F%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8A%E4%B8%AD%E7%BC%80%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[操作符重载其实很有意思！但这个概念却很少有人知道，使用操作符重载在某种程度上会给代码的阅读带来一定的麻烦。因此，慎用操作符被认为是一个好习惯。的确，操作符重载是一把双刃剑，既能削铁如泥，也能“引火烧身”，这篇文章将从实用的角度来讲解操作符重载的基本用法。 支持重载的操作符类型Kotlin语言支持重载的操作符类型比较多。以最新版本1.2.21为准，目前支持重载的操作符可以归纳为以下几类： 一元操作符一元前缀操作符 操作符 对应方法 +a a.unaryPlus() -a a.unaryMinus() !a a.not() 以上三个操作符在日常使用中频率很高，第一个操作符在基本运算中很少使用，第二个操作符就是常见的取反操作，第三个操作符是逻辑取反操作。接下来，我们使用扩展的方式重载这三个操作符：1234567891011121314151617181920212223242526272829303132333435363738394041/** * 一元操作符 * * @author Scott Smith 2018-02-03 14:11 */data class Number(var value: Int)/** * 重载一元操作符+，使其对Number中实际数据取绝对值 */operator fun Number.unaryPlus(): Number &#123; this.value = Math.abs(value) return this&#125;/** * 重载一元操作符-，使其对Number中实际数据取反 */operator fun Number.unaryMinus(): Number &#123; this.value = -value return this&#125;/** * 这个操作符通常是用于逻辑取反，这里用一个没有意义的操作，来模拟重载这个操作符 * 结果：始终返回Number中实际数据的负值 */operator fun Number.not(): Number &#123; this.value = -Math.abs(value) return this&#125;fun main(args: Array&lt;String&gt;) &#123; val number = Number(-3) println(&quot;Number value = $&#123;number.value&#125;&quot;) println(&quot;After unaryPlus: Number value = $&#123;(+number).value&#125;&quot;) println(&quot;After unaryMinus: Number value = $&#123;(-number).value&#125;&quot;) number.value = Math.abs(number.value) println(&quot;After unaryNot: Number value = $&#123;(!number).value&#125;&quot;)&#125; 运行上述代码，将得到如下结果：1234Number value = -3After unaryPlus: Number value = 3After unaryMinus: Number value = -3After unaryNot: Number value = -3 自增和自减操作符 操作符 对应方法 a++/++a a.inc() a–/–a a.dec() 重载这个操作符相对比较难理解，官方文档有一段简短的文字解释，翻译成代码可以这样表示：123456789101112// a++fun increment(a: Int): Int &#123; val a0 = a a = a + 1 return a0&#125;// ++afun increment(a: Int): Int &#123; a = a + 1 return a&#125; 看懂上面的代码后，我们换成需要重载的Number类，Kotlin最终会这样处理：1234567891011// Number++fun increment(number: Number): Number &#123; val temp = number val result = number.inc() return result&#125;// Number++fun increment(number: Number): Number &#123; return number.inc()&#125; 因此，重载Number类自加操作符，我们可以这样做：123operator fun Number.inc(): Number &#123; return Number(this.value + 1)&#125; 重载自减操作符同理，完整代码请参考我的Git版本库：kotlin-samples 二元操作符算术运算符 操作符 对应方法 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b) a..b a.rangeTo(b) 前5个操作符相对比较好理解，我们以a + b为例，举个一个简单的例子：12345678910// 重载Number类的加法运算符operator fun Number.plus(value: Int): Number &#123; return Number(this.value + value)&#125;fun main(args: Array&lt;String&gt;) &#123; println((Number(1) + 2))&#125;// 输出结果：Number value = 3 相对比较难理解的是第六个范围运算符，这个操作符主要用于生成一段数据范围。我们认为Number本身就代表一个整型数字，因此，重载Number是一件有意义的事情。直接看例子：123456789101112131415161718192021operator fun Number.rangeTo(to: Number): IntRange &#123; return this.value..to.value&#125;fun main(args: Array&lt;String&gt;) &#123; val startNumber = Number(3) val endNumber = Number(9) (startNumber..endNumber).forEach &#123; println(&quot;value = $it&quot;) &#125;&#125;// 运行结果：value = 3value = 4value = 5value = 6value = 7value = 8value = 9 “In”运算符 操作符 对应方法 a in b b.contains(a) a !in b !b.contains(a) 这个操作符相对比较好理解，重载这个操作符可以用于判断某个数据是否在另外一个对象中。我们用一个非常简单的自定义类来模拟集合操作：1234567891011121314151617class IntCollection &#123; val intList = ArrayList&lt;Int&gt;()&#125;// 重载&quot;in&quot;操作符operator fun IntCollection.contains(value: Int): Boolean &#123; return this.intList.contains(value)&#125;fun main(args: Array&lt;String&gt;) &#123; val intCollection = IntCollection() intCollection.add(1, 2, 3) println(3 in intCollection)&#125;// 输出结果：true 索引访问运算符 操作符 对应方法 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, …, i_n] a.get(i_1, …, i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, …, i_n] = b a.set(i_1, …, i_n, b) 这个操作符很有意思，例如，如果你要访问Map中某个数据，通常是这样的map.get(&quot;key&quot;)，使用索引运算符你还可以这样操作：1val value = map[&quot;key&quot;] 我们继续以IntCollection类为例，尝试重写a[i]和a[i] = b两个运算符，其它运算符同理。123456789101112131415161718// 重载a[i]操作符operator fun IntCollection.get(index: Int): Int &#123; return intList[index]&#125;// 重载a[i] = b操作符operator fun IntCollection.set(index: Int, value: Int) &#123; intList[index] = value&#125;fun main(args: Array&lt;String&gt;) &#123; val intCollection = IntCollection() intCollection.add(1, 2, 3) println(intCollection[0]) intCollection[2] = 4 print(intCollection[2])&#125; 接下来，我们用索引运算符来做一点更有意思的事情！新建一个普通的Kotlin类User：1234class User(var name: String, var age: Int) &#123;&#125; 使用下面的方式重载索引运算符：1234567891011121314151617181920212223operator fun User.get(key: String): Any? &#123; when(key) &#123; &quot;name&quot; -&gt; &#123; return this.name &#125; &quot;age&quot; -&gt; &#123; return this.age &#125; &#125; return null&#125;operator fun User.set(key: String, value:Any?) &#123; when(key) &#123; &quot;name&quot; -&gt; &#123; name = value as? String &#125; &quot;age&quot; -&gt; &#123; age = value as? Int &#125; &#125;&#125; 接下来，你会神奇地发现，一个普通的Kotlin类居然也可以使用索引运算符对成员变量进行操作了，是不是很神奇？123456fun main(args: Array&lt;String&gt;) &#123; val user = User(&quot;Scott Smith&quot;, 18) println(user[&quot;name&quot;]) user[&quot;age&quot;] = 22 println(user[&quot;age&quot;])&#125; 因此，索引运算符不仅仅可以对集合类数据进行操作，对一个普通的Kotlin类也可以发挥同样的作用。如果你脑洞足够大，你还可以发现更多更神奇的玩法。 调用操作符 操作符 对应方法 a() a.invoke() a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, ……, i_n) a.invoke(i_1, ……, i_n) 重载这个操作符并不难，理解它的应用场景却有一定的难度。为了理解它的应用场景，我们来举一个简单的例子：12345678910111213class JsonParser &#123;&#125;operator fun JsonParser.invoke(json: String): Map&lt;String, Any&gt; &#123; val map = Json.parse(json) ... return map&#125;// 可以这样调用val parser = JsonParser()val map = parser(&quot;&#123;name: \&quot;Scott Smith\&quot;&#125;&quot;) 这里的调用有点像省略了一个解析Json数据的方法，难道它仅仅就是这个作用吗？是的，调用操作符其实就这一个作用。如果一个Kotlin类仅仅只有一个方法，直接使用括号调用的确是一个不错的主意。不过，在使用的时候还是要稍微注意一下，避免出现歧义。 广义赋值操作符 操作符 对应方法 a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.remAssign(b) 这个操作符相对比较好理解，我们以Number类为例，举一个简单的例子：12345678910111213// 广义赋值运算符operator fun Number.plusAssign(value: Int) &#123; this.value += value&#125;fun main(args: Array&lt;String&gt;) &#123; val number = Number(1) number += 2 println(number)&#125;// 输出结果：Number value = 3 相等与不等操作符 操作符 对应方法 a == b a?.equals(b) ?: (b === null) a != b !(a?.equals(b) ?: (b === null)) 重载这个操作符与Java重写equals方法是一样的。不过，这里要注意与Java的区别，在Java端==用于判断两个对象是否是同一对象（指针级别）。而在Kotlin语言中，如果我们不做任何处理，==等同于使用Java对象的equals方法判断两个对象是否相等。 另外，这里还有一种特殊情况，如果左值等于null，这个时候a?.equals(b)将返回null值。因此，这里还增加了?:运算符用于进一步判断，在这个情况下，当且仅当b === null的时候，a、b才有可能相等。因此，才有了上面的对应关系，这里以User类为例举一个简单的例子：12345678910class User(var name: String?, var age: Int?) &#123; operator override fun equals(other: Any?): Boolean &#123; if(other is User) &#123; return (this.name == other.name) &amp;&amp; (this.age == other.age) &#125; return false &#125;&#125; 注意：这里有一个特殊的地方，与其它操作符不一样的地方是，如果使用扩展的方式尝试重载该操作符，将会报错。因此，如果要重载该操作符，一定要在类中进行重写。 比较操作符 操作符 对应方法 a &gt; b a.compareTo(b) &gt; 0 a &lt; b a.compareTo(b) &lt; 0 a &gt;= b a.compareTo(b) &gt;= 0 a &lt;= b a.compareTo(b) &lt;= 0 比较操作符是一个在日常使用中频率非常高的操作符，重载这个操作符只需要掌握以上表格中几个规则即可。我们以Number类为例举一个简单的例子：123operator fun Number.compareTo(number: Number): Int &#123; return this.value - number.value&#125; 属性委托操作符属性委托操作符是一种非常特殊的操作符，其主要用在代理属性中。关于Kotlin代理的知识，如果你还不了解的话，请参考这篇文章 Delegation。这篇文章介绍的相对简略，后面会出一篇更详细的文章介绍代理相关的知识。 中缀调用看到这里，可能有一些追求更高级玩法的同学会问：Kotlin支持自定义操作符吗？ 答案当然是：不能！不过，别失望，infix也许适合你，它其实可以看做一种自定义操作符的实现。这里我们对集合List新增一个扩展方法intersection用于获取两个集合的交集：1234567891011// 获取两个集合的交集fun &lt;E&gt; List&lt;E&gt;.interSection(other: List&lt;E&gt;): List&lt;E&gt; &#123; val result = ArrayList&lt;E&gt;() forEach &#123; if(other.contains(it)) &#123; result.add(it) &#125; &#125; return result&#125; 接下来，我们就可以在List及其子类中使用点语法调用了。但，它看起来仍然不像一个操作符。为了让它更像一个操作符，我们继续做点事情： 添加infix关键词 将函数名修改为∩（这是数学上获取交集的标记符号）然而，万万没想到，修改完成后居然报错了。Kotlin并不允许直接使用特殊符号作为函数名开头。因此，我们取形近的字母n用于表示函数名：1234567891011// 获取两个集合的交集infix fun &lt;E&gt; List&lt;E&gt;.n(other: List&lt;E&gt;): List&lt;E&gt; &#123; val result = ArrayList&lt;E&gt;() forEach &#123; if(other.contains(it)) &#123; result.add(it) &#125; &#125; return result&#125; 接下来，我们就可以这样调用了val interSection = list1 n list2，怎么样？是不是很像自定义了一个获取交集的操作符n？如果你希望自定义操作符，可以尝试这么做。 其实infix的应用场景还不止这些，接下来，我们再用它完成一件更有意思的事情。 在实际项目开发中，数据库数据到对象的处理是一件繁琐的过程，最麻烦的地方莫过于思维的转换。那我们是否可以在代码中直接使用SQL语句查询对象数据呢？例如这样：1val users = Select * from User where age &gt; 18 纸上学来终觉浅，觉知此事需躬行。有了这个idea，接下来，我们就朝着这个目标努力。一、先声明一个Sql类，准备如下方法：1234567infix fun select(columnBuilder: ColumnBuilder): Sql &#123;infix fun from(entityClass: Class&lt;*&gt;): Sql infix fun where(condition: String): Sql fun &lt;T&gt; query(): T 二、我们的目的是：最终转换到SQL语句形式。因此，增加如下实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class ColumnBuilder(var columns: Array&lt;out String&gt;) &#123;&#125;class Sql private constructor() &#123; var columns = emptyList&lt;String&gt;() var entityClass: Class&lt;*&gt;? = null var condition: String? = null companion object &#123; fun get(): Sql &#123; return Sql() &#125; &#125; infix fun select(columnBuilder: ColumnBuilder): Sql &#123; this.columns = columnBuilder.columns.asList() return this &#125; infix fun from(entityClass: Class&lt;*&gt;): Sql &#123; this.entityClass = entityClass return this &#125; infix fun where(condition: String): Sql &#123; this.condition = condition return this &#125; fun &lt;T&gt; query(): T &#123; // 此处省略所有条件判断 val sqlBuilder = StringBuilder(&quot;select &quot;) val columnBuilder = StringBuilder(&quot;&quot;) if(columns.size == 1 &amp;&amp; columns[0] == &quot;*&quot;) &#123; columnBuilder.append(&quot;*&quot;) &#125; else &#123; columns.forEach &#123; columnBuilder.append(it).append(&quot;,&quot;) &#125; columnBuilder.delete(columns.size - 1, columns.size) &#125; val sql = sqlBuilder.append(columnBuilder.toString()) .append(&quot; from $&#123;entityClass?.simpleName&#125; where &quot;) .append(condition) .toString() println(&quot;执行SQL查询：$sql&quot;) return execute(sql) &#125; private fun &lt;T&gt; execute(sql: String): T &#123; // 仅仅用于测试 return Any() as T &#125;&#125; 三、为了看起来更形似，再增加如下两个方法：123456789// 使其看起来像在数据库作用域中执行fun database(init: Sql.()-&gt;Unit) &#123; init.invoke(Sql.get())&#125;// 因为infix限制，参数不能直接使用可变参数。因此，我们增加这个方法使参数组装看起来更自然fun columns(vararg columns: String): ColumnBuilder &#123; return ColumnBuilder(columns)&#125; 接下来，就是见证奇迹的时刻！12345678fun main(args: Array&lt;String&gt;) &#123; database &#123; (select (columns(&quot;*&quot;)) from User::class.java where &quot;age &gt; 18&quot;).query() &#125;&#125;// 输出结果：执行SQL查询：select * from User where age &gt; 18 为了方便大家查看，我们提取完整执行代码段与SQL语句对比：12select * from User where age &gt; 18select (columns(&quot;*&quot;)) from User::class.java where &quot;age &gt; 18&quot; 神奇吗？至此，我们就可以直接在代码中愉快地使用类似SQL语句的方式进行方法调用了。 总结本篇文章从操作符重载实用的角度讲解了操作符重载的所有相关知识。如文章开头所说，操作符重载是一把双刃剑。用得好事半功倍，用不好事倍功半。因此，我给大家的建议是：使用的时候一定要保证能够自圆其说，简单来说，就是自然。我认为相对于古老的语言C++来说，Kotlin语言操作符重载的设计是非常棒的。如果你知道自己在做什么，我非常推荐你在生产环境中使用操作符重载来简化操作。 本篇文章例子代码点这里：kotlin-samples 我是欧阳锋，一个热爱Kotlin语言编程的学生。如果你喜欢我的文章，请在文章下方留下你爱的印记。如果你不喜欢我的文章，请先喜欢上我的文章。然后再留下爱的印记！ 下次文章再见，拜拜！]]></content>
      <categories>
        <category>Kotlin</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>操作符</tag>
        <tag>重载</tag>
        <tag>infix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Git，你真的学会了吗？]]></title>
    <url>%2F2018%2F02%2F01%2Fdevelop%20tools%2F%E5%85%B3%E4%BA%8EGit%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E5%AD%A6%E4%BC%9A%E4%BA%86%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[“锋哥，Git有什么可说的，不就是git add添加，git commit提交嘛” 听说我要写一篇Git教程，小明不屑一顾地说。“…”。 小明是我的一个学生。目前，是一名Android开发工程师。 过了几天，我又再次见到了小明。 “锋哥，今天，我在Github新建了一个版本库，本地提交后推送远程的时候，却被拒绝了，是怎么回事？” 以下是小明的操作记录：12345git initgit add .git commit -m &quot;Init commit&quot;git remote add origin git@github.com:xiaoming/xxx.gitgit pull origin master 以上操作触发了下面的错误：1234From git@github.com:xiaoming/xxx.git * branch master -&gt; FETCH_HEAD * [new branch] master -&gt; origin/masterfatal: refusing to merge unrelated histories “小明，注意看最后一句提示。翻译成中文的意思是 ‘拒绝合并不相关的历史’，这个问题有两个方案可以处理。” git pull命令其实是触发了拉取git fetch和合并git merge两个操作。而本地的版本库和远程版本库在第一次拉取或推送完成之前是毫不相关的，Git为了避免不必要的合并，默认不允许进行这样的操作。但你可以手动添加--allow-unrelated-histories强制进行合并，这是方案一。 1git pull origin master --allow-unrelated-histories 再来看方案二，从你上面的操作来看，你只是在本地初始化了一个版本库，并完成了基础的提交。接下来，你希望和远程版本库建立关联，将提交推送到远程。这种情况下，其实你可能并不需要远程的默认数据（通常是一个空的README文件）。所以，你可以添加-f参数，将提交强制提交并覆盖远程版本库。 1git push -f origin master 小明若有所思地点点头，这是小明第一次遇到Git问题。我想，接下来他应该会比较顺利了。 没想到，过了几天，我又收到了小明的消息。这一次，他发来的是对Git的抱怨。 “锋哥，Git好讨厌，提交日志出现了错误，也不能修改。你知道搜狗输入法有时候不够智能，输入太快不小心就输错了…😓” “🙂，你这孩子，别轻易下结论哈。其实，Git是允许修改提交记录的。使用Git最舒服的一点就是：Git永远都会给你反悔的机会。这一点，其它的版本控制工具是做不到的！” “哦，原来是这样啊！那快说说看，要怎么做？” 小明已经一副迫不及待的表情了。 “git commit命令中有一个参数叫--amend就是为解决这个问题而生的。因此，如果是最近的提交，你只需要按照下面的命令操作即可。” 1git commit --amend -m &quot;这是新的提交日志&quot; 看完我的消息，小明给我发来一个微笑的表情。小明的抱怨让我想起一句好气又好笑的农村俗语 “屙屎不出怪茅坑”，哈哈。 本以为一切可以风平浪静了。没想到，过了一个月左右，突然接到了小明的紧急电话。电话那头，小明似乎心情很急躁。 “锋哥，我不小心进行了还原操作，我写的代码全丢了。几千行的代码啊，明天晚上就要发版本了，有办法找回来吗？” 听到这个消息，我心里盘算，大约有50%的概率应该是找不回来了。这孩子比较粗心，可能根本就没提交到版本库。但如果他正好提交到了版本库，兴许还有救。因此，我安慰他说 “小明，别急！你打开TeamViewer，我远程帮你看看” 连上机器后，我使用history命令看到小明在提交之后使用了git reset --hard xxx命令进行重置。--hard是git reset命令中唯一一个不安全的操作，它会真正地销毁数据，以至于你在git log中完全看不到操作日志。可是，Git真的很聪明，它还保存了另外一份日志叫reflog，这个日志记录了你每次修改HEAD的操作。因此，你可以通过下面的命令对数据进行还原：12345678git reflog// 使用这个命令，你看到的日志大概是这样c8278f9 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to c8278f9914a91e3aca6ab0993b48073ba1e41b2b3e59423 HEAD@&#123;1&#125;: commit: ac8278f9 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (amend): v2 update2dc167b HEAD@&#123;3&#125;: commit: v22e342e9 HEAD@&#123;4&#125;: commit (initial): Init commit 可以看到，我们在版本3e59423进行了git reset操作，最新版本是3e59423。因此，我们可以再次通过git reset命令回到这个版本：1git reset --hard 3e59423 以上操作完成后，你会惊喜地发现，丢失的数据居然神奇般地回来了。 “谢谢锋哥！！！🌺 🌺 🌺” “下次别这样操作了哈。另外，你怎么一次性丢失这么多代码。一定要记得勤提交。” 小明出现这样的问题，与平时的不规范操作也是分不开的。因此，最后我还不忘嘱咐了他一句。 “好的，我知道了。对了，我一个还有比较疑惑的问题。git checkout和git reset到底有啥区别？我以前用SVN的时候git checkout是用来检出代码的，在Git中可以用它切换分支或者指定版本，但git reset同样可以做到。难道两者是完全一样的吗？” 小明在QQ中给我发来了回复消息。 “这是一个比较有深度的问题，解释这个问题需要一点时间。接下来，你仔细听” 理解Git工作空间理解这个问题之前，先来简单学习一些Git基础知识。Git有三种状态： 已提交（commited）：数据已完全保存到本地数据库中 已修改（modified）：修改了文件，但还没有保存到数据库中 已暂存（staged)：对一个已修改的文件做了标记，将包含在下一次提交的版本快照中 这三种状态对应Git三个工作区域：Git版本库、暂存区和工作区 Git版本库是Git用来保存项目的元数据和对象数据库的地方，使用git clone命令时拷贝的就是这里的数据。 工作目录是对某个版本独立检出的内容，这些数据可以供你使用和修改。 暂存区在Git内部对应一个名为index的文件，它保存了下次将要提交的文件列表信息。因此，暂存区有时候也被叫作 “索引”。 一个基础的Git工作流程如下：1）在工作区修改文件2）使用git add将文件添加到暂存区，也就是记录到index文件中3）使用git commit将暂存区中记录的文件列表，使用快照永久地保存到Git版本库中 理解HEAD解释这个问题，你还需要简单理解HEAD是什么。简单来说，HEAD是当前分支引用的指针，它永远指向该分支上最后一次提交。为了让你更容易理解HEAD，你可以将HEAD看作上一次提交数据的快照。 如果你感兴趣，你可以使用一个底层命令来查看当前HEAD的快照信息:1234567git ls-tree -r HEAD100644 blob aca4b576b7d4534266cb818ab1191d91887508b9 demo/src/main/java/com/youngfeng/snake/demo/Constant.java100644 blob b8691ec87867b180e6ffc8dd5a7e85747698630d demo/src/main/java/com/youngfeng/snake/demo/SnakeApplication.java100644 blob 9a70557b761171ca196196a7c94a26ebbec89bb1 demo/src/main/java/com/youngfeng/snake/demo/activities/FirstActivity.java100644 blob fab8d2f5cb65129df09185c5bd210d20484154ce demo/src/main/java/com/youngfeng/snake/demo/activities/SecondActivity.java100644 blob a7509233ecd8fe6c646f8585f756c74842ef0216 demo/src/main/java/com/youngfeng/snake/demo/activities/SplashActivity.java 这里简单解释一下每个字段的意思：100644表示文件模式，其对应一个普通文件。blob表示Git内部存储对象数据类型，另外还有一种数据类型tree，对应一个树对象，中间较长的字符串对应当前文件的SHA-1值，这部分不需要记住，简单了解即可。 所以，简单来说，HEAD对应一个树形结构，存储了当前分支所有的Git对象快照： 我们用一个表格简单来总结一下以上知识点： HEAD Index(暂存区) 工作区 上一次提交的快照，下一次提交的父节点 预期的下一次提交快照 当前正在操作的沙盒目录 理解git reset和git checkout区别主要是理解Git内部是怎么操作以上三棵树的。 接下来，我们用一个简单的例子来看一下使用git reset到底发生了什么。先创建一个Git版本库并触发三次提交：123456789101112git init repotouch file.txtgit add file.txtgit commit -m &quot;v1&quot;echo v2 &gt; file.txtgit add file.txtgit commit -m &quot;v2&quot;echo v3 &gt; file.txtgit add file.txtgit commit -m &quot;v3&quot; 以上操作完成后，版本库现在看起来是这样的： 接下来执行命令git reset 14ad152看看会发生什么。以下是命令执行完成后看到的结果：123456789101112git log --abbrev-commit --pretty=oneline### This is output ###14ad152 (HEAD -&gt; master) v2bcc49f4 v1git status -s### This is output ### M file.txtcat file.txt### This is output ###v3 可以看到版本库中文件版本回退到了V2，工作区文件内容同之前的版本V3一致；为了确认暂存区发生了什么变化，我们再使用一个底层命令对比一下暂存区数据和版本库数据是否一致：123456789# 查看暂存区信息git ls-files -s### This is output ###100644 8c1384d825dbbe41309b7dc18ee7991a9085c46e 0 file.txt# 查看版本库快照信息git ls-tree -r HEAD### This is output ###100644 blob 8c1384d825dbbe41309b7dc18ee7991a9085c46e file.txt 可以看到当前版本库和暂存区信息是完全一致的，HEAD指向了v2提交，用一个图形来表示整个过程，应该是这样： 看一眼上图，理解一下刚刚发生的事情：首先，HEAD指针发生了移动，指向了V2，并撤销了上一次提交。目前，版本库和暂存区都保存的是第二次提交的记录，工作区却保存了最近一次修改。稍微联想一下，你就会发现，这次的git reset命令恰好是最近一次提交的逆向操作。让数据完全回到了上一次提交前的状态。所以，如果你想撤销最近一次提交，可以这么做。 增加–soft参数测试以上是我们对git reset命令的第一次尝试，在下一轮尝试前，先执行git help reset看看reset命令的用法：123git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;...git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;...]git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;] 看最后一句发现，reset命令后面还可以接5个不同的参数: --soft、--mixed、--hard 、--merge、--keep。这里我们主要关注前面三个，其中--mixed其实刚刚已经尝试过，它和不带参数的git reset命令是同样的效果。换而言之，--mixed是git reset命令的默认行为。接下来执行git reset --soft 14ad152看看会发生什么。命令执行完成后，按照惯例，我们同样使用基础命令看看发生了什么变化：123456789101112git log --abbrev-commit --pretty=oneline### This is output ###14ad152 (HEAD -&gt; master) v2bcc49f4 v1git status -s### This is output ###M file.txtcat file.txt### This is output ###v3 奇怪了？为什么会和上次不带任何参数的执行结果完全一致？难道Git出现了设计错误。相信你看到结果一定会有这样的疑问，其实不然！因为，这里我用文本粘贴了输出结果，忽略了命令的字体颜色，其实这里第二条命令输出结果中的M颜色与上一次执行结果是不一样的。为了让你看到不同，看下面的截图：这个颜色表示：file.txt文件已经被添加到了暂存区，使用git commit命令就可以完成提交。为了严谨，我们依然使用上面的底层命令看看版本库和暂存区信息是否一致。注意：这里的结果应该是不一致才对，因为版本库记录的文件版本是v2，而暂存区记录的文件版本其实是v3。1234567git ls-tree -r HEAD### This is output ###100644 blob 8c1384d825dbbe41309b7dc18ee7991a9085c46e file.txtgit ls-files -s### This is output ###100644 29ef827e8a45b1039d908884aae4490157bcb2b4 0 file.txt 可以看到，两个命令执行输出的SHA-1并不一致，验证了我们的猜想。 这里我们可以得出一个结论：--soft和默认行为(--mixed)不一样的地方是：--soft会将工作区的最新文件版本再做一步操作，添加到暂存区。使用这个命令可以用来合并提交。即：如果你在某一次提交中有未完成的工作，而你反悔了，你可以使用这个命令撤销提交，等工作做完后继续一次性完成提交。 增加–hard参数测试接下来我们对最后一个参数进行测试，这也是小明在使用过程出现问题的一个参数。执行命令git reset --hard 14ad152，看看发生了什么：1234567891011git log --abbrev-commit --pretty=oneline### This is output ###14ad152 (HEAD -&gt; master) v2bcc49f4 v1git status -s### This is output ###&gt;&gt;&gt; No output &lt;&lt;&lt;cat file.txtv2 注意看，这次使用git status -s完全看不到输出，这就证明：当前工作区，暂存区，版本库数据是完全一致的。查看文件内容，发现文件回到了v2版本。通常情况下，如果你看到这种情况，一定会吓一跳，你最近一次提交的数据居然完全丢失了。的确，这是Git命令中少有的几个真正销毁数据的命令之一。除非你非常清楚地知道自己在做什么，否则，请尽量不要使用这个命令！ 我们依然用一张图，完整地描述这个命令到底发什么了什么： 可以看到，相对于默认行为，--hard将工作区的数据也还原到了V2版本，以至于V3版本的提交已经完全丢失。 git checkout接下来看git checkout, 按照惯例，先执行git checkout 14ad152看看会发生什么：1234567891011git log --abbrev-commit --pretty=oneline### This is output ###14ad152 (HEAD -&gt; master) v2bcc49f4 v1git status -s### This is output ###&gt;&gt;&gt; No output &lt;&lt;&lt;cat file.txtv2 可以看到，又出现了神奇的一幕，这一次git checkout命令的执行结果的确和git reset --hard完全一致。这是否意味着两者就没有任何区别了呢？当然也不是。严格来说，两者有两个“本质”的区别： 相对而言，git checkout对工作目录是安全的，它不会将工作区已经修改的文件还原，git reset则不管三七二十一一股脑全部还原。 另外一个比较重要的区别是，git checkout并不移动HEAD分支的指向，它是通过直接修改HEAD引用来完成指针的指向。 第二个不同点相对比较难理解，我们用一张图来更直观地展示二者的区别： 简单来说，git reset会通过移动指针来完成HEAD的指向，而git checkout则通过直接修改HEAD本身来完成指向的移动。 命令作用于部分文件git reset和git checkout还可以作用于一个文件，或者部分文件，即带文件路径执行。这种情况下，两个命令的表现不太一样。我们来试试看，先执行git reset 14ad15 -- file.txt命令尝试将文件恢复到V2版本。命令执行完成，按照惯例用一些基础命令来看看发生了什么：123456789101112131415161718git log --abbrev-commit --pretty=oneline### This is output ###4521405 (HEAD -&gt; master) v314ad152 v2bcc49f4 v1git status -v### This is output ###diff --git a/file.txt b/file.txtindex 29ef827..8c1384d 100644--- a/file.txt+++ b/file.txt@@ -1 +1 @@-v3+v2cat file.txtv3 可以看到，版本库和工作区的数据都没有发生变化。唯一发生变化的是暂存区，暂存区记录下一次提交的改动将导致数据从V3恢复到V2版本! 这里我们可以这样理解：执行这条命令后，Git先将暂存区和工作区的文件版本恢复到V2，再将工作区的文件版本恢复到V3。与--hard不一样的地方是：这个命令并不会覆盖工作区已经修改的文件，是安全操作。 执行带路径的git checkout命令和git reset命令有一些细微的差别，相对于git reset，git checkout带路径执行会覆盖工作区已经修改的内容，导致数据丢失，是一个非安全操作。 针对上面的所有实验，我们用一个简单的表格来总结他们的区别，以及操作是否安全： 不带路径执行 命令行 HEAD 暂存区 工作区 目录安全 git reset [–mixed] YES YES NO YES git reset –soft YES YES NO YES git reset –hard YES YES YES NO git checkout Modify YES YES YES 带路径执行 命令行 HEAD 暂存区 工作区 目录安全 git reset – NO YES NO YES git checkout NO YES YES NO “小明，你明白了吗？” 消息发送过去之后，等了很久却一直没有响应。“哎，这孩子！估计听睡着了… 😆” 自从这次问到Git的问题后，已经两年过去了，小明再没有问到关于Git的问题。而就在昨天，突然又收到了小明的消息。 也许你应该试试Git Flow“锋哥，我现在已经是Android Leader了。现在安卓团队一共6个人，我们现在在做一个社交类应用，在Git管理方面我还是发现了一些问题。其中一个问题就是，现在版本库有好多分支，其中开发主要在develop分支。主干分支是master主要用于版本发布。可还有一些分支却显得非常混乱，有什么办法改善这种情况吗？” “关于Git的分支设计，目前有一个公认比较好的设计叫 Git Flow模型。关于Git Flow模型，你可以查看这篇文章 http://nvie.com/posts/a-successful-git-branching-model/ 了解一下” 一个idea，一次提交“好的！还有一个困扰了我很久的问题是，大家的提交日志写的比较笼统。在查找问题的时候非常不便，而且大部分同学一次性提交好多文件，导致解决问题的时候不能准确定位到具体是哪一次提交导致的。我告诉大家，一次提交改动要尽可能小。但当别人问到具体的提交规则的时候我又不知道从何说起…” “这是一个很好的问题 。中国程序员普遍存在的一个问题是，恨不得把这辈子能提交的代码一次性搞定。甚至有人用多次提交太麻烦的借口来搪塞问责人。简单来说，可以用一句话概括提交原则：一个idea，一次提交。另外，你说的没错，提交必须尽可能小，注释必须尽可能表述准确！” 给小明讲了这么多Git，我忍不住半开玩笑地问他，“小明，你现在还觉得Git简单吗？” 小明发了一个无奈的表情！说道，“以前是我才疏学浅，略知皮毛，不知道Git原来还有这么多玩法，忍不住为Git的发明者点赞了。对了，锋哥，Git到底是谁开发的？” Git的最大功臣，其实不是Linus”关于Git的故事，互联网上其实已经烂大街了。我简单给你介绍一下吧！Git的诞生其实是一个偶然，其初始使命是为Linux内核代码管理服务的。早年的时候Linux内核源码是用Bitkeeper版本控制工具管理的。可是，后来因为某些利益关系，Bitkeeper要求Linux社区付费使用。这一举动激怒了Linus，也就是Linux的创始人，他决定自己开发一个分布式版本控制系统。几周时间下来，Git的雏形就诞生了，并且开始在Linux社区中应用开来。虽然Linus是Git的创始人，可是背后的最大功臣却是一个日本人 Junio C Hamano。Linus在Git开源版本库的提交只有258次，而Junio C Hamano却提交了4000多次。也就是说，在Linus开发后不久项目的管理权就交给了这个日本人。关于 Junio C Hamano，你感兴趣的话可以Google了解一下。他现在在Google工作，如同Linus一样非常低调。“ “这个故事也告诉我：不要用技术去挑战一个程序员 @_@ ” 这个故事讲完，小明与Git的故事就已经告一段落了。其实，还有一些比较常见的问题，小明并没有问到过。这里，我为你准备了一个附录，给你介绍一些常用的小命令帮你解决日常小问题。它很有用，一定要拿笔记下来，或者收藏这篇文章备用。 常见问题问题一：公司的Git服务器是搭建在一个内网服务器上面的，我想把代码同时提交到OsChina上面，以便在家拉取代码，远程办公，怎么办？Git本身是一个分布式的版本管理系统，实现这个需求非常简单，使用git remote add命令添加多个远程版本库关联即可。12git remote add company git@xxxgit remote add home git@xxx 问题二：在拉取远程代码的时候，如果本地有代码还没有提交，Git就会提示先提交代码到版本库。可暂时我又不想提交，怎么办？针对这个问题，Git提供了一个临时区域用于保存不想提交的记录，对应的命令是git stash。通常情况下，你可以这样操作：123456789101112# 将暂时还不想提交的数据保存到临时区域，保存成功后，工作区将和版本库完全一致git stash# 还原stash数据到工作区git stash apply# 以上操作完成后，stash数据依然保存在临时区域中，为了删除这部分数据，使用如下命令即可。git stash drop# 如果你想在还原数据的同时从临时区域删除数据，可以这样操作：git statsh pop# 以上两个命令如果不接任何参数将删除掉所有的临时区域数据，如果你只想删除其中一条记录，指定对应索引数据即可。git stash pop/drop stash@&#123;index&#125;# 查看临时区域所有数据，使用如下命令：git stash list 问题三：作为项目负责人，我希望迅速找出问题代码的“元凶”，有什么办法吗？针对这个问题，最好的答案是git blame，使用这个命令并指定具体文件它将显示文件每一行代码的最近修改记录，你可以清晰地看待最近代码的修改人。 总结Git是一个非常优秀的版本控制系统，我极力推荐你在日常开发中使用。这篇文章从小明的角度解释了几个常见问题的解决方案，毫无悬念地，你可能还会遇到其它的一些问题。遇到问题，你可以尝试Google搜索解决方案。也可以在文章下方给我留言，我非常乐意为你解答Git问题。 我是欧阳锋，我愿为你鞍前马后，助你平步青云。如果你喜欢我的文章，请在下方留下你爱的印记。如果你不喜欢我的文章，请先喜欢上我的文章，然后再留下爱的印记。 下次文章再见！拜拜！]]></content>
      <categories>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制工具</tag>
        <tag>开发工具</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[也许你应该试试用Kotlin写Gradle脚本]]></title>
    <url>%2F2018%2F01%2F26%2Fkotlin%2F%E7%94%A8Kotlin%E5%86%99Android-Gradle%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Android应用开发中，离不开Gradle脚本的构建。大部分Android开发同学忽视了脚本的力量，甚至有很大一部分同学不知道Gradle脚本是什么，用什么语言编写的；当然，也有相当一部分同学知道Gradle脚本是使用Groovy语言编写的，但对于Groovy语言却一窍不通，只是勉强可以看懂Gradle脚本。正所谓，知其然，但并不知其所以然… 换个角度看问题，熟练掌握Gradle脚本还需要精通Groovy语言，这对Android开发同学来说的确是一个不小的挑战。这种Java + Groovy的开发套餐对于普通的Android开发者来说的确存在一定的知识断层，显而易见的是，部分同学写的Gradle脚本简直“不堪入目”。时间回到去年5月份，Google IO大会上宣布了一个重磅消息，Android官方开始支持使用Kotlin语言进行应用开发。其实，在这个时间节点上，我已经在生产环境使用Kotlin开发Android将近一年。对于我来说，这无疑是一个让人欣喜若狂的消息。但，惊喜还远远不止这些，过了一段时间，我又看到了这篇文章 Kotlin Meets Gradle。很有诗意的标题：当Gradle邂逅Kotlin，文章的核心意思是：Gradle团队正在尝试使用Kotlin语言作为Gradle脚本的官方开发语言。 我想，也许，Android开发者的春天就要到了！ Why use Kotlin ?在写Gradle脚本的时候，最痛苦的莫过于没有任何提示，唯一的调试手段就是使用print方法打印调试日志。正如 Kotlin Meets Gradle 文中所说，当你使用Kotlin语言编写Gradle脚本的时候，你会发现一切都变得有趣起来。突然： 脚本代码可以自动补全了 源码之间可以互相跳转了 插件源码更容易看懂了 重构（Refactoring）也可以支持了… 当然，惊喜还不止这些，当你开始决定使用Kotlin语言的时候，仿佛一切都变得美好了起来！ Let’s start好了，废话不多说，接下来我们开始尝试用Kotlin语言编写Gradle脚本。由于当前 kotlin-dsl 正处于预发布状态（kotlin-dsl的最新版本是0.14.2，对应Gradle插件版本4.5），IDE的支持也不完善，为了更好的体验该功能，推荐大家使用如下配置： 实验室配置操作系统：macOS 10.13.2Android Studio： 3.1 Canary 9Gradle Wrapper： 4.5Gradle Plugin： 3.1.0-alpha9Kotlin：1.2.21 操作步骤首先，按照以往步骤创建一个Android工程： 接下来，改造开始，Gradle Script Kotlin脚本以.gradle.kts后缀结尾。因此，我们先将工程根目录settings.gradle更名为settings.gradle.kts。 这个地方的错误有两个原因： Kotlin语言中，单引号只能包裹字符，不能包裹字符串 Kotlin语言中，方法调用使用括号。仅在使用infix修饰的方法中可以省略括号。这里显然是一个正常调用方法。因此，我们修改为：1include(&quot;app&quot;) 接下来，修改根目录的build.gradle脚本，用同样的方式修改后缀，方法修改为括号调用，修改后的内容如下：1234567891011121314151617buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; // 这里修改为括号调用即可 classpath(&quot;com.android.tools.build:gradle:3.0.1&quot;) &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() &#125;&#125; 注意：在修改后缀名称的时候IDE会出现警告提示，这里可以忽略，选择continue即可。 由于我们手动修改了build.gradle脚本，为了保证工程可以使用这个脚本，需要在settings.gradle.kts中添加一行代码，让Gradle知道使用build.gradle.kts脚本构建。因此，最后的settings.gradle.kts代码如下：12include(&quot;app&quot;)rootProject.buildFileName = &quot;build.gradle.kts&quot; 最后一步，修改app模块build.gradle文件，这也是最复杂的一步，修改完后缀名后，你会看到整个脚本全部被红色标识错误： 别慌！还是一样的方式，这里我们先将这里的所有代码注释掉。在最上方逐一对应修改，apply plugin部分修改为:123plugins &#123; id(&quot;com.android.application&quot;)&#125; 接下来，修改android {}闭包部分。这里有两个小技巧，由于目前IDE的支持不是很完善，在输入的时候稍微等待一段时间，IDE会给出相应的提示。另外，如果没有提示，例如android {}闭包就没有任何提示，输入完成后展开右侧gradle面板，选择gradle/buid setup/init，双击执行： 在底部面板可以看到任务执行是否成功。注意，即使任务执行成功，脚本依然可能被红色标识，这是IDE支持不完善导致的，可以忽略。 修改完成后的内容如下：1234567891011121314151617181920android &#123; compileSdkVersion(27) buildToolsVersion(&quot;27.0.2&quot;) defaultConfig &#123; applicationId = &quot;com.youngfeng.kotlindsl&quot; minSdkVersion(15) targetSdkVersion(27) versionCode = 1 versionName = &quot;1.0&quot; testInstrumentationRunner = &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; getByName(&quot;release&quot;) &#123; isMinifyEnabled = true proguardFiles(getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;) &#125; &#125;&#125; 注意：你在使用的过程中，依然可能会遇到无论如何都不生效的问题。这个时候别着急，使用./gradlew assembleDebug命令调试，查看终端找到错误原因。Windows用户去掉./执行即可。 最后的依赖部分，同样地，全部修改为括号调用即可。这里就不赘述了，文章的最后部分会提供操作视频，在使用过程中有任何问题可以打开操作视频参考，如果依然不能解决，可以在文章下方给我留言，我会在第一时间给你答复。修改后的内容如下：12345678dependencies &#123; implementation(fileTree(mapOf(&quot;dir&quot; to &quot;libs&quot;, &quot;include&quot; to listOf(&quot;*.jar&quot;)))) implementation(&quot;com.android.support:appcompat-v7:26.1.0&quot;) implementation(&quot;com.android.support.constraint:constraint-layout:1.0.2&quot;) testImplementation(&quot;junit:junit:4.12&quot;) androidTestImplementation(&quot;com.android.support.test:runner:1.0.1&quot;) androidTestImplementation(&quot;com.android.support.test.espresso:espresso-core:3.0.1&quot;)&#125; 通过上面的步骤，从Groovy转换到Kotlin的步骤已经全部完成，你可以在终端输入./gradlew assembleDebug测试是否可以正常构建了： 统一依赖管理上面的步骤虽然完成了脚本的转换，但依赖的管理依然是混乱的，为了实现类似 Snake 工程的统一依赖管理，我们还需要做一些工作。 Gradle官方提供了使用 buildSrc 目录实现自定义任务和插件逻辑，这里我们可以使用它完成依赖的统一处理，一个完整的buildSrc目录结构如下： Deps类中，可以这样定义依赖结构：1234567891011121314151617181920212223object deps &#123; object plugin &#123; val gradle = &quot;com.android.tools.build:gradle:3.1.0-alpha09&quot; val kotlin = &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.2.21&quot; &#125; object kotlin &#123; val stdlibJre7 = &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.21&quot; &#125; object android &#123; object support &#123; val compat = &quot;com.android.support:appcompat-v7:27.0.2&quot; val constraintLayout = &quot;com.android.support.constraint:constraint-layout:1.0.2&quot; &#125; object test &#123; val junit = &quot;junit:junit:4.12&quot; val runner = &quot;com.android.support.test:runner:1.0.1&quot; val espressoCore = &quot;com.android.support.test.espresso:espresso-core:3.0.1&quot; &#125; &#125;&#125; 定义之后，我们就可以在脚本中直接引用了：123456789dependencies &#123; implementation(fileTree(mapOf(&quot;dir&quot; to &quot;libs&quot;, &quot;include&quot; to listOf(&quot;*.jar&quot;)))) implementation(deps.kotlin.stdlibJre7) implementation(deps.android.support.compat) implementation(deps.android.support.constraintLayout) testImplementation(deps.android.test.junit) androidTestImplementation(deps.android.test.runner) androidTestImplementation(deps.android.test.espressoCore)&#125; 是不是漂亮了许多？ 至此，整个转换过程就顺利完成了，为了保证转换的成功率，我推荐使用文章开头的实验室配置。如果版本过低，不保证可以转换成功。最新版本的kotlin-dsl会跟随最新版本的Gradle插件发布，因此一定要使用最新版本。另外，目前IDE对kts的支持依然不完善，即使正确的写法也会报错，这个一定要注意，不要被IDE欺骗了。 更详细的操作，请看视频教程腾讯视频：用Kotlin写Android Gradle脚本 一些建议虽然使用Kotlin语言写脚本是一件非常美妙的事情，但目前依然存在一些问题： IDE支持不完善 kotlin-dsl 正在快速开发中，语法变动较大 缺少官方文档 互联网上缺少相关资料，遇到问题很难追踪 因此，目前我并不推荐你在生产环境中使用，但可以作为日常学习练手之用。预计1.0版本的发布在今年6月份左右，正式版本发布后，我推荐你立即将Gradle脚本转换到Kotlin语言。 遇到问题，看这里 ==&gt;在使用的过程中，按照文章同样的步骤，你依然可能会遇到很多问题。因此，我为你整理了目前互联网上可以参考的资料，你可以收藏这篇文章。遇到问题别慌，来这里查找答案。 关于kotlin-dsl的开发路线图，请看这篇文章：https://blog.gradle.org/kotlin-scripting-update 如果你在使用过程中，遇到了任何问题，并且确定是 kotlin-dsl 的bug，请点这里：https://github.com/gradle/kotlin-dsl 并推送 issue 如果你遇到了知识盲点，并且在Google找不到答案。可以来 Slack#gradle频道反馈，我在 Slack 的昵称是Scott Smith，也欢迎你给我发送私信消息。 本篇文章例子完整代码，请点击这里：https://github.com/yuanhoujun/gradle-script-kotlin-example kts文档正在编写当中，具体进度，请点这里：https://github.com/gradle/kotlin-dsl-docs 欢迎加入Kotlin交流群如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。]]></content>
      <categories>
        <category>Kotlin</category>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Groovy</tag>
        <tag>Gradle</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 代理模式]]></title>
    <url>%2F2016%2F08%2F22%2Fkotlin%2Fdelegation%2F</url>
    <content type="text"><![CDATA[代理模式是23种经典设计模式之一，代理模式被认为是继承的更好替代解决方案；因为代理比继承更加灵活，在Java语言中，通过反射可以实现动态代理，动态代理可以实现AOP编程，即：可以动态地往已有类中添加逻辑；比如：实现事务的自动提交，异常的自动捕获，热修复等等; 在Kotlin语言中，代理模式是默认支持的，不需要任何额外的代码，你只需要记住一个关键字by。我们不妨来试一下: 12345678910111213141516interface Base &#123; fun sayHi()&#125;class BaseImpl : Base &#123; override fun sayHi() &#123; println(&quot;BaseImpl-&gt;sayHi&quot;) &#125;&#125;class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl() val derived = Derived(b) derived.sayHi()&#125; 这里Derived作为BaseImpl的代理类，拥有BaseImpl类中的所有方法，Derived将代理BaseImpl类执行BaseImpl类中的所有方法，就像继承自BaseImpl类一样。这样说起来有点抽象，来看一下Kotlin编译器具体为我们做了一些什么。但是，怎么看呢？教大家一个方法！大家都知道，Kotlin和Java均是JVM语言，最终均转换到同样的Java字节码，这样我们就可以先将Kotlin编译为.class文件，再反编译为.java文件，看看对应的Java代码，我们就可以看到更多的细节。下面是最终反编译生成的Java代码: 12345678public final class Derived implements Base &#123; public Derived(@NotNull Base b) &#123; this.$$delegate_0 = b; &#125; public void sayHi() &#123; this.$$delegate_0.sayHi(); &#125;&#125; 这里，我们可以清楚地看到，Kotlin编译器为我们动态添加了一个成员变量$$delegate_0，这个成员变量代表被代理的对象，这里对应的是BaseImpl对象，Derived里面的sayHi方法最终调用是代理对象的sayHi方法，即Kotlin编译器帮我们提供了一个非常漂亮的代理模式实现。 代理属性在一些情况下，我们可能希望某些属性延迟加载，即在我们正在需要的时候才对它赋值；亦或者我们希望可以随时监听属性值的变化；在上述这些场景中，代理属性就可以发挥作用了。 代理属性的语法格式如下： 123456789101112131415161718class DelegateProperty &#123; val d: String by Delegate()&#125;class Delegate &#123; operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;): String &#123; return &quot;Invoke getValue() , thisRef = $thisRef , property name = $&#123;property.name&#125;&quot; &#125; operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: String) &#123; println(&quot;Invoke setValue() , thisRef = $thisRef , property name = $&#123;property.name&#125; , value = $value&quot;) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val dp = DelegatedProperty() dp.d = &quot;Value0&quot; // Invoke setValue() , thisRef = DelegatedProperty@2ef1e4fa , property name = d , value = Value0 println(dp.d) // Invoke getValue() , thisRef = DelegatedProperty@2ef1e4fa , property name = d&#125; 这里的代理是如何实现的呢？我们知道，Kotlin的属性值会自动生成set/get方法，而代理类通过代理set/get方法生成相应的代理方法，这里的方法对应关系如下： 1234// thisRef对应代理对象的引用，property对应代理属性的反射属性封装// 注意这里的代理方法一定要添加operator关键字，operator关键字是重载操作符关键字，后续的文章中会讲到，敬请期待get() -&gt; operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;)set() -&gt; operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: T) Kotlin标准库提供了一些常用代理的方法实现，即上文提到的几种代理，先来看第一种：延迟加载。 延迟加载Kotlin提供了一个lazy方法用于实现延迟加载，lazy方法有一个lambda表达式参数，用于对属性进行初始化赋值，而一旦完成赋值，该lambda表达式将不会再次调用。lambda表达式调用发生在第一次使用该属性的时候，即实现了属性赋值的延迟加载。来看一个简单的例子: 1234567891011// 使用标准库实现的lazy函数，实现属性的延迟加载private val lazyValue: String by lazy &#123; println(&quot;调用该初始赋值表达式完成赋值&quot;) // 这里是实际赋值 &quot;Hello, world&quot;&#125;fun main(args: Array&lt;String&gt;) &#123; // 仅在第一次会调用lazy方法的lambda表达式 println(lazyValue) // 打印：调用该初始赋值表达式完成赋值 println(lazyValue) // 打印： Hello, world, 再次调用将不再调用lambda表达式&#125; lazy方法是一个线程安全的延迟加载方法，为了加深大家的理解，根据上面的原理，我们尝试自己来实现一个非线程安全的延迟加载方法，看具体实现： 1234567891011121314151617181920212223242526272829private object UNINITIALIZE_VALUEclass MyLazy&lt;T&gt;(initialize: ()-&gt;T) &#123; private var value: Any? = UNINITIALIZE_VALUE private val initialize = initialize operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;): T &#123; if(value == UNINITIALIZE_VALUE) &#123; value = initialize() &#125; return value as T &#125; operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: T) &#123; this.value = value &#125;&#125;// 为了和标准库区分，使用__lazy命名fun &lt;T&gt; __lazy(initialize: () -&gt; T): MyLazy&lt;T&gt; = MyLazy(initialize)var lazyValue1 by __lazy &#123; println(&quot;自定义lazy初始化赋值表达式被调用&quot;) &quot;Hello , world&quot;&#125;fun main(args: Array&lt;String&gt;) &#123; // 自定义延迟加载函数__lazy println(lazyValue1) lazyValue1 = &quot;Other value&quot; println(lazyValue1)&#125; 由此可见，实现一个延迟加载接口并不复杂，最重要的是要理解延迟加载的过程以及实现原理。总结实现延迟加载接口，需要注意三个地方： 需要提供初始化lambda表达式参数，用于初始赋值 需要实现代理属性对象的setValue/getValue方法，如果是val则只需要实现getValue即可 需要严格确保属性不会被多次初始化 Observable属性Kotlin标准库还提供了一个可观察属性，这个属性使用观察者模式实现，如果属性值发生变化则会调用相应的回调lambda接口通知使用者，先看一个具体的例子: 123456789var observableValue by Delegates.observable(&quot;Initial value&quot;) &#123; prop , old , new -&gt; println(&quot;$old -&gt; $new&quot;)&#125;fun main(args: Array&lt;String&gt;) &#123; println(observableValue) // 打印：Initial value observableValue = &quot;Hello&quot; // 打印: Initial value -&gt; Hello println(observableValue) // 打印：Hello&#125; 这里的具体实现，感兴趣的同学请参看文章开头的方法进行追踪！ Storing Properties in a Map这也是Kotlin标准库提供的一个非常有用的特性，它主要用于JSON数据的解析。看官方的例子： 123456789class User(val map: Map&lt;String, Any?&gt;) &#123; val name: String by map val age: Int by map&#125;val user = User(mapOf( &quot;name&quot; to &quot;John Doe&quot;, &quot;age&quot; to 25)) 该方法比较简单，这里就不再赘述了！ 总结至此，关于代理的介绍可以暂时告一段落了！代理模式是一个非常经典设计模式，在解决某些问题中可以发挥事半功倍的效果。幸运的是，Kotlin语言原生支持代理模式，实现代理模式如同声明一个属性一样简单。而且，代理模式的设计也非常漂亮，仅仅使用一个关键字by极尽简约之美。在日常编码中，一定要灵活运用代理模式，比如实现延迟加载，实现属性观察等等。KotterKnife 是一个非常经典的代理模式的实现例子，有兴趣的同学可以clone该仓库，查看源码，领会代理模式的优美。 欢迎加入Kotlin交流群如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。 文章源码地址Kotliner: https://github.com/yuanhoujun/Kotliner,别忘了点击仓库右上方的star哦！]]></content>
      <categories>
        <category>Kotlin</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>代理模式</tag>
        <tag>代理属性</tag>
        <tag>延迟加载</tag>
      </tags>
  </entry>
</search>
