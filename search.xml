<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作符重载及中缀调用]]></title>
    <url>%2F2018%2F02%2F06%2Fkotlin%2F%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8A%E4%B8%AD%E7%BC%80%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[操作符重载其实很有意思！但这个概念却很少有人知道，使用操作符重载在某种程度上会给代码的阅读带来一定的麻烦。因此，慎用操作符被认为是一个好习惯。的确，操作符重载是一把双刃剑，既能削铁如泥，也能“引火烧身”，这篇文章将从实用的角度来讲解操作符重载的基本用法。 支持重载的操作符类型Kotlin语言支持重载的操作符类型比较多。以最新版本1.2.21为准，目前支持重载的操作符可以归纳为以下几类： 一元操作符一元前缀操作符 操作符 对应方法 +a a.unaryPlus() -a a.unaryMinus() !a a.not() 以上三个操作符在日常使用中频率很高，第一个操作符在基本运算中很少使用，第二个操作符就是常见的取反操作，第三个操作符是逻辑取反操作。接下来，我们使用扩展的方式重载这三个操作符：1234567891011121314151617181920212223242526272829303132333435363738394041/** * 一元操作符 * * @author Scott Smith 2018-02-03 14:11 */data class Number(var value: Int)/** * 重载一元操作符+，使其对Number中实际数据取绝对值 */operator fun Number.unaryPlus(): Number &#123; this.value = Math.abs(value) return this&#125;/** * 重载一元操作符-，使其对Number中实际数据取反 */operator fun Number.unaryMinus(): Number &#123; this.value = -value return this&#125;/** * 这个操作符通常是用于逻辑取反，这里用一个没有意义的操作，来模拟重载这个操作符 * 结果：始终返回Number中实际数据的负值 */operator fun Number.not(): Number &#123; this.value = -Math.abs(value) return this&#125;fun main(args: Array&lt;String&gt;) &#123; val number = Number(-3) println(&quot;Number value = $&#123;number.value&#125;&quot;) println(&quot;After unaryPlus: Number value = $&#123;(+number).value&#125;&quot;) println(&quot;After unaryMinus: Number value = $&#123;(-number).value&#125;&quot;) number.value = Math.abs(number.value) println(&quot;After unaryNot: Number value = $&#123;(!number).value&#125;&quot;)&#125; 运行上述代码，将得到如下结果：1234Number value = -3After unaryPlus: Number value = 3After unaryMinus: Number value = -3After unaryNot: Number value = -3 自增和自减操作符 操作符 对应方法 a++/++a a.inc() a–/–a a.dec() 重载这个操作符相对比较难理解，官方文档有一段简短的文字解释，翻译成代码可以这样表示：123456789101112// a++fun increment(a: Int): Int &#123; val a0 = a a = a + 1 return a0&#125;// ++afun increment(a: Int): Int &#123; a = a + 1 return a&#125; 看懂上面的代码后，我们换成需要重载的Number类，Kotlin最终会这样处理：1234567891011// Number++fun increment(number: Number): Number &#123; val temp = number val result = number.inc() return result&#125;// Number++fun increment(number: Number): Number &#123; return number.inc()&#125; 因此，重载Number类自加操作符，我们可以这样做：123operator fun Number.inc(): Number &#123; return Number(this.value + 1)&#125; 重载自减操作符同理，完整代码请参考我的Git版本库：kotlin-samples 二元操作符算术运算符 操作符 对应方法 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b) a..b a.rangeTo(b) 前5个操作符相对比较好理解，我们以a + b为例，举个一个简单的例子：12345678910// 重载Number类的加法运算符operator fun Number.plus(value: Int): Number &#123; return Number(this.value + value)&#125;fun main(args: Array&lt;String&gt;) &#123; println((Number(1) + 2))&#125;// 输出结果：Number value = 3 相对比较难理解的是第六个范围运算符，这个操作符主要用于生成一段数据范围。我们认为Number本身就代表一个整型数字，因此，重载Number是一件有意义的事情。直接看例子：123456789101112131415161718192021operator fun Number.rangeTo(to: Number): IntRange &#123; return this.value..to.value&#125;fun main(args: Array&lt;String&gt;) &#123; val startNumber = Number(3) val endNumber = Number(9) (startNumber..endNumber).forEach &#123; println(&quot;value = $it&quot;) &#125;&#125;// 运行结果：value = 3value = 4value = 5value = 6value = 7value = 8value = 9 “In”运算符 操作符 对应方法 a in b b.contains(a) a !in b !b.contains(a) 这个操作符相对比较好理解，重载这个操作符可以用于判断某个数据是否在另外一个对象中。我们用一个非常简单的自定义类来模拟集合操作：1234567891011121314151617class IntCollection &#123; val intList = ArrayList&lt;Int&gt;()&#125;// 重载&quot;in&quot;操作符operator fun IntCollection.contains(value: Int): Boolean &#123; return this.intList.contains(value)&#125;fun main(args: Array&lt;String&gt;) &#123; val intCollection = IntCollection() intCollection.add(1, 2, 3) println(3 in intCollection)&#125;// 输出结果：true 索引访问运算符 操作符 对应方法 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, …, i_n] a.get(i_1, …, i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, …, i_n] = b a.set(i_1, …, i_n, b) 这个操作符很有意思，例如，如果你要访问Map中某个数据，通常是这样的map.get(&quot;key&quot;)，使用索引运算符你还可以这样操作：1val value = map[&quot;key&quot;] 我们继续以IntCollection类为例，尝试重写a[i]和a[i] = b两个运算符，其它运算符同理。123456789101112131415161718// 重载a[i]操作符operator fun IntCollection.get(index: Int): Int &#123; return intList[index]&#125;// 重载a[i] = b操作符operator fun IntCollection.set(index: Int, value: Int) &#123; intList[index] = value&#125;fun main(args: Array&lt;String&gt;) &#123; val intCollection = IntCollection() intCollection.add(1, 2, 3) println(intCollection[0]) intCollection[2] = 4 print(intCollection[2])&#125; 接下来，我们用索引运算符来做一点更有意思的事情！新建一个普通的Kotlin类User：1234class User(var name: String, var age: Int) &#123;&#125; 使用下面的方式重载索引运算符：1234567891011121314151617181920212223operator fun User.get(key: String): Any? &#123; when(key) &#123; &quot;name&quot; -&gt; &#123; return this.name &#125; &quot;age&quot; -&gt; &#123; return this.age &#125; &#125; return null&#125;operator fun User.set(key: String, value:Any?) &#123; when(key) &#123; &quot;name&quot; -&gt; &#123; name = value as? String &#125; &quot;age&quot; -&gt; &#123; age = value as? Int &#125; &#125;&#125; 接下来，你会神奇地发现，一个普通的Kotlin类居然也可以使用索引运算符对成员变量进行操作了，是不是很神奇？123456fun main(args: Array&lt;String&gt;) &#123; val user = User(&quot;Scott Smith&quot;, 18) println(user[&quot;name&quot;]) user[&quot;age&quot;] = 22 println(user[&quot;age&quot;])&#125; 因此，索引运算符不仅仅可以对集合类数据进行操作，对一个普通的Kotlin类也可以发挥同样的作用。如果你脑洞足够大，你还可以发现更多更神奇的玩法。 调用操作符 操作符 对应方法 a() a.invoke() a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, ……, i_n) a.invoke(i_1, ……, i_n) 重载这个操作符并不难，理解它的应用场景却有一定的难度。为了理解它的应用场景，我们来举一个简单的例子：12345678910111213class JsonParser &#123;&#125;operator fun JsonParser.invoke(json: String): Map&lt;String, Any&gt; &#123; val map = Json.parse(json) ... return map&#125;// 可以这样调用val parser = JsonParser()val map = parser(&quot;&#123;name: \&quot;Scott Smith\&quot;&#125;&quot;) 这里的调用有点像省略了一个解析Json数据的方法，难道它仅仅就是这个作用吗？是的，调用操作符其实就这一个作用。如果一个Kotlin类仅仅只有一个方法，直接使用括号调用的确是一个不错的主意。不过，在使用的时候还是要稍微注意一下，避免出现歧义。 广义赋值操作符 操作符 对应方法 a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.remAssign(b) 这个操作符相对比较好理解，我们以Number类为例，举一个简单的例子：12345678910111213// 广义赋值运算符operator fun Number.plusAssign(value: Int) &#123; this.value += value&#125;fun main(args: Array&lt;String&gt;) &#123; val number = Number(1) number += 2 println(number)&#125;// 输出结果：Number value = 3 相等与不等操作符 操作符 对应方法 a == b a?.equals(b) ?: (b === null) a != b !(a?.equals(b) ?: (b === null)) 重载这个操作符与Java重写equals方法是一样的。不过，这里要注意与Java的区别，在Java端==用于判断两个对象是否是同一对象（指针级别）。而在Kotlin语言中，如果我们不做任何处理，==等同于使用Java对象的equals方法判断两个对象是否相等。 另外，这里还有一种特殊情况，如果左值等于null，这个时候a?.equals(b)将返回null值。因此，这里还增加了?:运算符用于进一步判断，在这个情况下，当且仅当b === null的时候，a、b才有可能相等。因此，才有了上面的对应关系，这里以User类为例举一个简单的例子：12345678910class User(var name: String?, var age: Int?) &#123; operator override fun equals(other: Any?): Boolean &#123; if(other is User) &#123; return (this.name == other.name) &amp;&amp; (this.age == other.age) &#125; return false &#125;&#125; 注意：这里有一个特殊的地方，与其它操作符不一样的地方是，如果使用扩展的方式尝试重载该操作符，将会报错。因此，如果要重载该操作符，一定要在类中进行重写。 比较操作符 操作符 对应方法 a &gt; b a.compareTo(b) &gt; 0 a &lt; b a.compareTo(b) &lt; 0 a &gt;= b a.compareTo(b) &gt;= 0 a &lt;= b a.compareTo(b) &lt;= 0 比较操作符是一个在日常使用中频率非常高的操作符，重载这个操作符只需要掌握以上表格中几个规则即可。我们以Number类为例举一个简单的例子：123operator fun Number.compareTo(number: Number): Int &#123; return this.value - number.value&#125; 属性委托操作符属性委托操作符是一种非常特殊的操作符，其主要用在代理属性中。关于Kotlin代理的知识，如果你还不了解的话，请参考这篇文章 Delegation。这篇文章介绍的相对简略，后面会出一篇更详细的文章介绍代理相关的知识。 中缀调用看到这里，可能有一些追求更高级玩法的同学会问：Kotlin支持自定义操作符吗？ 答案当然是：不能！不过，别失望，infix也许适合你，它其实可以看做一种自定义操作符的实现。这里我们对集合List新增一个扩展方法intersection用于获取两个集合的交集：1234567891011// 获取两个集合的交集fun &lt;E&gt; List&lt;E&gt;.interSection(other: List&lt;E&gt;): List&lt;E&gt; &#123; val result = ArrayList&lt;E&gt;() forEach &#123; if(other.contains(it)) &#123; result.add(it) &#125; &#125; return result&#125; 接下来，我们就可以在List及其子类中使用点语法调用了。但，它看起来仍然不像一个操作符。为了让它更像一个操作符，我们继续做点事情： 添加infix关键词 将函数名修改为∩（这是数学上获取交集的标记符号）然而，万万没想到，修改完成后居然报错了。Kotlin并不允许直接使用特殊符号作为函数名开头。因此，我们取形近的字母n用于表示函数名：1234567891011// 获取两个集合的交集infix fun &lt;E&gt; List&lt;E&gt;.n(other: List&lt;E&gt;): List&lt;E&gt; &#123; val result = ArrayList&lt;E&gt;() forEach &#123; if(other.contains(it)) &#123; result.add(it) &#125; &#125; return result&#125; 接下来，我们就可以这样调用了val interSection = list1 n list2，怎么样？是不是很像自定义了一个获取交集的操作符n？如果你希望自定义操作符，可以尝试这么做。 其实infix的应用场景还不止这些，接下来，我们再用它完成一件更有意思的事情。 在实际项目开发中，数据库数据到对象的处理是一件繁琐的过程，最麻烦的地方莫过于思维的转换。那我们是否可以在代码中直接使用SQL语句查询对象数据呢？例如这样：1val users = Select * from User where age &gt; 18 纸上学来终觉浅，觉知此事需躬行。有了这个idea，接下来，我们就朝着这个目标努力。一、先声明一个Sql类，准备如下方法：1234567infix fun select(columnBuilder: ColumnBuilder): Sql &#123;infix fun from(entityClass: Class&lt;*&gt;): Sql infix fun where(condition: String): Sql fun &lt;T&gt; query(): T 二、我们的目的是：最终转换到SQL语句形式。因此，增加如下实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class ColumnBuilder(var columns: Array&lt;out String&gt;) &#123;&#125;class Sql private constructor() &#123; var columns = emptyList&lt;String&gt;() var entityClass: Class&lt;*&gt;? = null var condition: String? = null companion object &#123; fun get(): Sql &#123; return Sql() &#125; &#125; infix fun select(columnBuilder: ColumnBuilder): Sql &#123; this.columns = columnBuilder.columns.asList() return this &#125; infix fun from(entityClass: Class&lt;*&gt;): Sql &#123; this.entityClass = entityClass return this &#125; infix fun where(condition: String): Sql &#123; this.condition = condition return this &#125; fun &lt;T&gt; query(): T &#123; // 此处省略所有条件判断 val sqlBuilder = StringBuilder(&quot;select &quot;) val columnBuilder = StringBuilder(&quot;&quot;) if(columns.size == 1 &amp;&amp; columns[0] == &quot;*&quot;) &#123; columnBuilder.append(&quot;*&quot;) &#125; else &#123; columns.forEach &#123; columnBuilder.append(it).append(&quot;,&quot;) &#125; columnBuilder.delete(columns.size - 1, columns.size) &#125; val sql = sqlBuilder.append(columnBuilder.toString()) .append(&quot; from $&#123;entityClass?.simpleName&#125; where &quot;) .append(condition) .toString() println(&quot;执行SQL查询：$sql&quot;) return execute(sql) &#125; private fun &lt;T&gt; execute(sql: String): T &#123; // 仅仅用于测试 return Any() as T &#125;&#125; 三、为了看起来更形似，再增加如下两个方法：123456789// 使其看起来像在数据库作用域中执行fun database(init: Sql.()-&gt;Unit) &#123; init.invoke(Sql.get())&#125;// 因为infix限制，参数不能直接使用可变参数。因此，我们增加这个方法使参数组装看起来更自然fun columns(vararg columns: String): ColumnBuilder &#123; return ColumnBuilder(columns)&#125; 接下来，就是见证奇迹的时刻！12345678fun main(args: Array&lt;String&gt;) &#123; database &#123; (select (columns(&quot;*&quot;)) from User::class.java where &quot;age &gt; 18&quot;).query() &#125;&#125;// 输出结果：执行SQL查询：select * from User where age &gt; 18 为了方便大家查看，我们提取完整执行代码段与SQL语句对比：12select * from User where age &gt; 18select (columns(&quot;*&quot;)) from User::class.java where &quot;age &gt; 18&quot; 神奇吗？至此，我们就可以直接在代码中愉快地使用类似SQL语句的方式进行方法调用了。 总结本篇文章从操作符重载实用的角度讲解了操作符重载的所有相关知识。如文章开头所说，操作符重载是一把双刃剑。用得好事半功倍，用不好事倍功半。因此，我给大家的建议是：使用的时候一定要保证能够自圆其说，简单来说，就是自然。我认为相对于古老的语言C++来说，Kotlin语言操作符重载的设计是非常棒的。如果你知道自己在做什么，我非常推荐你在生产环境中使用操作符重载来简化操作。 本篇文章例子代码点这里：kotlin-samples 我是欧阳锋，一个热爱Kotlin语言编程的学生。如果你喜欢我的文章，请在文章下方留下你爱的印记。如果你不喜欢我的文章，请先喜欢上我的文章。然后再留下爱的印记！ 下次文章再见，拜拜！]]></content>
      <categories>
        <category>Kotlin</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
        <tag>操作符</tag>
        <tag>重载</tag>
        <tag>infix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 代理模式]]></title>
    <url>%2F2016%2F08%2F22%2Fkotlin%2Fdelegation%2F</url>
    <content type="text"><![CDATA[代理模式是23种经典设计模式之一，代理模式被认为是继承的更好替代解决方案；因为代理比继承更加灵活，在Java语言中，通过反射可以实现动态代理，动态代理可以实现AOP编程，即：可以动态地往已有类中添加逻辑；比如：实现事务的自动提交，异常的自动捕获，热修复等等; 在Kotlin语言中，代理模式是默认支持的，不需要任何额外的代码，你只需要记住一个关键字by。我们不妨来试一下: 12345678910111213141516interface Base &#123; fun sayHi()&#125;class BaseImpl : Base &#123; override fun sayHi() &#123; println(&quot;BaseImpl-&gt;sayHi&quot;) &#125;&#125;class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl() val derived = Derived(b) derived.sayHi()&#125; 这里Derived作为BaseImpl的代理类，拥有BaseImpl类中的所有方法，Derived将代理BaseImpl类执行BaseImpl类中的所有方法，就像继承自BaseImpl类一样。这样说起来有点抽象，来看一下Kotlin编译器具体为我们做了一些什么。但是，怎么看呢？教大家一个方法！大家都知道，Kotlin和Java均是JVM语言，最终均转换到同样的Java字节码，这样我们就可以先将Kotlin编译为.class文件，再反编译为.java文件，看看对应的Java代码，我们就可以看到更多的细节。下面是最终反编译生成的Java代码: 12345678public final class Derived implements Base &#123; public Derived(@NotNull Base b) &#123; this.$$delegate_0 = b; &#125; public void sayHi() &#123; this.$$delegate_0.sayHi(); &#125;&#125; 这里，我们可以清楚地看到，Kotlin编译器为我们动态添加了一个成员变量$$delegate_0，这个成员变量代表被代理的对象，这里对应的是BaseImpl对象，Derived里面的sayHi方法最终调用是代理对象的sayHi方法，即Kotlin编译器帮我们提供了一个非常漂亮的代理模式实现。 代理属性在一些情况下，我们可能希望某些属性延迟加载，即在我们正在需要的时候才对它赋值；亦或者我们希望可以随时监听属性值的变化；在上述这些场景中，代理属性就可以发挥作用了。 代理属性的语法格式如下： 123456789101112131415161718class DelegateProperty &#123; val d: String by Delegate()&#125;class Delegate &#123; operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;): String &#123; return &quot;Invoke getValue() , thisRef = $thisRef , property name = $&#123;property.name&#125;&quot; &#125; operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: String) &#123; println(&quot;Invoke setValue() , thisRef = $thisRef , property name = $&#123;property.name&#125; , value = $value&quot;) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val dp = DelegatedProperty() dp.d = &quot;Value0&quot; // Invoke setValue() , thisRef = DelegatedProperty@2ef1e4fa , property name = d , value = Value0 println(dp.d) // Invoke getValue() , thisRef = DelegatedProperty@2ef1e4fa , property name = d&#125; 这里的代理是如何实现的呢？我们知道，Kotlin的属性值会自动生成set/get方法，而代理类通过代理set/get方法生成相应的代理方法，这里的方法对应关系如下： 1234// thisRef对应代理对象的引用，property对应代理属性的反射属性封装// 注意这里的代理方法一定要添加operator关键字，operator关键字是重载操作符关键字，后续的文章中会讲到，敬请期待get() -&gt; operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;)set() -&gt; operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: T) Kotlin标准库提供了一些常用代理的方法实现，即上文提到的几种代理，先来看第一种：延迟加载。 延迟加载Kotlin提供了一个lazy方法用于实现延迟加载，lazy方法有一个lambda表达式参数，用于对属性进行初始化赋值，而一旦完成赋值，该lambda表达式将不会再次调用。lambda表达式调用发生在第一次使用该属性的时候，即实现了属性赋值的延迟加载。来看一个简单的例子: 1234567891011// 使用标准库实现的lazy函数，实现属性的延迟加载private val lazyValue: String by lazy &#123; println(&quot;调用该初始赋值表达式完成赋值&quot;) // 这里是实际赋值 &quot;Hello, world&quot;&#125;fun main(args: Array&lt;String&gt;) &#123; // 仅在第一次会调用lazy方法的lambda表达式 println(lazyValue) // 打印：调用该初始赋值表达式完成赋值 println(lazyValue) // 打印： Hello, world, 再次调用将不再调用lambda表达式&#125; lazy方法是一个线程安全的延迟加载方法，为了加深大家的理解，根据上面的原理，我们尝试自己来实现一个非线程安全的延迟加载方法，看具体实现： 1234567891011121314151617181920212223242526272829private object UNINITIALIZE_VALUEclass MyLazy&lt;T&gt;(initialize: ()-&gt;T) &#123; private var value: Any? = UNINITIALIZE_VALUE private val initialize = initialize operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;): T &#123; if(value == UNINITIALIZE_VALUE) &#123; value = initialize() &#125; return value as T &#125; operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: T) &#123; this.value = value &#125;&#125;// 为了和标准库区分，使用__lazy命名fun &lt;T&gt; __lazy(initialize: () -&gt; T): MyLazy&lt;T&gt; = MyLazy(initialize)var lazyValue1 by __lazy &#123; println(&quot;自定义lazy初始化赋值表达式被调用&quot;) &quot;Hello , world&quot;&#125;fun main(args: Array&lt;String&gt;) &#123; // 自定义延迟加载函数__lazy println(lazyValue1) lazyValue1 = &quot;Other value&quot; println(lazyValue1)&#125; 由此可见，实现一个延迟加载接口并不复杂，最重要的是要理解延迟加载的过程以及实现原理。总结实现延迟加载接口，需要注意三个地方： 需要提供初始化lambda表达式参数，用于初始赋值 需要实现代理属性对象的setValue/getValue方法，如果是val则只需要实现getValue即可 需要严格确保属性不会被多次初始化 Observable属性Kotlin标准库还提供了一个可观察属性，这个属性使用观察者模式实现，如果属性值发生变化则会调用相应的回调lambda接口通知使用者，先看一个具体的例子: 123456789var observableValue by Delegates.observable(&quot;Initial value&quot;) &#123; prop , old , new -&gt; println(&quot;$old -&gt; $new&quot;)&#125;fun main(args: Array&lt;String&gt;) &#123; println(observableValue) // 打印：Initial value observableValue = &quot;Hello&quot; // 打印: Initial value -&gt; Hello println(observableValue) // 打印：Hello&#125; 这里的具体实现，感兴趣的同学请参看文章开头的方法进行追踪！ Storing Properties in a Map这也是Kotlin标准库提供的一个非常有用的特性，它主要用于JSON数据的解析。看官方的例子： 123456789class User(val map: Map&lt;String, Any?&gt;) &#123; val name: String by map val age: Int by map&#125;val user = User(mapOf( &quot;name&quot; to &quot;John Doe&quot;, &quot;age&quot; to 25)) 该方法比较简单，这里就不再赘述了！ 总结至此，关于代理的介绍可以暂时告一段落了！代理模式是一个非常经典设计模式，在解决某些问题中可以发挥事半功倍的效果。幸运的是，Kotlin语言原生支持代理模式，实现代理模式如同声明一个属性一样简单。而且，代理模式的设计也非常漂亮，仅仅使用一个关键字by极尽简约之美。在日常编码中，一定要灵活运用代理模式，比如实现延迟加载，实现属性观察等等。KotterKnife 是一个非常经典的代理模式的实现例子，有兴趣的同学可以clone该仓库，查看源码，领会代理模式的优美。 欢迎加入Kotlin交流群如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。 文章源码地址Kotliner: https://github.com/yuanhoujun/Kotliner,别忘了点击仓库右上方的star哦！]]></content>
      <categories>
        <category>Kotlin</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
        <tag>代理模式</tag>
        <tag>代理属性</tag>
        <tag>延迟加载</tag>
      </tags>
  </entry>
</search>
