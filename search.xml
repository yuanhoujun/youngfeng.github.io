<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[10分钟看懂动态代理设计模式（升级篇）]]></title>
    <url>%2F2019%2F11%2F29%2F10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%87%E7%BA%A7%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[关于动态代理，我之前写过一篇文章《10分钟看懂动态代理设计模式》。在这篇文章中，我收到了一些关于动态代理的提问，也有同学在微信公众号给我私信，询问关于动态代理的问题。再次Review这篇文章之后，我发现了一些问题。确实有一些细节没有介绍清楚，有一些地方含混过关了。因此，我决定重新写一篇关于动态代理的文章，希望可以讲清楚关于动态代理实现的每一处细节。这注定又是一场艰难的旅程，你愿意加入我们吗？ 这篇文章的思路还是同之前的文章一样，由浅入深，如果你已经看过上一篇文章，部分章节可以跳过。 静态代理那么，到底什么是代理呢？ 所谓的代理，其实就是中间人的意思。例如：让朋友代替你去取快递，你的朋友就充当了代理的作用。再比如，让你的朋友帮你去借款，你的朋友实际上也充当了代理的作用，最终这笔钱的受益人还是你自己。 理解了代理的意思，接下来我们一起来看一下，在面向对象编程语言中，到底应该如何体现代理呢。 这里我们就以上面提到的代取快递为例，来写一个简单的代理实现。 我们用Friend类表示你的朋友，用Self表示你自己，上面的例子用代码实现应该是这样： 1234567891011public class Friend &#123; private String name; public Friend(String name) &#123; this.name = name; &#125; public void collectPack() &#123; System.out.println(this.name + "去取快递..."); &#125;&#125; 1234567891011121314151617181920public class Self &#123; private Friend friend; public Self(Friend friend) &#123; this.friend = friend; &#125; // 由于实际动作的执行者是你的朋友 // 因此，这里直接调用Friend的collectPack方法 public void collectPack() &#123; friend.collectPack(); &#125; public static void main(String[] args) &#123; Friend friend = new Friend("张三"); Self self = new Self(friend); // 这里将打印”张三去取快递...“ self.collectPack(); &#125;&#125; 在上面这段代码中，我们实现了一个简单的代理。这里的代理类是Friend，被代理类是Self，通过这段代码，我们知道了一个基本事实：代理对象是真正去执行动作的对象，被代理对象是被动执行动作的对象（并不真正执行动作）。 上面的实现看似没有问题，实际上却不够友好，由于代理对象能够替被代理对象执行动作。所以，他们应该具有同样的一些方法。换句话说，应该实现他们应该实现同样的接口，这个接口中的方法表示双方都可以执行的一些动作，或者说可能要被代理的一些动作。 因此，上面的代码可以改写成下面这样： 12345// 这个接口表示代理类与被代理类可以共同执行的动作// 或者说，具体想要被代理的动作方法集合public interface Collectable &#123; void collectPack();&#125; 1234567891011public class Friend implements Collectable &#123; private String name; public Friend(String name) &#123; this.name = name; &#125; public void collectPack() &#123; System.out.println(this.name + "去取快递..."); &#125;&#125; 12345678910111213141516171819public class Self implements Collectable &#123; private Friend friend; public Self(Friend friend) &#123; this.friend = friend; &#125; // 由于实际动作的执行者是你的朋友 // 因此，这里直接调用Friend的collectPack方法 public void collectPack() &#123; friend.collectPack(); &#125; public static void main(String[] args) &#123; Friend friend = new Friend("张三"); Self self = new Self(friend); self.collectPack(); &#125;&#125; 恭喜你！通过上面的改造，我们已经完成了一个标准的静态代理实现。之所以称之为静态代理，是因为这里的逻辑是写死的，并不具备动态特性。与之相对的，就是今天这篇文章的主角：动态代理。 代理的作用是什么看到这里，应该有人会问了，说了这么多，代理到底有什么用呢。这个问题并不容易回答，为了回答你的这个问题，我们先来看一个场景。 假设有一个类Driver，类中只有一个方法drive，我们不能改动这个类的源码，如何获取这个方法的执行时间呢？ 12345678public class Driver &#123; public void drive() throws InterruptedException &#123; System.out.println("I'm driving..."); Thread.sleep(1000); System.out.println("Drive completed..."); &#125;&#125; 有的同学可能会说，这还不简单，在main方法中，方法执行前记录一个时间，方法执行后记录一个时间，两个时间相减就得到了方法最终的执行时间。 位置p1 123456789public static void main(String[] args) throws InterruptedException &#123; Driver driver = new Driver(); long start = System.currentTimeMillis(); driver.drive(); long end = System.currentTimeMillis(); System.out.println(end - start);&#125; 这个方法到底对不对呢，先说结论：不对！这里的时间会大于方法实际执行的时间，因为这里包含了准备方法的那些时间。 除了这个方法之外，还有一个比较容易想到的方法就是继承。通过继承Driver类，在drive方法前后打印时间，计算时间差，这种方式似乎可行！ 12345678910public class Driver1 extends Driver &#123; @Override public void drive() throws InterruptedException &#123; long start = System.currentTimeMillis(); super.drive(); long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 位置p2 1234public static void main(String[] args) throws InterruptedException &#123; Driver1 driver1 = new Driver1(); driver1.drive();&#125; 这里有一个疑点，有些同学在问，到底方法的准备时间是什么，为什么会有准备方法的这些时间。这两种方式不是都需要准备方法吗？ 上面我们说到，直接打印的方式包含了准备方法的那些时间，准备一个方法通常需要先压栈，调用后自动出栈，这些都需要时间，尤其在一些性能比较低的机器上会体现的特别明显。不信，大家可以执行位置p1处的代码与位置p2处的代码，你会发现，位置p2处的执行时间几乎总是比位置p1处的执行时间少3~5毫秒（在我的Macbook Pro 15.4 2017上执行是这样的结果，其它机型时间可能略有差异）。在继承中不需要这些时间的原因是：我们是方法内部执行的，这个时候方法已经准备好，就不存在这个准备时间了。 Ok，说完了上面这个问题，我们继续回到上面的代码。在上面的代码中，我们通过继承的方式获得了方法的执行时间。接下来，新需求来了，我要你在drive方法前后各打印一条日志。 你会怎么做呢，当然毫无疑问，我们继续沿用上面的解决方案，继承Driver类创建新类Driver2。然后，在super调用前后各打印一条日志。 123456789public class Driver2 extends Driver &#123; @Override public void drive() throws InterruptedException &#123; System.out.println("Drive start..."); super.drive(); System.out.println("Drive complete..."); &#125;&#125; 问题似乎很简单，可是，新的需求又来了。我要你先打印日志再获取方法的执行时间。其实，这也很简单。我们只要继承上面的Driver2类，重写drive方法获取方法执行的时间即可： 12345678910public class Driver3 extends Driver2 &#123; @Override public void drive() throws InterruptedException &#123; long start = System.currentTimeMillis(); super.drive(); long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 接下来，麻烦来了。需求又变了，我要你先获取方法的执行时间再打印日志，怎么办。 有人说，这也没毛病啊。我们只要继承Driver1创建新类Driver4，然后在drive方法中打印日志即可： 123456789public class Driver4 extends Driver1 &#123; @Override public void drive() throws InterruptedException &#123; System.out.println("Drive start..."); super.drive(); System.out.println("Drive complete..."); &#125;&#125; 也许你已经发现了，这个解决方案存在着明显的问题，如果一个类有100个方法，实现上述这些逻辑大概需要创建400个类，这显然不是一个可取的方法。那么，是否有更好的解决方案呢？ 在上面的解决方案中，我们通过继承的方式获取到了父类方法的执行时间。但是，如果Driver类被final修饰呢，大家知道final类是无法被继承的，继承这条路显然走不通了。 但这似乎恰好为我们打开了一扇窗，我们尝试使用文章开头静态代理的方式传入不同功能的Driver类实例，看看能否发生一些特殊的化学反应。 同样，我们以获取方法的执行时间为例，如果要通过静态代理的方式获取方法的执行时间，我们应该这样做： 1234567891011121314public class Driver5 &#123; private Driver driver; public Driver5(Driver driver) &#123; this.driver = driver; &#125; public void drive() throws InterruptedException &#123; long start = System.currentTimeMillis(); driver.drive(); long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 前面说到，我们应该将统一的动作抽象化。因此，这里我们新增统一的接口Drivable，我们让所有的Driver类都实现Drivable接口： 1234567891011121314public class Driver5 implements Drivable &#123; private Driver driver; public Driver5(Driver driver) &#123; this.driver = driver; &#125; public void drive() throws InterruptedException &#123; long start = System.currentTimeMillis(); driver.drive(); long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 同样地，为了在方法的执行前后打印日志，我们创建Driver6通过代理的方式实现日志的打印： 12345678910111213public class Driver6 implements Drivable &#123; private Driver driver; public Driver6(Driver driver) &#123; this.driver = driver; &#125; public void drive() throws InterruptedException &#123; System.out.println("Drive start..."); driver.drive(); System.out.println("Drive complete..."); &#125;&#125; 为了与前面的方式区分开来，我们将Driver5重命名为DriverTimeProxy，Driver6重命名为DriverLogProxy，接下来我们尝试先打印日志再获取方法的执行时间。 咋一看，似乎毫无头绪。别急，我们先尝试将聚合对象Driver抽象化。参数类型修改为Drivable（由于Driver类也实现了Drivable接口），修改完成后代码如下： 12345678910111213public class DriverLogProxy implements Drivable &#123; private Drivable drivable; public DriverLogProxy(Drivable drivable) &#123; this.drivable = drivable; &#125; public void drive() throws InterruptedException &#123; System.out.println("Drive start..."); drivable.drive(); System.out.println("Drive complete..."); &#125;&#125; 1234567891011121314public class DriverTimeProxy implements Drivable &#123; private Drivable drivable; public DriverTimeProxy(Drivable drivable) &#123; this.drivable = drivable; &#125; public void drive() throws InterruptedException &#123; long start = System.currentTimeMillis(); drivable.drive(); long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 至此，神奇的化学反应出现了。由于DriverLogProxy与DriveTimeProxy都实现了Drivable接口，我们可以将这两个对象相互聚合到对方的类中。 例如，如果我们要先打印方法的执行时间再打印日志，可以这样做： 12345678public static void main(String[] args) throws InterruptedException &#123; Driver driver = new Driver(); DriverTimeProxy driverTimeProxy = new DriverTimeProxy(driver); DriverLogProxy driverLogProxy = new DriverLogProxy(driverTimeProxy); driverLogProxy.drive();&#125; 而如果我们要先打印日志再打印方法的执行时间，可以这样做： 12345678public static void main(String[] args) throws InterruptedException &#123; Driver driver = new Driver(); DriverLogProxy driverLogProxy = new DriverLogProxy(driver); DriverTimeProxy driverTimeProxy = new DriverTimeProxy(driverLogProxy); driverTimeProxy.drive();&#125; 在前面的例子中，为了实现相同的功能，我们至少需要创建四个类，而这里似乎只需要两个类就搞定了。显然，这种通过代理处理的方式更优。 动态代理在上面的例子中，我们通过静态代理仅使用两个类就完成了四种不同顺序调用的组合，这种在一个类中持有另一个类的实例引用的方式也被称之为聚合。在这种场景中，我们可以说，聚合优于继承。 接下来，我们继续加大问题的难度，我们是否可以在任意对象的任意方法前后添加任意的操作呢？并且不需要增加额外的类。 这个问题的难度一下提高了不少，为了简化问题的难度，我们将问题分解一下。 首先，第一个要点是，必须在任意对象的任意方法前后执行任意的操作，这就要求我们必须拿到对象中的任意方法。要拿到对象的任意方法怎么做呢，反射恰好可以解决你的问题。 第二个要点，不能增加额外的类，换句话说，DriverLogProxy与DriverTimeProxy都不需要增加，怎么办！这个地方不太容易想到，其实我们可以帮助用户生成这样的类，使用Java代码编译并通过ClassLoader将字节码加载到内存中，再通过反射的方式进行调用。这样看起来虽然生成了额外的类，但用户是无法感知的，也就做到了不增加额外类的要求。 接下来，我们先来尝试动态生成针对时间的代理类DriverTimeProxy，这个类的完整代码如下所示： 1234567891011121314public class DriverTimeProxy implements Drivable &#123; private Drivable drivable; public DriverTimeProxy(Drivable drivable) &#123; this.drivable = drivable; &#125; public void drive() throws InterruptedException &#123; long start = System.currentTimeMillis(); drivable.drive(); long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 为了生成这样的代码，我们需要分两步处理： 第一步：将上面的代码当成字符串拼接到变量str中 第二步：使用File类将文件输出到硬盘 以上是我们生成DriverTimeProxy类源码的基本思路，为了简化第一步的处理，这里我们使用JavaPoet来处理。 JavaPoet是什么呢，JavaPoet其实就是一个Java源码生成工具，为了让大家对JavaPoet有一个更直观的了解，我们先来看一段使用JavaPoet编写的代码： 12345678910111213141516MethodSpec main = MethodSpec.methodBuilder("main") .addModifiers(Modifier.PUBLIC, Modifier.STATIC) .returns(void.class) .addParameter(String[].class, "args") .addStatement("$T.out.println($S)", System.class, "Hello, JavaPoet!") .build();TypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld") .addModifiers(Modifier.PUBLIC, Modifier.FINAL) .addMethod(main) .build();JavaFile javaFile = JavaFile.builder("com.example.helloworld", helloWorld) .build();javaFile.writeTo(System.out); 将以上代码复制到main方法中执行，你将得到下面这样的输出结果： 1234567package com.example.helloworld;public final class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello, JavaPoet!"); &#125;&#125; 怎么样，明白了吧。通过使用上面的一段API对Java代码进行描述，JavaPoet就自动帮我们生成了一段非常漂亮的Java代码，连排版都省了，这就是JavaPoet的作用。 Ok，接下来我们增加下面这段代码帮助我们生成DriverTimeProxy： 123456789101112131415161718192021222324252627282930MethodSpec drive = MethodSpec.methodBuilder("drive") .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .addException(InterruptedException.class) .addStatement("long start = $T.currentTimeMillis()", System.class) .addStatement("drivable.drive()") .addStatement("long end = $T.currentTimeMillis()", System.class) .addStatement("$T.out.println(end - start)", System.class) .build();FieldSpec fieldSpec = FieldSpec.builder(Drivable.class, "drivable") .addModifiers(Modifier.PRIVATE) .build();MethodSpec constructor = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(Drivable.class, "drivable") .addStatement("this.$N = $N", "drivable", "drivable") .build();TypeSpec driverTimeProxy = TypeSpec.classBuilder("DriverTimeProxy") .addModifiers(Modifier.PUBLIC) .addSuperinterface(Drivable.class) .addMethod(drive) .addMethod(constructor) .addField(fieldSpec) .build();JavaFile javaFile = JavaFile.builder("com.youngfeng.designmode.proxy", driverTimeProxy).build();javaFile.writeTo(System.out); 在main运行以上代码，你将得到下面这样的结果： 12345678910111213141516171819202122package com.youngfeng.designmode.proxy;import com.youngfeng.designmode.proxy.juhe.Drivable;import java.lang.InterruptedException;import java.lang.Override;import java.lang.System;public class DriverTimeProxy implements Drivable &#123; private Drivable drivable; public DriverTimeProxy(Drivable drivable) &#123; this.drivable = drivable; &#125; @Override public void drive() throws InterruptedException &#123; long start = System.currentTimeMillis(); drivable.drive(); long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125; 这恰好就是DriverTimeProxy类的完整代码。接下来，我们继续尝试第二步，将生成的DriverTimeProxy类动态编译并加载到内存中，同时通过反射的方式创建该对象。为了让大家看的更清晰，我们创建一个新类Proxy并增加一个静态方法newProxyInstance专门用来处理这个问题。 为了实现动态编译，我们需要将文件输出到硬盘中，简单起见，这里我直接将其输出到我的电脑桌面。为了将其编译为Java字节码，我们需要使用JDK自带的工具类JavaCompiler进行处理，这是第一步处理。 第二步处理，通过JavaCompiler编译完成后需要通过ClassLoader将生成的字节码加载到内存中，再通过反射获取DriverTimeProxy实例，其完整的处理流程如下： 12345678910111213141516171819JavaFile javaFile = JavaFile.builder("com.youngfeng.designmode.proxy", driverTimeProxy).build();File sourceFile = new File(PATH);javaFile.writeTo(sourceFile);// 编译生成的Java源码javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null);Iterable iterable = fileManager.getJavaFileObjects(PATH + "/com/youngfeng/designmode/proxy/DriverTimeProxy.java");javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable);task.call();fileManager.close();// 通过反射将源码加载到内存中URL[] urls = new URL[] &#123;new URL("file:" + PATH)&#125;;URLClassLoader classLoader = new URLClassLoader(urls);Class cls = classLoader.loadClass("com.youngfeng.designmode.proxy.DriverTimeProxy");Constructor constr = cls.getConstructor(Drivable.class);Object obj = constr.newInstance(drivable); 结合上面的分析，Proxy类的完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Proxy &#123; // 这里需要修改为你自己期望的源码生成路径 private static String PATH = "/Users/ouyangfeng/Desktop"; public static Object newProxyInstance(Drivable drivable) &#123; try &#123; MethodSpec drive = MethodSpec.methodBuilder("drive") .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .addException(InterruptedException.class) .addStatement("long start = $T.currentTimeMillis()", System.class) .addStatement("drivable.drive()") .addStatement("long end = $T.currentTimeMillis()", System.class) .addStatement("$T.out.println(end - start)", System.class) .build(); FieldSpec fieldSpec = FieldSpec.builder(Drivable.class, "drivable") .addModifiers(Modifier.PRIVATE) .build(); MethodSpec constructor = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(Drivable.class, "drivable") .addStatement("this.$N = $N", "drivable", "drivable") .build(); TypeSpec driverTimeProxy = TypeSpec.classBuilder("DriverTimeProxy") .addModifiers(Modifier.PUBLIC) .addSuperinterface(Drivable.class) .addMethod(drive) .addMethod(constructor) .addField(fieldSpec) .build(); JavaFile javaFile = JavaFile.builder("com.youngfeng.designmode.proxy", driverTimeProxy).build(); File sourceFile = new File(PATH); javaFile.writeTo(sourceFile); // 编译生成的Java源码 javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null); Iterable iterable = fileManager.getJavaFileObjects(PATH + "/com/youngfeng/designmode/proxy/DriverTimeProxy.java"); javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable); task.call(); fileManager.close(); // 通过反射将源码加载到内存中 URL[] urls = new URL[] &#123;new URL("file:" + PATH)&#125;; URLClassLoader classLoader = new URLClassLoader(urls); Class cls = classLoader.loadClass("com.youngfeng.designmode.proxy.DriverTimeProxy"); Constructor constr = cls.getConstructor(Drivable.class); Object obj = constr.newInstance(drivable); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 这里的整个过程相对比较复杂，为了让大家更直观地看到整个过程，我用一张图来描述一下整个过程到底发生了什么。 在上图中，大家可以看到，有三个小助手在帮助我们完成整个过程。他们分别是JavaPoet，帮助生成Java源码文件；JavaCompiler，帮助编译Java源码文件；Reflect（反射)，帮助动态创建DriverTimeProxy实例。 至此，我们终于完成了DriverTimeProxy动态实例的创建，从现在开始，DriverTimeProxy.java的源码文件可以从我们的工程中删除掉了。换句话说，我们完成了前面需求中的其中一个，不需要新增额外的类这个部分。 等等，是否任意实现了Drivable接口的类都可以通过Proxy.newProxyInstance()方法创建代理实例增加日志打印功能呢？ 是的，没错，你已经做到了。因为newProxyInstance的参数是Drivable接口类型，任意实现了该接口的对象都可以作为参数传入进来。 万里长征我们似乎已经走了一大半了。但，还不够！说好的实现任意自定义操作呢，这里只不过是打印日志而已。别急，我们继续往下看。 为了实现任意的自定义操作，我们需要增加进一步抽象。既然操作是任意的，那么这个操作部分就不能由我们做主，应该交给用户。可问题是，到底应该如何只交出自定义操作权限，其它交给Proxy类实现呢。 这里比较容易想到的一个思路是，增加一个统一的接口，接口中只需要包含一个方法，每次调用代理类接口方法的时候都去调用该方法。至于在该方法中到底要做什么，交给用户去处理。 这个思路是完全可行的，我们还是用一张图来描述整个过程。 上图中的InvocatinHandler是计划用来拦截代理类的drive方法调用的。当调用drive方法的时候实际上是调用InvocationHandler的invoke方法。 这样做的好处是什么呢，很明显，我们已经交出了自定义逻辑的主动权，用户可以在invoke方法中实现任意的自定义操作。为了能够实现自定义操作，这里的InvocationHandler也必须是一个接口。 按照这个设计，InvocationHandler实例必须作为参数传入到newInstanceProxy方法中。为了让大家看的更清晰，我们先手动实现新版本的DriverTimeProxy类。 我想，大家首先能够想到的第一个版本应该是这样： 123public interface InvocationHandler &#123; void invoke(Object proxy);&#125; 123456789101112public class DriverTimeProxy implements Drivable &#123; private InvocationHandler invocationHandler; public DriverTimeProxy(InvocationHandler invocationHandler) &#123; this.invocationHandler = invocationHandler; &#125; @Override public void drive() throws InterruptedException &#123; invocationHandler.invoke(this); &#125;&#125; 这样的设计确实存在一些问题，我们先不管，先按照这个设计，使用JavaPoet帮助我们生成这样的代码。这个时候，newProxyInstance应该修改为下面这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static Object newProxyInstance(InvocationHandler handler, Class ints) &#123; try &#123; MethodSpec drive = MethodSpec.methodBuilder("drive") .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .addException(InterruptedException.class) .addStatement("invocationHandler.invoke(this)") .build(); FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, "invocationHandler") .addModifiers(Modifier.PRIVATE) .build(); MethodSpec constructor = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(InvocationHandler.class, "invocationHandler") .addStatement("this.$N = $N", "invocationHandler", "invocationHandler") .build(); TypeSpec driverTimeProxy = TypeSpec.classBuilder("DriverTimeProxy") .addModifiers(Modifier.PUBLIC) .addSuperinterface(ints) .addMethod(drive) .addMethod(constructor) .addField(fieldSpec) .build(); JavaFile javaFile = JavaFile.builder("com.youngfeng.designmode.proxy", driverTimeProxy).build(); File sourceFile = new File(PATH); javaFile.writeTo(sourceFile); // 编译生成的Java源码 javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null); Iterable iterable = fileManager.getJavaFileObjects(PATH + "com/youngfeng/designmode/proxy/DriverTimeProxy.java"); javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable); task.call(); fileManager.close(); // 通过反射将源码加载到内存中 URL[] urls = new URL[] &#123;new URL("file:" + PATH)&#125;; URLClassLoader classLoader = new URLClassLoader(urls); Class cls = classLoader.loadClass("com.youngfeng.designmode.proxy.DriverTimeProxy"); Constructor constr = cls.getConstructor(InvocationHandler.class); Object obj = constr.newInstance(handler); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;&#125; 这里我们的DriverTimeProxy构造函数的参数换成了InvocationHandler实例，Drivable实例参数也就不再需要了，但必须传入代理类需要实现的接口类型。因此，newProxyInstance方法的参数变成了两个：InvocationHandler实例与接口的Class类型。 这个版本的newProxyInstance与上一个版本到底有什么不同呢。这里，我们先来做一个简单的总结。 在这个版本的实现中，我们不再需要传入真正的被代理类实例了。我们也去掉了获取方法执行时间的逻辑，这就意味着我们可以在方法的执行前后添加任意的操作了。 这样说起来可能有点抽象，我们继续回到打印方法时间的问题，在这个版本的实现中，如果要打印方法的执行时间，需要怎么做呢。看下面，我们可以这样做： 1234567891011121314151617181920212223242526272829// 增加自己的InvocationHandler实现类，在类中包含目标代理类Driver实例public class MyInvocationHandler implements InvocationHandler &#123; private Driver target; public MyInvocationHandler(Driver target) &#123; this.target = target; &#125; @Override public void invoke(Object proxy) &#123; long start = System.currentTimeMillis(); try &#123; target.drive(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println(end - start); &#125;&#125;// 运行测试public static void main(String[] args) throws InterruptedException &#123; Driver driver = new Driver(); Object proxy = Proxy.newProxyInstance(new MyInvocationHandler(driver), Drivable.class); ((Drivable)proxy).drive();&#125; 很神奇，是吗？我们最终将自定义逻辑的实现转移到了接口InvocationHandler的实现类中，至于要对方法做日志打印还是统计时间，只需要自己实现即可，例如，如果要打印日志，在invoke方法中，增加日志打印语句即可： 1234567891011121314151617@Overridepublic void invoke(Object proxy) &#123; long start = System.currentTimeMillis(); System.out.println("Drive start..."); try &#123; target.drive(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Drive complete..."); long end = System.currentTimeMillis(); System.out.println(end - start);&#125; 有人说，如果调换日志打印与时间打印的顺序呢，很简单，直接修改invoke方法中的打印顺序即可，逻辑的设计已经完全掌握在了你自己手中，想怎么操作就怎么操作。 至此，经过艰难的长途跋涉，我们终于完全地抛弃掉了DriverTimeProxy与DriverLogProxy两个类，仅需要实现InvocationHandler接口就可以完成各种逻辑的排列组合了。而且，真正的代理类实现对用户来说是完全不可见的，这就是所谓的动态代理。 但，还不够！如果这里我们需要实现另外一个类型的类代理，而这个类中的方法存在参数和返回值的话，这里的设计又出现问题了。为什么呢，看下面的代码： 1234// ICreatorpublic interface ICreator &#123; Person.Builder create(String name);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Person.javapublic class Person &#123; private String name; private int age; private Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public static class Builder &#123; private String name; private int age; public Builder(String name) &#123; this.name = name; &#125; public Builder age(int age) &#123; this.age = age; return this; &#125; public Person build() &#123; return new Person(this.name, this.age); &#125; &#125;&#125; 12345678// BuilderCreatorpublic class BuilderCreator implements ICreator &#123; @Override public Person.Builder create(String name) &#123; return new Person.Builder(name); &#125;&#125; 这里我们增加了三个类，一个接口，这里需要被代理的类是BuilderCreator。 与之前的Drivable接口不同的是，这里的ICreator接口中的方法不仅存在参数，而且还有返回值。那么，问题来了！ 这里暴露出了我们之前设计存在的两个问题： 第一个问题：参数无法传入到InvocationHandler中。 第二个问题：无法获取到目标代理实例方法调用的返回值。 先来看第一个问题，假设我们自己实现了InvocationHandler，代码如下： 12345678910111213public class MyInvocationHandler implements InvocationHandler &#123; private BuilderCreator target; public MyInvocationHandler(BuilderCreator target) &#123; this.target = target; &#125; @Override public void invoke(Object proxy) &#123; // create方法的参数无法获取到，这里将无法被调用 this.target.create(xxx) &#125;&#125; 在上面的代码中，我们发现，当我们对目标代理对象调用create方法的时候，发现create方法的参数无法传入进来了。 怎么办呢！为了保证方法参数可以被传入进来，这里的invoke方法必须再增加一个参数表示外部传入的参数值。由于方法参数可能有多个，这里的参数类型我们用一个对象数组来表示。 这是第一个问题，再来看第二个问题。 由于我们的create方法实际会返回BuilderCreator实例，而在我们的设计中invoke方法是无返回值的。因此，当我们调用代理类的接口方法时，将无法获取到create方法的返回值，也就无法实现后面的调用。因此，为了可以获取到方法的返回值，这里的invoke方法还需要增加一个返回值，类型未知，我们就用Object类型。 按照上面的修正，我们的InvocationHandler接口应该这样设计： 123public interface InvocationHandler &#123; Object invoke(Object proxy, Object[] args);&#125; 按照这样的设计，newProxyInstance方法应该这样修改： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public static Object newProxyInstance(InvocationHandler handler, Class ints) &#123; try &#123; FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, "invocationHandler") .addModifiers(Modifier.PRIVATE) .build(); MethodSpec constructor = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(InvocationHandler.class, "invocationHandler") .addStatement("this.$N = $N", "invocationHandler", "invocationHandler") .build(); TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder("DriverTimeProxy") .addModifiers(Modifier.PUBLIC) .addSuperinterface(ints) .addMethod(constructor) .addField(fieldSpec); // 为了保证灵活性，这里需要遍历接口中的方法，逐一实现 Method[] methods = ints.getMethods(); for (Method method: methods) &#123; MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class); Class[] params = method.getParameterTypes(); String args = params.length &lt;= 0 ? null : "new Object[] &#123;"; for (int i = 0; i &lt; params.length; i++) &#123; Class param = params[i]; methodSpecBuilder.addParameter(ParameterSpec.builder(param, "p" + i).build()); args += "p" + i + ","; &#125; args = args == null ? args : args.substring(0, args.length() - 1) + "&#125;"; Class[] exceptions = method.getExceptionTypes(); for (int i = 0; i &lt; exceptions.length; i++) &#123; methodSpecBuilder.addException(exceptions[i]); &#125; Class returnType = method.getReturnType(); methodSpecBuilder.returns(returnType); // 方法没有返回值的情况下，这里需要额外处理 if (returnType.getName().equals("void")) &#123; methodSpecBuilder.addStatement("this.invocationHandler.invoke(this, " + args + ")"); &#125; else &#123; // 为了保证逻辑的严谨性，这里需要判断实际返回数据类型是否是接口中方法的返回值类型 methodSpecBuilder.addStatement("Object result = this.invocationHandler.invoke(this, " + args + ")") .addCode("if (result instanceof $T) &#123;\n", TypeName.get(method.getReturnType()).box()) .addStatement("\treturn ($T) result", TypeName.get(returnType).box()) .addCode("&#125; else &#123;\n") .addStatement("\treturn ($T) null", TypeName.get(returnType).box()) .addCode("&#125;\n"); &#125; typeSpecBuilder.addMethod(methodSpecBuilder.build()); &#125; JavaFile javaFile = JavaFile.builder("com.youngfeng.designmode.proxy", typeSpecBuilder.build()).build(); File sourceFile = new File(PATH); javaFile.writeTo(sourceFile); // 编译生成的Java源码 javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null); Iterable iterable = fileManager.getJavaFileObjects(PATH + "com/youngfeng/designmode/proxy/DriverTimeProxy.java"); javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable); task.call(); fileManager.close(); // 通过反射将源码加载到内存中 URL[] urls = new URL[] &#123;new URL("file:" + PATH)&#125;; URLClassLoader classLoader = new URLClassLoader(urls); Class cls = classLoader.loadClass("com.youngfeng.designmode.proxy.DriverTimeProxy"); Constructor constr = cls.getConstructor(InvocationHandler.class); Object obj = constr.newInstance(handler); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;&#125; newProxyInstance方法似乎又复杂了许多，为了可以获取到用户传入的参数，我们必须严格匹配参数的命名。因此，这里将参数统一命名为pN。由于每个接口可能有多个方法，这里我们修改为通过遍历的方式获取传入接口的所有方法。同时，为了保证返回值类型与所需类型一致，在代码中，我们增加了类型判断，自动转换到预期的数据类型。 接下来，我们简单测试一下方法是否按照我们预期的情况运行。实现InvocationHandler接口，在main方法中添加如下测试代码，尝试运行，查看结果： 12345678910111213141516171819202122public class MyInvocationHandler implements InvocationHandler &#123; private BuilderCreator target; public MyInvocationHandler(BuilderCreator target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Object[] args) &#123; return this.target.create((String) args[0]); &#125;&#125;public static void main(String[] args) &#123; BuilderCreator builderCreator = new BuilderCreator(); MyInvocationHandler handler = new MyInvocationHandler(builderCreator); Object proxy = Proxy.newProxyInstance(handler, ICreator.class); Person person = ((ICreator)proxy).create("Scott").age(18).build(); System.out.println(person.getAge());&#125; 运行上面的代码，输出结果18，很显然，代码按照预期的结果输出了。 但是，我们还是忽略了一个问题，是什么问题呢，这里先卖个关子，我们先来回顾一下每一次的方法调用过程。 在上面这张流程图中，在第一步调用中，我增加了几个方法，因为一个接口可能存在多个方法。通过newProxyInstance的处理，这些方法的调用最终都会通过调用InvocationHandler的invoke方法来实现间接调用。 所以，这里的invoke方法的调用次数与接口的方法数是一致的。如果某个接口有5个方法，这里就会调用5次。而这个时候，我们之前设计的问题也就出现了。 什么问题呢，通常来说，我们需要针对不同的方法进行不同的处理。而用户在invoke方法中无法知道当前究竟调用的是哪个方法，也就无法在invoke方法中针对不同的方法调用进行不同的处理。 这样说起来还是有点抽象，为了让大家看的更直观，我们在ICreator接口中再增加一个方法foo, 运行，查看生成的代码是什么。 12345public interface ICreator &#123; Person.Builder create(String name); int foo(int x, int y);&#125; 最终动态生成的代码如下： 12345678910111213141516171819202122232425262728293031323334package com.youngfeng.designmode.proxy;import com.youngfeng.designmode.proxy.juhe.InvocationHandler;import java.lang.Integer;import java.lang.Override;import java.lang.String;public class DriverTimeProxy implements ICreator &#123; private InvocationHandler invocationHandler; public DriverTimeProxy(InvocationHandler invocationHandler) &#123; this.invocationHandler = invocationHandler; &#125; @Override public Person.Builder create(String p0) &#123; Object result = this.invocationHandler.invoke(this, new Object[] &#123;p0&#125;); if (result instanceof Person.Builder) &#123; return (Person.Builder) result; &#125; else &#123; return (Person.Builder) null; &#125; &#125; @Override public int foo(int p0, int p1) &#123; Object result = this.invocationHandler.invoke(this, new Object[] &#123;p0,p1&#125;); if (result instanceof Integer) &#123; return (Integer) result; &#125; else &#123; return (Integer) null; &#125; &#125;&#125; 可以看到每次调用实际调用的都是InvocationHandler的invoke方法。这个地方会让用户产生疑惑，究竟调用这个方法是发生在调用create还是foo的时候呢。 为了让大家看的更清晰，我们还是看一眼用户端需要实现的InvocationHandler接口类，已经明白的同学可以跳过这个部分继续往下看： 123456789101112131415public class MyInvocationHandler implements InvocationHandler &#123; private BuilderCreator target; public MyInvocationHandler(BuilderCreator target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Object[] args) &#123; // 这里会让用户产生疑惑，target实际有两个方法，而无论是 // 调用create方法还是foo方法最终都会走这里。 // 如果用户需要对不同的方法进行不同的处理就没法办到了。 return this.target.create((String) args[0]); &#125;&#125; 为了让用户知道这一次的调用究竟是调用哪个方法产生的，invoke方法还需要再增加一个参数，这个参数必须代表当前调用的方法。这里需要用到反射了，我们可以通过反射拿到当前调用方法的Method实例并传入到invoke方法中。 我们摘取其中一个方法create来描述我们大概需要怎么做，看下面这段代码： 12345678910111213141516 @Overridepublic Person.Builder create(String p0) &#123; try &#123; // 这里是计划新增的代码 Method method = Drivable.class.getMethod("create", String.class); Object result = this.invocationHandler.invoke(this, method, new Object[]&#123;p0&#125;); if (result instanceof Person.Builder) &#123; return (Person.Builder) result; &#125; else &#123; return (Person.Builder) null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;&#125; 为了生成上面这样的代码，我们继续改进newProxyInstance方法，改进后的方法如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public static Object newProxyInstance(InvocationHandler handler, Class ints) &#123; try &#123; FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, "invocationHandler") .addModifiers(Modifier.PRIVATE) .build(); MethodSpec constructor = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(InvocationHandler.class, "invocationHandler") .addStatement("this.$N = $N", "invocationHandler", "invocationHandler") .build(); TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder("DriverTimeProxy") .addModifiers(Modifier.PUBLIC) .addSuperinterface(ints) .addMethod(constructor) .addField(fieldSpec); // 为了保证灵活性，这里需要遍历接口中的方法，逐一实现 Method[] methods = ints.getMethods(); for (Method method: methods) &#123; MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class); Class[] params = method.getParameterTypes(); String args = params.length &lt;= 0 ? null : "new Object[] &#123;"; String argTypes = params.length &lt;= 0 ? null : "new Class[] &#123;"; for (int i = 0; i &lt; params.length; i++) &#123; Class param = params[i]; methodSpecBuilder.addParameter(ParameterSpec.builder(param, "p" + i).build()); args += "p" + i + ","; argTypes += TypeName.get(param).box().toString() + ".class,"; &#125; args = args == null ? args : args.substring(0, args.length() - 1) + "&#125;"; argTypes = argTypes == null ? argTypes : argTypes.substring(0, argTypes.length() - 1) + "&#125;"; Class[] exceptions = method.getExceptionTypes(); for (int i = 0; i &lt; exceptions.length; i++) &#123; methodSpecBuilder.addException(exceptions[i]); &#125; Class returnType = method.getReturnType(); methodSpecBuilder.returns(returnType); methodSpecBuilder.beginControlFlow("try"); methodSpecBuilder.addStatement("$T method = getClass().getMethod($S, $N)", Method.class, method.getName(), argTypes); // 方法没有返回值的情况下，这里需要额外处理 if (returnType.getName().equals("void")) &#123; methodSpecBuilder.addStatement("this.invocationHandler.invoke(this, " + args + ")"); &#125; else &#123; // 为了保证逻辑的严谨性，这里需要判断实际返回数据类型是否是接口中方法的返回值类型 methodSpecBuilder.addStatement("Object result = this.invocationHandler.invoke(this, method, " + args + ")") .addCode("if (result instanceof $T) &#123;\n", TypeName.get(method.getReturnType()).box()) .addStatement("\treturn ($T) result", TypeName.get(returnType).box()) .addCode("&#125; else &#123;\n") .addStatement("\treturn ($T) null", TypeName.get(returnType).box()) .addCode("&#125;\n"); &#125; methodSpecBuilder.nextControlFlow("catch ($T e)", Exception.class) .addStatement("e.printStackTrace()") .addStatement("return ($T) null", TypeName.get(returnType).box()) .endControlFlow(); typeSpecBuilder.addMethod(methodSpecBuilder.build()); &#125; JavaFile javaFile = JavaFile.builder("com.youngfeng.designmode.proxy", typeSpecBuilder.build()).build(); File sourceFile = new File(PATH); javaFile.writeTo(sourceFile); // 编译生成的Java源码 javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null); Iterable iterable = fileManager.getJavaFileObjects(PATH + "com/youngfeng/designmode/proxy/DriverTimeProxy.java"); javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable); task.call(); fileManager.close(); // 通过反射将源码加载到内存中 URL[] urls = new URL[] &#123;new URL("file:" + PATH)&#125;; URLClassLoader classLoader = new URLClassLoader(urls); Class cls = classLoader.loadClass("com.youngfeng.designmode.proxy.DriverTimeProxy"); Constructor constr = cls.getConstructor(InvocationHandler.class); Object obj = constr.newInstance(handler); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;&#125; 至此，如果我们需要对不同的方法进行不同的处理，这里就可以通过method参数进行判断了。 我们继续以代理BuilderCreator类为例，如果我们要在create与foo方法前后分别打印当前方法被调用的日志，可以这样做： 12345678910111213141516171819202122public class MyInvocationHandler implements InvocationHandler &#123; private BuilderCreator target; public MyInvocationHandler(BuilderCreator target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) &#123; try &#123; // 通过method.getName()可以获取到方法名 System.out.println(method.getName() + " invoke start..."); Object result = method.invoke(target, args); System.out.println(method.getName() + " invoke end..."); return result; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 到现在为止，我们的动态代理实现基本完整了，我们的旅程也快要结束了。终于，如果我们要在某个类的某个方法前后插入任意的逻辑，不再需要新增额外的类了（InvocationHandler实现类除外），而且添加的逻辑也可以完全自定义了，我们的目标达到了！ 回顾一下我们的整个探索过程，在文章的开篇部分我们从为Driver类的drive方法增加时间打印需求开始，最终选择通过代理的方式进行处理，这样做的灵活性明显高于继承。而为了去掉额外新增的类，我们使用了动态编译的方式在运行期间帮助用户生成相应的代理类。但我们并未满足于此，为了让插入的逻辑也实现自定义，我们又对插入进行了抽象，新增了插入逻辑抽象类InvocationHandler，最终将对Driver类的代理转换到对InvocationHandler实现类的代理中。将方法调用的主动权交给用户（InvocationHandler的实现类处理）。这样，无论是多么复杂的需求，对用户来说，只需要实现InvocationHandler接口增加自定义处理即可，即使某个类有100个方法，他需要的也只是一个InvocationHandler的实现类而已。 等等，我们似乎还忘记了一件事情。一直以来我们生成的动态代理类名称都叫做DriverTimeProxy，而此刻它的功能已经不再仅仅是为Driver类增加时间打印而已了。因此，这里我们将最终生成的代理类名称修改为Proxy$0。最终版本的实现大家可以查看文章的附录部分，点击下方链接前去查看。 动态代理到底有什么用在上面的整个过程中，我们可谓是经历了千难万险，终于完成了一个简易版本的动态代理。那么动态代理到底有什么作用呢。为了让大家直观地感受到，动态代理到底可以做什么，我们先一起来看一个简单的例子。 这里我们创建两个类来简单模拟数据库事务的提交过程（以下代码仅作为演示使用，不具有实际使用价值）： 123public interface TransactionConstr &#123; void commit(int x);&#125; 12345678910111213141516public class Database implements TransactionConstr &#123; public static Database getInstance() &#123; return new Database(); &#125; @Override public void commit(int x) &#123; if (x &lt; 0) throw new IllegalArgumentException(); System.out.println("Transaction commit success..."); &#125; public void rollback() &#123; System.out.println("Transaction rollback..."); &#125;&#125; 为了防止出现脏数据，我们需要在事务提交失败的时候将数据回滚。在没有动态代理之前，我们会这样处理： 1234567891011public static void main(String[] args) &#123; Database db = Database.getInstance(); // 通过try catch的方式手动回滚数据 try &#123; db.commit(-1); &#125; catch (Exception e) &#123; e.printStackTrace(); db.rollback(); &#125;&#125; 而使用动态代理，我们这样做：实现InvocationHandler，代理Database类，在invoke方法中捕获方法可能抛出的异常，一旦发现异常就调用rollback方法自动回滚。 1234567891011121314151617public class AutoRollbackInvocationHandler implements InvocationHandler &#123; private Database target; public AutoRollbackInvocationHandler(Database target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) &#123; try &#123; method.invoke(target, args); &#125; catch (Exception e) &#123; target.rollback(); &#125; return null; &#125;&#125; 这里一定还是会有人说，这两种调用方式貌似没有什么区别啊。第二种写法在每次调用的时候不也需要先使用newProxyInstance生成代理类，然后再调用吗，这样反而麻烦了许多。 其实，这两种方式有一个本质上的区别，前者免不了每次都添加try-catch语句。而后者由于是使用模板化的实现，我们可以在框架层帮助用户自动生成动态代理类，自动添加try-catch语句，这样用户就可以使用非常简单的方式实现事务的自动回滚了。例如，在方法上面添加一个自动回滚的注解，框架层识别注解自动生成代理类实例。这样，你需要的仅仅是一个注解而已了。如果你了解Java后端开发，你应该就知道我在说什么了。 以上是动态代理设计模式的一个经典应用场景，但实际上，动态代理的使用场景还有很多。仔细观察动态代理的执行过程，它似乎为我们开辟了一个新的编程方式。相对于传统的流线型编程方式，动态代理可以在任意已经实现的类中的任意方法中插入自定义的逻辑，就像一把刀一样，将代码的执行过程切成片段，再往里插入自定义的逻辑。至此，计算机的编程方式就变成了cut-insert（切开-插入）的方式进行。这种编程方式，在计算机科学中，被称之为面向切面编程（AOP）。 AOP动态代理是面向切面编程的一种经典实现。在大部分框架中，实现AOP都会使用JDK自带的动态代理处理。当然，JDK的实现其实也有一定的局限性，这就是为什么CGLIB这样的动态代理库大行其道的原因。不过，这不是本文讨论的重点，大家如果对CGLIB感兴趣的话，可以在文章下方给留言。 说回AOP，到底什么是面向切面编程呢？前面其实已经有了一个简单的解释了，为了让大家看的更直观，我们先来看一张图： 以上是面向切面编程框架AspectJ的示例图，AspectJ是一个非常流行面向切面编程Java库。我们就用这张图来给大家讲一下相对于传统编程，面向切面编程到底有什么不同。 图中绿色箭头表示正常代码的执行过程，PointCut表示切入点，即在哪个类的哪些位置插入自定义逻辑。Join Points表示连接点，即具体的插入位置，例如方法调用前，调用后，异常抛出等等。 由此可见，相当于传统的编程模型，AOP的思考点是：找到匹配的切入点，插入自定义逻辑，而且这种插入对原有框架代码是无侵入性的。相对于面向对象编程模型使用继承的方式进行扩展这种侵入性的处理方式，显然是一个巨大的进步。 正是因为AOP具备高度自由、无侵入性的这些特点，才使得它在Spring等知名开源框架中有着大量的应用，而这一切的核心都依赖于AOP最经典的实现方式：动态代理。我想，这应该是动态代理到底有什么用这个问题最好的回答。 JDK实现揭秘实际上，在上面的整个探索过程中，我们都是参照JDK实现来进行讲解的。但还有哪些地方是我们考虑不周的呢，一起来看看JDK实现吧。 打开JavaSE官方文档，找到Proxy与InvocationHandler类。 Proxy.java InvocationHandler 可以看到，JDK版本的newProxyInstance方法中一个有三个参数，第一个参数是ClassLoader，这就意味着我们可以指定自己的类加载器。第二个参数是接口数组，这是因为需要被代理的接口可能不止一个，或者说代理类实现的接口可能不止一个。这是在我们的版本中没有考虑到的一点，实际使用场景中这种情况其实是很常见的。 JDK版本中，InvocationHandler接口的定义与我们的版本是完全一致的。在前一篇文章中，关于这个接口中方法里面几个参数的意思，有不少同学问到，甚至有同学在微信公众号“欧阳锋工作室”给我私信，问到了这个问题。这里统一给大家解答一下： proxy：这个参数表示动态生成的代理类实例，在某些场景中你可能需要对代理实例做一些特殊的处理，这个时候，这个参数的作用就出来了，大多数情况下你不需要用到这个参数。 method：这个参数在前面的文章中其实已经讲过了，它表示实际调用的代理类的接口方法的Method实例，用户可以使用它调用目标代理类的方法。 args：这个参数表示method对应方法传入的参数值，这里可以提供给method方法反射调用，也可以通过直接调用的方式逐一传入参数值到目标代理类方法中。 返回值：invoke方法的返回值，这里也有一些同学问到，这个也是上一篇文章中解释不够到位的地方。这一次我们在前面的例子中详细解释了invoke方法的返回值到底有什么作用。它实际上对应的是被代理类对应method方法的返回值。这是与接口方法一一对应的，方便调用者轻松获取到实际代理类方法调用的返回值。 写在最后最后，感谢大家陪伴我走过了这一段艰难的探索旅程，这的确不太容易。如果你完整地看完了整篇文章，并且根据文章的推进过程同步完成了代码开发，应该给自己鼓个掌。因为，这的确不太容易。Java动态代理设计模式是所有设计模式中最难理解的一个。如果你已经看懂了这个设计模式，其它的设计模式就已经是“除却巫山不是云”了。 希望这篇文章说清楚了前一篇文章大家提的每一个问题，也说清楚了动态代理的每一处细节。如果你还有疑问，欢迎在文章下方给我留言，或者来我的微信公众号“欧阳锋工作室”给我发私信。 附录例子源码：https://github.com/yuanhoujun/java-dynamic-proxy 关注微信公众号”欧阳锋工作室“，阅读更多文章。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入链表数据结构，助你搞定链表算法题]]></title>
    <url>%2F2019%2F11%2F18%2F%E6%B7%B1%E5%85%A5%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A9%E4%BD%A0%E6%90%9E%E5%AE%9A%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在上一篇文章《巧解约瑟夫环问题》中，我们提到了链表。部分同学可能对链表的数据结构还不太熟悉。今天，我们就一起来尝试手写一个链表类实现。然后，再一起来看一看与链表相关的那些算法题。 本篇文章我们依然使用Java语言实现，如果你对其它语言的实现感兴趣，请在微信公众号”欧阳锋工作室“中给我留言 常见的线性链表分为两种：单向链表与双向链表。所谓单向链表，即链表只能通过单向访问，从上一个节点可以访问到下一个节点，而下一个节点不能逆向访问到上一个节点。双向链表则没有这个限制，它既可以从上一个节点访问到下一个节点，也可以从下一个节点访问到上一个节点。 单向链表我们先来尝试实现一个单向链表，一个完整的单向链表数据结构如下图所示： 链表中的每一个元素称之为链表的节点，开始的节点叫做头节点，结束的节点叫做尾节点。 在单向链表中，节点中应该至少包含两个元素：数据（value）以及指向下一个节点的指针（next）。 参照上图，我们先构建节点数据结构： 12345678910// 为了保证通用性，这里我们使用// 泛型参数表示节点数据的数据类型public class Node&lt;E&gt; &#123; public E value; public Node&lt;E&gt; next; public Node(E value) &#123; this.value = value; &#125;&#125; 接下来，我们创建链表集合类，新增主要的增删改查等相关方法： 12345678910111213141516171819202122public class LinkedList&lt;E&gt; &#123; public void add(E e) &#123; &#125; public void remove(E e) &#123; &#125; public void set(int index, E e) &#123; &#125; public E get(int index) &#123; &#125; public int size() &#123; &#125;&#125; 由于是单向链表，这里我们只保存头节点的引用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 单向链表public class LinkedList&lt;E&gt; &#123; private Node&lt;E&gt; head; // 始终指向最新添加的节点 private Node&lt;E&gt; current; private int size; public void add(E e) &#123; Node&lt;E&gt; node = new Node&lt;&gt;(e); // 第一次添加，将头节点指向该元素 if (null == head) &#123; head = node; current = head; &#125; else &#123; current.next = node; current = node; &#125; size ++; &#125; public void remove(E e) &#123; if (null == head) return; // 如果当前元素恰好是头节点，直接将头节点置空 if (e == head.value) &#123; head = null; size --; return; &#125; // 由于我们已知的信息只有头节点，我们必须通过 // 遍历找到对应的节点，这就是为什么说List的查询 // 效率比LinkedList效率高的原因 Node&lt;E&gt; prev = head; Node&lt;E&gt; next = head.next; while (next != null) &#123; if (next.value == e) &#123; prev.next = next.next; size --; // 这里要注意，如果当前节点恰好是被移除的节点 // 需要将当前节点的值指向上一个节点 if (current == next) &#123; current = prev; &#125; break; &#125; prev = next; next = next.next; &#125; &#125; public void set(int index, E e) &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException("Valid index 0 ~ " + (size - 1) + ", current: " + index); &#125; Node&lt;E&gt; current = head; for (int i = 0; i &lt; size; i ++) &#123; if (index == i) &#123; current.value = e; break; &#125; current = current.next; &#125; &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException("Valid index 0 ~ " + (size - 1) + ", current: " + index); &#125; Node&lt;E&gt; current = head; for (int i = 0; i &lt; size; i ++) &#123; if (index == i) &#123; return current.value; &#125; current = current.next; &#125; return null; &#125; public int size() &#123; return size; &#125;&#125; 以上就是单向链表的完整代码了，解题的关键在于你需要在脑海里构建链表的数据结构模型，需要弄清楚节点之间是如何连接在一起的，只要搞清楚了这些关系，问题也就引刃而解了。 按照同样的思路，接下来我们开始尝试实现双向链表。 双向链表与单向链表不一样的地方在于，节点还需要持有上一个节点的引用。对应的数据模型可以用下面的图形来表示: 可以看到，在上面的图形中，我们使用last引用指向上一个节点。同时，增加了一个尾节点引用tail，方便逆向遍历。 按照上面的数据模型，完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 双向链表public class LinkedList&lt;E&gt; &#123; private Node&lt;E&gt; head; private Node&lt;E&gt; tail; private int size; public void add(E e) &#123; Node&lt;E&gt; node = new Node&lt;&gt;(e); if (null == head) &#123; head = node; tail = node; &#125; else &#123; tail.next = node; tail = node; &#125; size ++; &#125; public void remove(E e) &#123; if (null == head) return; // 如果当前元素恰好是头节点，直接将头节点置空 if (e == head.value) &#123; head = null; size --; return; &#125; Node&lt;E&gt; prev = head; Node&lt;E&gt; next = head.next; while (next != null) &#123; if (next.value == e) &#123; prev.next = next.next; size --; // 如果当前节点恰好是尾节点，需要将尾节点上移一位 if (next == tail) &#123; tail = prev; &#125; break; &#125; prev = next; next = next.next; &#125; &#125; public void set(int index, E e) &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException("Valid index 0 ~ " + (size - 1) + ", current: " + index); &#125; Node&lt;E&gt; current = head; for (int i = 0; i &lt; size; i ++) &#123; if (index == i) &#123; current.value = e; break; &#125; current = current.next; &#125; &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IndexOutOfBoundsException("Valid index 0 ~ " + (size - 1) + ", current: " + index); &#125; Node&lt;E&gt; current = head; for (int i = 0; i &lt; size; i ++) &#123; if (index == i) &#123; return current.value; &#125; current = current.next; &#125; return null; &#125; public int size() &#123; return size; &#125;&#125; 在上面的文章中，我们动手编写了单向链表与双向链表的代码实现。接下来，我们一起来看一下与链接相关的那些算法题吧。 问题一：有一个单向链表，如何快速获取链表中倒数第5个元素这个问题可以使用两个指针p1、p2，p2先走5步，指向第6个节点。然后两个指针开始同步出发，一直到p2指向尾节点，p1恰好指向倒数第5个元素。 这个方法可以通过一次循环就获取到倒数第5个元素，时间复杂度最低，完整代码如下： 1234567891011121314151617public void f(Node head) &#123; Node p1 = head; Node p2 = head; int i = 0; while (i &lt; 5) &#123; i ++; p2 = p2.next; &#125; while (p2 != null) &#123; p1 = p1.next; p2 = p2.next; &#125; System.out.println(p1.value);&#125; 问题二：判断一个链表中有环，请给出判断方法这个问题可以使用一个经典的解法“快慢指针”的方式解决。 所谓的“快慢指针”，即同时使用两个指针p1、p2同步前进，p2的速度比p1快。这样就形成了“一快一慢”的效果，因此，我们将其称之为“快慢指针”。“快慢指针”在链表的算法题中起着关键性的作用，常常能够让很多看似复杂的问题简单化。例如，这个问题我们就可以通过“快慢指针”的方式解决。 具体要怎么做呢？我们一起来看一下。 假设有一个如上图所示的单向链表，链表中仅有5个元素，3、4、5形成了一个环。 想象一下，如果我们使用两个指针p1、p2，我们让p1、p2同时出发，但p1每次只向前移动一个节点，而p2每次向前移动两个节点，两者有可能相遇吗？ 在没有环的情况下，很显然一定不会相遇，但在有环的情况下，一定会相遇。因为当两者同时进入链表环中时，如果有一个指针快，一个指针慢，当两者的步数差恰好是一个环的大小时二者就相遇了，这跟时钟的时针和分针一定会相遇是一样的道理。 按照这个思路，判断链表是否有环的完整代码如下： 123456789101112131415public boolean hasRing(Node head) &#123; Node p1 = head; Node p2 = head; while (p2 != null &amp;&amp; p2.next != null) &#123; p1 = p1.next; p2 = p2.next.next; if (p1 == p2) &#123; return true; &#125; &#125; return false;&#125; 由此可见，“快慢指针”的确是一个非常有效的解决方案，在上述两个问题的解答中就起到了决定性的作用。大家一定要牢记这个解决方案，以便面试官问到相关的问题的时候能够迅速脱口而出。 问题三：假设一个链表中存在环，请求出环的大小问题二中我们可以知道一个链表中是否存在环，但如何知道这个环的大小呢。 我们继续回想时针与分针相遇的原理，分针比时针快，从第一次相遇开始，分针走的快，继续往前走，为了再次追上时针，分针应该至少多走一圈。因此，第二次相遇时分针和时针所在的距离差恰好就是环的大小。 按照这个原理，获取链表环大小的完整代码如下： 1234567891011121314151617181920212223242526272829public int getRingSize(Node head) &#123; Node p1 = head; Node p2 = head; int size = 0; int index = 0; // 标记是否已经出现第一次相遇 int hasMeeted = false; while (p2 != null &amp;&amp; p2.next != null) &#123; p1 = p1.next; p2 = p2.next.next; if (hasMeeted) &#123; size += 1; &#125; if (p1 == p2) &#123; // 再次相遇发现hasMeeted为true // 表示已经是第二次相遇了，直接跳出循环 if (hasMeeted) &#123; break; &#125; hasMeeted = true; &#125; &#125; return size;&#125; 问题四：有一个单向链表，请从尾到头打印该链表数据从尾到头打印链表有点像栈的数据结构模型。因此，这里我们可以使用一个栈去保存链表中的所有节点，然后pop栈顶元素，打印即可。但这不仅增加了一定的空间复杂度，也增加了一定的时间复杂度。 这个问题无非就是打印链表中的值而已，如果我们能够按照栈调用的方式对其进行调用，问题不就迎刃而解了吗。 递归恰好就是一个栈调用的方式，因此，我们完全可以使用递归巧妙地解决这个问题。 以下是使用递归调用反向打印链表数据的完整代码： 12345678public void printReverse(Node node) &#123; if (node != null) &#123; printReverse(node.next); System.out.println(node.value); &#125; else &#123; return; &#125;&#125; 问题五：有一个单向链表，求链表的中间节点这个问题初看起来似乎有点眼熟，是的，没错！它跟问题一比较像。在问题一中我们需要找到倒数第5个节点，而在这个问题中，我们需要找到链表的中间节点。 但这个问题的难点在于如何保证其中较慢的指针恰好停留在中间节点的位置。 其实，这很简单，我们依然可以使用“快慢指针”的方式进行处理。只要设置快指针每次走两步，而慢指针每次走一步即可。完整代码如下： 123456789101112public void findMidNode(Node head) &#123; Node p1 = head; Node p2 = head; while (p2 != null &amp;&amp; p2.next != null) &#123; p1 = p1.next; p2 = p2.next.next; &#125; // 这里的p1节点恰好就是中间节点 System.out.println(p1.value);&#125; 问题六：反转链表示例： 121-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 按照正常思维，反转链表，我们需要将链表的值先保存起来，然后再构建新的链表，再逐一连接起来。 但实际上，上面的动作其实我们可以同步进行，具体思路如下： 1）声明变量prev、curr分别指向前一个节点、当前遍历节点。 2）如果当前节点不为空，则先设置临时变量next指向curr的下一个节点。 3）让curr的下一个节点指向pre，然后再让pre指向当前节点curr, 最后让当前节点curr指向next。 4）重复以上过程，判断条件是当前节点curr不为空。 完整代码如下： 123456789101112public void reverseLink(Node head) &#123; Node prev = null; Node curr = head; while (null != curr) &#123; Node next = curr.next; curr.next = prev; prev = curr; curr = next; &#125;&#125; 问题七：如果链表中存在环，求环的入口节点这道题似乎依然可以用“快慢指针”的方式解决，但问题是：如何让指针相遇的点恰好落在环的入口处呢，这似乎是一个难题。 我们继续沿用问题二中的图： 在问题二中我们使用了两个指针p1、p2，p1每次前进一步，p2每次前进两步，如果两者相遇，则说明链表中有环。 上图中整个链表只有5个元素，链表的入口节点是3，p1、p2指针第一次相遇的节点位置是4。在这个位置，p2所走的距离恰好比p1多出一个环的距离。 这是按照问题二中的设计思路推算出来的相遇节点，接下来我们的难点是尝试找到一种方法让指针恰好在入口位置处相遇。 这里我们假设： 1）头节点距离入口节点的节点数是a 2）指针第一次相遇的位置距离入口节点的节点数是b 3）相遇位置节点走到入口节点的节点数是x 4）环的节点数是r 如果p1指针走过的距离是s，那么p2指针走过的距离应该是2s（p2指针的速度是p1的两倍）。观察上图，我们得到如下的等式： 12s = a + b2s = a + b + r 等式二减去等式一得到s = r。 由此我们可以知道，第一次相遇的时候，指针p1恰好走过了一个环的距离。 继续观察上图，可以得到r = b + x。 由此我们得到几种非常重要的公式： 123s = a + bs = rr = b + x 结合上述三个等式，去掉b、s，最终得到： 1x = a 这说明一个问题：从相遇节点到入口节点的距离与开始节点到入口节点的距离是相等的。 所以，如果我们在指针相遇后，让p2指针重新回到头节点，并且每次只前进一步。那么，当两个指针再次相遇的时候，其节点恰好就是入口节点。 以上的推导可能有点绕，如果你还不能理解，请在微信公众号“欧阳锋工作室”给我留言。 知道了原理之后，代码就简单了。以下是上述思路的完整代码实现： 1234567891011121314151617181920212223242526272829public Node getRingEntryNode(Node head) &#123; Node p1 = head; Node p2 = head; while (p2 != null &amp;&amp; p2.next != null) &#123; p1 = p1.next; p2 = p2.next.next; if (p1 == p2) &#123; break; &#125; &#125; // 第一相遇后，我们让p2节点重新指向头节点 p2 = head; // 再次进入循环，直到二者再次相遇 while (p1 != null) &#123; p1 = p1.next; p2 = p2.next; // 两者再次相遇，相遇节点即是环 // 的入口节点 if (p1 == p2) &#123; return p1; &#125; &#125; return null;&#125; 问题八：有两个有序链表，请将他们合并为一个链表，同时保证链表有序示例： 12345输入：1-&gt;3-&gt;52-&gt;3-&gt;6输出：1-&gt;2-&gt;3-&gt;3-&gt;5-&gt;6 这道题完全可以使用循环的方式处理，先取出两个链表中的第一个元素，取第一个元素较小的值放在表头，并且将该链表作为目标链表。逐一对比，拼接到链表指定位置，直到某个链表为空。如果被对比链表更长，则将剩余部分的元素直接连接到目标链表即可。 这是一种常规的解法，事实上，这道题还可以使用递归的方式进行处理。实现的思路与循环类似，只是代码层面更容易理解，且代码量更少，其完整实现如下： 12345678910111213141516171819public Node mergeOrderedLink(Node head1, Node head2) &#123; // 先判断存在空链表的情况 if (null == head1) &#123; return head2 &#125; else if (null == head2) &#123; return head1 &#125; else &#123; Node newHead = null; if (head1.data &lt; head2.data) &#123; newHead = head1; newHead.next = mergeOrderedLink(head1.next, head2); &#125; else &#123; newHead = head2; newHead.next = newHead.next = mergeOrderedLink(head1, head2.next); &#125; return newHead; &#125;&#125; 压轴题以上就是我们在面试中可能会遇到的常见的八道链表算法面试题。最后，我给大家准备了一道压轴题，大家尝试做一下。获取答案，可以在微信公众号“欧阳锋工作室”中回复“链表”获得。 问题九：有一个单向链表，你无法获取到这个链表的头节点，在链表中存在四个连续节点A、B、C、D四个节点，已知B节点，如何将其从链表中删除掉阅读更多文章，请关注公众号“欧阳锋工作室”]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧解约瑟夫环问题]]></title>
    <url>%2F2019%2F11%2F17%2F%E5%B7%A7%E8%A7%A3%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[100个小孩手拉手围成一圈，从第1个小孩开始报数，数到3出列，下一个小孩继续从1开始报数，循环报数，求最后留在队列中的小孩的位置。 这是一道非常经典的算法题，我在面试的时候经常提到这道题。这道题是完全可以通过正向思维解答的，但遗憾的是，在所有面试的人中，几乎没有一个人可以正确地解答这道题。 那么，到底要如何解答这道题呢，我们一起来试试看！ 解法一：生死看淡，不服就干首先，我们尝试用正向思维解答，我们用一个集合模拟100个人，集合中的值记录的是原来队列中人物的索引（从0开始）。为了保证函数的通用性，我们用n表示队列中的人数，m表示出列的位置： 本篇文章我们使用Java语言进行讲解，如果你想看其它语言的实现，请在微信公众号”欧阳锋工作室“给我留言 12345678910111213141516171819202122232425262728293031323334public static int f(int n, int m) &#123; // 这里用一个集合模拟队列 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i ++) &#123; list.add(i); &#125; // 计数器，记录报数序号 int count = 0; // 当前循环的队列位置索引 int index = 0; while (list.size() &gt; 1) &#123; count ++; // 这里还要注意一个问题，如果报数来到了队列尾部，我们需要从第一个人继续往下报数 // 因此这里的索引计数器需要归0 if (index &gt;= list.size()) &#123; index = 0; &#125; // 接下来开始循环报数，将序号为m的人移出队列 if (count &gt;= m) &#123; // 移出队列，同时计数器归0 list.remove(index); count = 0; &#125; index ++; &#125; return list.get(0);&#125; 以上这种解法是最容易被想到的方法，问题是：这样做正确吗？ 很显然不对！这里忽略了一个问题，一旦队列中有人被移出队列，队列的索引就会发生变化。举个例子，假设第3个人被移除，正常来说，下一个人的索引应该是4。而实际上，这个人的索引依然是3，因为索引计数是连续的。被移除的人索引也会消失，后面所有人的索引都会往前移动一位。 这是上述解法最容易出现的问题，知道了问题的根源，我们将代码继续改进。 我们在上述代码的第28行后面增加一行代码，人物出列后主动将索引值减一： 12345678// 接下来开始循环报数，将序号为m的人移出队列if (count &gt;= m) &#123; // 移出队列，同时计数器归0 list.remove(index); count = 0; // 这里的索引要减1 index --;&#125; 修改后，我们尝试运行以上代码，将100与3的值传入到函数中，运行得到结果90，答案是正确的。 解法二：死生不惧，一往直前直给的解题方式，除了上述解法之外，还有一种常见的解法，就是不管三七二十一，一路循环，直至输出结果。 这种解法同样需要构建用户队列，只是队列的形式发生了变化，我们使用一个长度为n的Boolean数组构建用户队列。 这种解法的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public static int f(int n, int m) &#123; Boolean[] arr = new Boolean[n]; for (int i = 0; i &lt; arr.length; i ++) &#123; arr[i] = true; &#125; // 队列中还剩余的人数 int leftCount = arr.length; // 计数器，记录报数序号 int count = 0; // 当前循环的队列位置索引 int index = 0; while (leftCount &gt; 1) &#123; if (arr[index]) &#123; count++; &#125; if (count == m) &#123; arr[index] = false; count = 0; leftCount --; &#125; index ++; // 这里同样需要处理计数到达队列尾部的情况 if (index &gt;= n) &#123; index = 0; &#125; &#125; int result = 0; for (int i = 0; i &lt; arr.length; i ++) &#123; if (arr[i]) &#123; result = i; break; &#125; &#125; return result;&#125; 这种解法相对于第一种解法来说，时间复杂度更高，循环次数更多，循环次数差不多是第一种解法的3到5倍，甚至更多。但相对第一种解法，这种解法更容易被人接受，也无需考虑索引的变化。在面试中，如果你想不到任何一种解法，我推荐你使用这种解法。 解法三：巧用链表，场景还原分析考题，我们不难发现，这似乎是我们非常熟悉的链表结构。在第三种解法中，我们尝试使用链表模拟这个用户队列，看看能否带给我们一些惊喜。 由于始终使用单向报数，我们就用一个单向链表来模拟这个数据结构： 12345678910// 这里用Child类来模拟每一个参与的小孩，其中的value值保存的是当前用户的索引public class Child &#123; // 简单起见，这里我们全部使用public public Child next; public int value; public Child(int value) &#123; this.value = value; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public static int f(int n, int m) &#123; Child head = new Child(0); Child current = head; for (int i = 1; i &lt; n; i ++) &#123; Child child = new Child(i); current.next = child; current = child; &#125; // 为了构建首尾相接的链表，这里我们主动将尾节点与头结点连接起来 // 当前节点恰好指向尾节点 current.next = head; // 接下来再移动一次指针，让current指向头节点 // 为了方便获取前一个节点，这里我们用一个变量表示前一个节点 Child prev = current; current = current.next; // 定义计数器 int count = 0; // 一旦收尾相接，当前节点指向了自身，证明队列中只有一个用户了，跳出循环，游戏结束 while (current.next != current) &#123; count ++; if (count == m) &#123; prev.next = current.next; count = 0; &#125; prev = current; current = current.next; &#125; return current.value;&#125; 以上就是这种解法的完整代码，代码中包含了每一行代码的详细解释。在这个解法中，我们利用链表模拟了人物队列，通过控制当前用户的指针移动来模拟报数。最终，当用户的下一个用户指针指向自己的时候跳出循环，游戏结束，当前用户就是队列中剩余的最后一个用户。 这种解法相对于上面两种解法来说更容易理解，并且这种解法的时间复杂度不高，循环次数与第一个解法的循环次数一致。目前来说，他是在所有的解法中是最优的。 那么，是否还有更好的解法呢？ 解法四：数学大法，九九归一计算机科学离不开数学！最后，我们一起来试试看，尝试利用数学的武器更加巧妙地解决这个问题。由于这是一个规律性的动作，我们可以肯定，这应该有一个固定的数学规律。 但现在的问题是，如何找到这个规律呢？这似乎不太容易。 这里我们先假设总人数为n，报数为m的人出列，用f(n, m)表示最终留在队列中的人的位置。 为了便于大家理解，我们先来看一个实际的例子，假设n=5, m=3, 即队列中只有5个人，报数为3的人出列。 123456789101112第一轮报数，位置为3的人出列[1, 2, x, 4, 5]出列后，从4开始报数，我们将开始报数的人挪到第一位，剩下的人按照报数的顺序往后排，得到一个新的队列：[4, 5, 1, 2]从这里，我们开始第二轮报数，这一轮报数位置为1的人出列[4, 5, x, 2]我们继续按照上面的方式，转换队列，重新第三轮报数：[2, 4, 5] =&gt; [2, 4, x]第四轮：[2, 4] =&gt; [x, 4]第五轮：[4] 以上就是n = 5, m = 3的情况下完整的报数情况，接下来我们仅关注第一次报数发生的变化。 第一轮报数完成后，队列由[1, 2, 3, 4, 5]转换成了[4, 5, 2, 1]。 队列一：[1, 2, 3, 4, 5] 队列二：[4, 5, 1, 2] 注意看，如果我们不去关注队列中人物的位置，仅关注队列本身。这两个队列有什么关系？ 两个队列都是从1开始报数 两个队列人数仅仅相差1 这里很微妙，这其实可以看做数量为5的人物队列，与数量为4的人物队列。如果我们用Q表示队列的话，第一个队列可以用Q(5)表示，第二个队列可以用Q(4)来表示，Q(4)实际上是Q(5)的子队列。 在这两个队列中，还有两个干扰项 [1, 2], 为了排除干扰，我们将他们改成 [6, 7], 即： 队列一：[1, 2, 3, 4, 5] 队列二：[4, 5, 6, 7] 这个时候队列Q(5)与Q(4)产生了一定的关系，同等位置处的索引值恰好相差3（其实就是m的值，为什么是m呢？大家可以自行思考一下）。 接下来，我们关注第二个队列的第一轮报数，报数为3的人出列，也就是队列二中的6。那么，TA在原来队列中的位置到底是什么呢？答案是1，实际就是将6 % 5进行取模得到的值。 这里似乎有一个固定的规律，即：假设队列2第一轮报数出列的人在队列2中的位置是x2, 在队列1中的位置是x1, x2与x1应该存在下面这个关系： 1x1 = (x2 + 3) % 5 第一轮报数等式成立，那么第二轮报数是否成立呢？一直到剩余最后一个人是否成立呢？答案是：当然成立。 由此，我们可以猜测f(n, m)与f(n, m - 1)存在下面这样的关系： 1f(n, m) = (f(n - 1, m) + m) % n 为了加深大家的理解，我们将转换过程用图片再一次展示给大家看： 以上就是队列长度为n，第一次报数为m的用户出列后将n-1的其他人转换到n-1的子队列的过程。 由此可以得出结论，这里的转换是普适的，以上的公式适用于所有情况。 上述公式中，我们没有考虑当前队列中只有一个人的情况，这里我们将其补全，得到下面的递推公式： 12f(n, m) = 0 (n = 1)f(n, m) = (f(n - 1, m) + m) % n (n &gt; 1) 得到上述递推公式之后，问题就变得简单了： 1234public static int f(int n, int m) &#123; if (n == 1) return 0; return (f(n - 1, m) + m) % n;&#125; 换成三目运算符，我们甚至可以使用一行代码解答这个问题： 123public static int f(int n, int m) &#123; return n == 1 ? 0 : (f3(n - 1, m) + m) % n;&#125; 最佳实践以上就是”约瑟夫环问题“的常见几种解法，算法效率最高的解法是第四种，其次是第一种与第三种，第二种解法效率最差，但最容易想到。尽管通过数学归纳法可以最高效地解答这个问题，但我仍然推荐第三种解法，这种解法最符合计算机思维。同时，算法复杂度也不高。但如果在高度要求性能的程序中，当然毫无疑问，解法四是你的最优选择。 总结在这个问题解答的过程中，我们用到了链表，链表是一种非常常见的数据结构。可能你经常在用，但并不了解。链表问题经常出现在算法中，如果你希望对链表进一步深入了解，请关注公众号”欧阳锋工作室“，下一篇文章我们讲一讲与链表相关的那些算法题。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>约瑟夫环</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Kotlin语言独有的位置注解，让注解控制更精准]]></title>
    <url>%2F2019%2F11%2F15%2F%E7%90%86%E8%A7%A3Kotlin%E8%AF%AD%E8%A8%80%E7%8B%AC%E6%9C%89%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E8%A7%A3%EF%BC%8C%E8%AE%A9%E6%B3%A8%E8%A7%A3%E6%8E%A7%E5%88%B6%E6%9B%B4%E7%B2%BE%E5%87%86%2F</url>
    <content type="text"><![CDATA[在Kotlin语言编写的代码中，你应该看到过类似这样的注解@file:JvmName(...)，这有点难以理解，正常的注解不会存在类似@file:这样的前缀，在Java语言中也没有类似的语法。那么，这到底有什么作用呢？ 由于其特殊的作用，我把它称之为”位置注解“。 Kotlin语言是一门将语法简化到极致的编程语言，我们一起来看一段简单的代码： 123class Person &#123; var name: String? = null&#125; 这段极其简单的代码，经过Kotlin编译器的处理，等价于下面这段Java代码： 12345678910111213public final class Person &#123; @Nullable private String name; @Nullable public final String getName() &#123; return this.name; &#125; public final void setName(@Nullable String var1) &#123; this.name = var1; &#125;&#125; 虽然在Kotlin语言中，看起来只是声明了一个成员变量，实际上编译后不仅声明了一个成员变量name，还生成了与之对应的setter/getter方法。 这个时候，问题来了，如果我们在Person类的name属性上方添加一个注解，会出现什么问题呢？ 1234class Person &#123; @Callable var name: String? = null&#125; 我们刚才说到，实际生成的字节码中包含了setter/getter方法，那么这个注解可能出现的位置就有4个地方： 属性（成员变量name） setter方法 setter方法参数name getter方法 用代码来表示，具体可能出现的位置如下图所示： 12345678910111213141516171819public final class Person &#123; // 位置一：属性 @Callable @Nullable private String name; // 位置二：setter方法 @Callable public final void setName(/*位置三：setter方法参数*/ @Nullable String var1) &#123; this.name = var1; &#125; // 位置四：getter方法 @Callable @Nullable public final String getName() &#123; return this.name; &#125;&#125; 这个时候编译器晕菜了，它无法确定你到底想要让注解出现在什么位置。那么，这种情况下，Kotlin编译器究竟会怎么做呢？感兴趣的同学不妨自己做做实验。 那么，是否有办法使注解准确地出现在指定位置呢？答案是：当然有！位置注解恰好就是用来解决这个问题的。 我们将上面的代码添加位置注解，修改为下面这样： 1234class Person &#123; @field:Callable var name: String? = null&#125; 通过添加位置注解@field， @Callable注解将准确出现在属性定义的位置，如下所示： 123456789101112131415public final class Person &#123; // 注解将出现在这里 @Callable @Nullable private String name; public final void setName(@Nullable String var1) &#123; this.name = var1; &#125; @Nullable public final String getName() &#123; return this.name; &#125;&#125; 对应上述其它三个位置的位置注解分别是： set: 对应setter方法位置 get：对应getter方法位置 setparam：对应setter方法参数位置 除此之外，Kotlin还提供了以下几个位置注解，对应其它不同使用场景： @file:这个注解用在文件级别，每一个Kotlin文件对应一个或多个Java类，当对应一个类的时候，可通过添加该位置注解，结合上一节课讲到的注解@JvmName一起使用，可改变生成的Java类名。 你可以理解为这个注解实际作用的位置就是最终编译生成的Java类。 1234@file:JvmName("FooKt")fun foo() &#123; println("Hello, world...")&#125; 最终生成的代码类似下面这样，生成的类名恰好是注解上方所填写的名称： 123456@JvmName("FooKt")public final class FooKt &#123; public final void foo() &#123; ... &#125;&#125; @param:这个注解的作用是使注解出现的位置定位到构造函数的参数上面。 大家知道，在Kotlin语言中，如果在构造函数参数前面添加var或val关键词，在对应类中会生成相应的属性、setter、getter方法。 为了让注解准确地出现在其构造函数参数的位置，这个注解就应运而生了！ 我们继续来看一个例子： 1class Person(@param:Callable var name: String) 添加上述位置注解后，最终生成的注解就会出现在构造函数参数的位置，如下所示： 12345678910111213141516171819public final class Person &#123; @NotNull private String name; @NotNull public final String getName() &#123; return this.name; &#125; public final void setName(@NotNull String var1) &#123; this.name = var1; &#125; // 注解最终出现在了这里 public Person(@Callable @NotNull String name) &#123; super(); this.name = name; &#125;&#125; @property:这是一个特殊的位置注解，这个注解对于Java端是不可见的，其代表的位置是对应属性的Property对象。这样说起来有点抽象，我们来看一个例子，先来了解一下Property到底是什么东西。 我们继续以Person类为例，通过下面一段代码去访问它： 1234567fun main(args: Array&lt;String&gt;) &#123; val person = Person("Scott") val propertyName = person::name // 这里将打印 name: falsee println("$&#123;propertyName.name&#125;: $&#123;propertyName.isConst&#125;")&#125; 上述代码中，propertyName对应的就是Person类中name属性的Property实例，简单来说就是，Property保存了对应属性的相关信息，代表了当前属性。通过Property可以获取到当前属性的相关信息（包括变量的名称，是否常量，是否延迟初始化等等）。 如果在构造函数的name前面添加位置注解@property:，注解生成的位置会稍微有点难以理解。访问这个注解的唯一方法就是通过其Property实例，我们一起来试一下： 1class Person(@property:Callable var name: String) 访问该注解的唯一方式是通过其Property实例，并且Java端无法访问到： 1234567fun main(args: Array&lt;String&gt;) &#123; val person = Person("Scott") val propertyName = person::name // 访问该注解的唯一方式 println(propertyName.annotations.find &#123; it.annotationClass == Callable::class &#125;)&#125; 那么，具体到字节码，该注解到底出现在了哪里呢？我们不妨来反编译看一看： 1234567891011121314151617181920212223public final class Person &#123; @NotNull private String name; // 注解出现在了这里，非常特殊的一个位置 @Callable public static void name$annotations() &#123; &#125; @NotNull public final String getName() &#123; return this.name; &#125; public final void setName(@NotNull String var1) &#123; this.name = var1; &#125; public Person(@NotNull String name) &#123; super(); this.name = name; &#125;&#125; 可以看到注解出现在了Kotlin编译器生成的一个以属性名称加$与annotations后缀作为方法命名的静态方法上。这是Kotlin编译器约定的一个特殊方法，通过Property实例可以准确访问到这里。 而知道了这个约定命名方式之后，事实上Java端也可以通过特殊的方式来访问到该注解，严格来讲，Java无法访问并不准确。 @receiver：这也是一个非常特殊的位置注解，Kotlin支持扩展函数，即在不通过继承的情况下对原有类扩展函数或属性。扩展中有一个很重要的概念就是receiver，所谓的receiver，就是指被扩展类的实例本身。 但问题来了，扩展并不会改变原有类的代码，如何将注解放到receiver位置呢，这似乎是一个不可能完成的事情。 这就要说到扩展的实现原理了，扩展实际上对应Kotlin中的一个全局函数，当转换到字节码的时候，函数的第一个参数就是receiver本身。这样说起来可能比较抽象，我们直接来看一个例子： 我们先对Person类增加扩展函数sayHi: 123fun Person.sayHi(greet: String) &#123; println("$greet, $name")&#125; 然后反编译查看最终得到的Java代码： 1234public static final void sayHi(@NotNull Person $receiver, @NotNull String greet) &#123; String var2 = greet + ", " + $receiver.getName(); System.out.println(var2);&#125; 可以看到Kotlin编译器生成了一个静态方法，静态方法的第一个参数就是receiver，对应扩展类实例本身，第二个参数是扩展函数实际的参数。 这就是Kotlin扩展的实现原理，其最终是通过增加静态函数来实现的，扩展函数的第一个参数永远指向被扩展类的实例，即receiver。而我们添加了位置注解@receiver之后，注解生成的位置就会出现在扩展函数第一个参数的位置，类似下面这样： 1234public static final void sayHi(@Callable @NotNull Person $receiver, @NotNull String greet) &#123; String var2 = greet + ", " + $receiver.getName(); System.out.println(var2);&#125; 这就是@receiver位置注解的作用，理解了扩展函数的原理，这个注解的作用就不难理解了。 @delegate这是今天我们要说的最后一个位置注解，这又是一个相对比较难理解的位置注解，因为在Java语言中并不存在类似的概念。在Kotlin语言中代理模式大行其道，Kotlin语言使用by关键字就可以轻松实现代理模式。 这里存在一个同样的问题，前面我们说过，在Kotlin类中声明一个属性实际会同时生成setter/getter方法，这样注解可能出现的位置除属性之外就是三处（setter/getter/setter参数)。而如果属性本身使用代理的方式生成，这里就多了一个位置：代理类属性的位置。 这样说，可能还不太直观，我们用官方的lazy实现来举一个例子。 我们在Person类中增加一个代理属性gender： 1234class Person(var name: String) &#123; @delegate:Callable val gender by lazy &#123; "male" &#125;&#125; 老规矩，我们还是直接反编译得到Java代码再来分析： 12345678910111213141516171819public final class Person &#123; // 注解出现在了这个位置 // 也就是真正的代理类实例的位置 @Callable @NotNull private final Lazy gender$delegate; @NotNull public final String getGender() &#123; Lazy var1 = this.gender$delegate; return (String)var1.getValue(); &#125; public Person(@NotNull String name) &#123; super(); this.name = name; this.gender$delegate = LazyKt.lazy((Function0)null.INSTANCE); &#125;&#125; 通过上面的代码，我们可以清晰地看到Kotlin编译器在类中生成真正的代理类实例属性，gender的值实际是从代理对象中获取的。这个位置注解的作用就是将注解精确地放置到代理类的实例属性上方。 默认位置注解优先级位置注解在Kotlin语言中并不是强制要求的，我们可以不添加位置注解，在未添加位置注解的情况下，Kotlin语言会按照下面的优先级将注解放置到指定的位置（如果注解可以同时出现在多个位置的话）： param &gt; property &gt; field 最佳实践以上就是Kotlin语言中我们可以用到的所有位置注解，这是因为Kotlin语言将语法简化到了极致，我们才需要这些注解精确地告诉编译器需要将注解放置到哪里。如果你需要在代码中添加注解，应该始终记得增加位置注解，以便注解可以精确地放置到你想要放置的位置，避免出现一些不必要的麻烦。 阅读更多技术文章，请关注微信公众号”欧阳锋工作室“ 参与Kotlin技术讨论，请添加唯一官方QQ交流群：329673958]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正确使用Kotlin注解，兼容Java代码]]></title>
    <url>%2F2019%2F11%2F12%2F%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8Kotlin%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%85%BC%E5%AE%B9Java%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[大多数情况下，你不需要关注这个问题。但是，如果你的代码中包含了部分Java代码，理解这些注解将帮助你解决很多棘手问题。 产生这个问题的根本原因在于：Kotlin语言与Java语言的设计思路不同，部分特性属于Java语言独有，例如静态变量。部分特性属于Kotlin语言独有，例如逆变和协变。 为了抹平这些差异，Kotlin语言提供了一个绝佳的思路，通过添加注解可以改变Kotlin编译器生成的Java字节码，使之按照Java语言可以理解的方向进行，从而实现兼容。 问题答疑：Kotlin语言与Java字节码有什么关系？为什么Kotlin编译器会生成Java字节码？ 不管是Kotlin语言还是Java语言都是建立在JVM平台上面的编程语言，其最终都需要编译成JVM可以识别的Java字节码才能被正确执行。这也是为什么Kotlin语言与Java可以完全互通的原因之一，不要将Java与Java平台混为一谈。 接下来我们看第一个注解，也是最常见的注解 @JvmFieldKotlin编译器默认会将类中声明的成员变量编译成私有变量，Java语言要访问该变量必须通过其生成的getter方法。而使用上面的注解可以向Java暴露该变量，即使其访问变为公开（修饰符变为public)。 我们来做一个实验： @JvmFieldKotlinJava1234class Person { @JvmField var name: String? = null}123456789public class Client { public static void main(String[] args) { Person p = new Person(); // 在添加@JvmField注解之前，这样访问会报错 // 只能通过p.getName()的方式进行访问 String name = p.name; }} 在Person类中我们定义了一个成员变量name，在添加@JvmField属性前我们试图通过p.name的方式进行访问，编译器会报错。因为，默认生成的成员变量name是私有的。而添加该注解之后我们却可以正常访问了。 由此可见，@JvmField注解的确使生成的字节码发生了变化，我们将字节码用Java语言的形式表示，具体发生的变化类似下面的代码展示： 添加@JvmField注解的变化beforeafter1234567891011public final class Person { private String name; public final String getName() { return this.name; } public final void setName(@Nullable String var1) { this.name = var1; }}123public final class Person { public String name;} 注：before与after分别为添加注解前与添加之后 以上场景是将@JvmField注解添加到普通变量上方，如果添加到伴随对象的成员变量上方，会发生什么呢？我们来试试看： 添加到伴随对象KotlinJava12345678class Person { var name: String? = null companion object { @JvmField val GENDER_MALE = 1 }}1234567public static void main(String[] args) { // 未添加之前 // int gender = Person.Companion.getGENDER_MALE(); // 添加之后，可直接访问 int gender = Person.GENDER_MALE; System.out.println(gender);} 同样地，添加注解之后我们可以通过点语法直接对其进行访问。 由此可见，@JvmField注解会使伴随对象在伴生类中生成静态成员变量，通过伴生类类名可直接对其进行访问。 结论@JvmField注解可改变字节码的生成，其作用的目标是类成员变量或伴随对象成员变量。作用在类成员中可使该变量对外暴露，通过点语法直接访问。即将私有成员变量公有化（public），并去掉setter/getter方法。作用在伴随对象成员变量中，可以使该伴随对象中的变量生成在伴生对象中，成为伴生对象的公有静态成员变量，通过伴生类可直接访问。 那么问题来了，如果该注解作用在私有成员变量上方会发生什么呢？请大家自行做实验验证。 @JvmStatic这个注解与@JvmField非常容易出现混淆，两者都可以作用在伴随对象成员变量上方，我们来试试看，如果同样作用在伴随对象成员变量中，会出现什么情况。 添加@JvmField注解的效果，上面我们已经看到了，我们直接将注解修改为@JvmStatic试试看： 添加到伴随对象KotlinJava12345678class Person { var name: String? = null companion object { @JvmStatic val GENDER_MALE = 1 }}12345678910public static void main(String[] args) { // 1) 这样访问报错 int gender = Person.GENDER_MALE; // 2) 这样访问正常 int gender = Person.Companion.getGENDER_MALE(); // 3) 这样访问也正常 int gender = Person.getGENDER_MALE(); System.out.println(gender);} 切换到Java代码，你可以看到，我一共提供了三种访问方式。第一种访问方式是通过点语法直接访问，编译器报错，由此可见，@JvmStatic注解并没有在伴生类中生成静态的公有成员变量。第三种方式可以正常访问，证明该注解在伴生类中生成了静态的公有getter方法。第二种方式可以正常访问，证明该注解不会破坏伴随对象中原有成员的访问方式。 由此，我们可以大胆猜测，@JvmStatic注解的作用应该是生成静态的setter/getter方法，而不会改变属性（成员变量）的访问权限。 为了进一步验证我们的猜想，我们将val修改为var试试看。 12345678910111213public static void main(String[] args) &#123; // 1) 这样访问报错 int gender = Person.GENDER_MALE; // 2) 这样访问正常 int gender = Person.Companion.getGENDER_MALE(); // 3) 这样访问也正常 int gender = Person.getGENDER_MALE(); // 4) 以下访问正常 Person.setGENDER_MALE(1); System.out.println(gender);&#125; 第四种方式调用正常，证明我们的猜测没有错，@JvmStatic仅会改变伴随对象或对象（object）中setter/getter方法的生成方式，而不会改变属性访问权限，这是与注解@JvmField的本质区别。 注意：由于@JvmField不仅会改变属性的访问权限，同时也会改变setter/getter方法的生成，细心的同学应该已经注意到了。一旦添加了@JvmField注解，setter/getter方法也消失了（变量可以通过点语法直接访问，setter/getter方法也就没必要存在了）。而@JvmStatic仅仅是使setter/getter方法变为静态方法，同时生成位置放置到伴生类中。这与@JvmField的处理方式有些冲突（@JvmField会直接删除掉setter/getter方法）。为了避免冲突，Kotlin语言禁止将这两个注解混淆使用。 以上是将@JvmStatic与@JvmField作用在伴随对象成员变量上的区别。实际上，@JvmStatic不仅可以修饰属性（成员变量），还可以修饰方法，修饰方法的作用与修饰属性的作用一致，都是将方法变成静态类型。 为了更直观地表示两种的区别，我们用一个表格完整展示两个注解的区别： 注解 作用位置 作用 @JvmField 类属性或对象属性 使属性修饰符成为public @JvmStatic 对象方法（包括伴生对象） 使用方法成为静态类型，如果作用在伴生对象方法中，其方法会成为伴生类的静态方法 @JvmName这个注解可以改变字节码中生成的类名或方法名称，如果作用在顶级作用域（文件中），则会改变生成对应Java类的名称。如果作用在方法上，则会改变生成对应Java方法的名称。 @JvmNameKotlinJava123456@file:JvmName("FooKt")@JvmName("foo1")fun foo() { println("Hello, Jvm...")}1234567// 相当于下面的Java代码public final class FooKt { public static final void foo1() { String var0 = "Hello, Jvm..."; System.out.println(var0); }} 可以看到第一个注解@file:JvmName(&quot;FooKt&quot;)的作用是使生成的类名变为FooKt，第二个注解的作用是使生成的方法名称变为foo1。 注意：该注解不能改变类中生成的属性（成员变量）的名称。 这里的注解中，我们看到了一个特殊的前缀@file:，这个注解前缀是Kotlin语言特有的一种标识，其作用是标记该注解最终会作用在生成的字节码的具体位置（属性、setter、getter等），关于这个部分，大家可以先跳过，下一篇文章将给大家详细讲解。 @JvmMultifileClass说完了上面这个注解，就不得不提到@JvmMultifileClass这个注解，这个注解通常是与@JvmName结合使用的。其使用场景比较单一，看下面的例子： @JvmMultifileClassUtil1Util212345@file:JvmName("Utils")fun isEmpty(str: String?): Boolean { return null == str || str.length &lt;= 0}12345@file:JvmName("Utils")fun isPhoneNumber(str: String): Boolean { return str.startsWith("1") &amp;&amp; str.length == 11} 编译以上代码，Kotlin编译器会提示错误Error:(1, 1) Kotlin: Duplicate JVM class name &#39;Utils&#39; generated from: package-fragment, package-fragment，即生成的类名出现了重复。可是，如果我们就是希望声明使用多个文件，但方法生成到同一个类中呢？@JvmMultifileClass就是为解决这个问题而生的。 我们在上面代码的基础上分别添加注解@JvmMultifileClass试试看: @JvmMultifileClassUtil1Util2Java123456@file:JvmName("Utils")@file:JvmMultifileClasfun isEmpty(str: String?): Boolean { return null == str || str.length &lt;= 0}123456@file:JvmName("Utils")@file:JvmMultifileClassfun isPhoneNumber(str: String): Boolean { return str.startsWith("1") &amp;&amp; str.length == 11}12345678910// 生成的代码相当于下面这段Java代码public final class Utils { public static final boolean isEmpty(@Nullable String str) { return Utils__A1Kt.isEmpty(str); } public static final boolean isPhoneNumber(@NotNull String str) { return Utils__A2Kt.isPhoneNumber(str); }} 这个注解在处理多个文件声明，合并到一个类的场景中发挥着举足轻重的作用。如果你有这样的需求，一定要谨记这个注解。 @JvmOverloads由于Kotlin语言支持方法参数默认值，而实现类似功能Java需要使用方法重载来实现，这个注解就是为解决这个问题而生的，添加这个注解会自动生成重载方法。我们来试一下： @JvmOverloadsKotlinJava1234@JvmOverloadsfun foo(x: Int, y: Int = 0, z: Int = 0): Int { return x + y + z}123456789101112// 生成的代码相当于下面这段Java代码public static final int foo(int x, int y, int z) { return x + y + z;} public static final int foo(int x, int y) { return foo(x, y, 0);}public static final int foo(int x) { return foo(x, 0, 0);} 由此可见，通过这个注解可以影响带有参数默认值方法的生成，添加该注解将自动生成带有默认值参数数量的重载方法。这是一个非常有用的特性，方便Java端可以更高效地调用Kotlin端代码。 @Throws由于Kotlin语言不支持CE（Checked Exception），所谓CE，即方法可能抛出的异常是已知的。Java语言通过throws关键字在方法上声明CE。为了兼容这种写法，Kotlin语言新增了@Throws注解，该注解的接收一个可变参数，参数类型是多个异常的KClass实例。Kotlin编译器通过读取注解参数，在生成的字节码中自动添加CE声明。 为了便于理解，看一个简单的例子： @JvmOverloadsKotlinJava1234@Throws(IllegalArgumentException::class)fun div(x: Int, y: Int): Float { return x.toFloat() / y}1234// 生成的代码相当于下面这段Java代码public static final float div(int x, int y) throws IllegalArgumentException { return (float)x / (float)y;} 可以看到，添加了@Throws(IllegalArgumentException::class)注解后，在生成的方法签名上自动添加了可能抛出的异常声明（throws IllegalArgumentException），即CE。 这个注解在保证逻辑的严谨性方面非常有用，但如果你的工程中仅使用Kotlin代码，可以不用理会该注解。在Kotlin语言的设计哲学里面，CE被认为是一个错误的设计。 @Synchronized这个注解很容易理解，顾名思义，主要用于产生同步方法。Kotlin语言不支持synchronized关键字，处理类似Java语言的并发问题，Kotlin语言建议使用同步方法进行处理。 Kotlin团队认为同步的逻辑应该交给代码处理，而不应该在语言层面处理： 但为了兼容Java，Kotlin语言支持使用该注解让编译器自动生成同步方法： @SynchronizedKotlinJava1234@Synchronizedfun start() { println("Start do something...")}12345// 生成的代码相当于下面这段Java代码public static final synchronized void start() { String var0 = "Start do something..."; System.out.println(var0);} @JvmWildcard这个注解主要用于处理泛型参数，这涉及到两个新的知识点：逆变与协变。由于Java语言不支持协变，为了保证安全地相互调用，可以通过在泛型参数声明的位置添加该注解使用Kotlin编译器生成通配符形式的泛型参数（？extends ...)。 看下面这段代码： 1234567class Box&lt;out T&gt;(val value: T)interface Baseclass Derived : Basefun boxDerived(value: Derived): Box&lt;Derived&gt; = Box(value)fun unboxBase(box: Box&lt;Base&gt;): Base = box.value 按照正常思维，下面的两个方法转换到Java代码应该是这样： 12Box&lt;Derived&gt; boxDerived(Derived value) &#123; …… &#125;Base unboxBase(Box&lt;Base&gt; box) &#123; …… &#125; 但问题是，Kotlin泛型支持型变，在Kotlin中，我们可以这样写unboxBase(Box(Derived()))，而在Java语言中，泛型参数类型是不可变的，按照上面的写法显然已经做不到了。 正确转换到Java代码应该是这样： 1Base unboxBase(Box&lt;? extends Base&gt; box) &#123; …… &#125; 为了使这样的转换正确生成，我们需要在泛型参数的位置添加上面的注解: 1fun unboxBase(box: Box&lt;@JvmWildcard Base&gt;): Base = box.value @JvmSuppressWildcards这个注解的作用与@JvmWildcard恰恰相反，它是用来抑制通配符泛型参数的生成，即在不需要型变泛型参数的情况下，我们可以通过添加这个注解来避免生成型变泛型参数。 @JvmSuppressWildcardsKotlinJava1fun unboxBase(box: Box&lt;@JvmSuppressWildcards Base&gt;): Base = box.value12// 生成的代码相当于下面这段Java代码Base unboxBase(Box&lt;Base&gt; box) { …… } 正确使用上述注解，可以抹平Kotlin与Java泛型处理的差异，避免出现安全转换问题。 @Volatile @Transient这两个注解恰好对应Java端的两个关键字volatile与transient，前者主要用于解决多线程脏数据问题，后者用于标记序列化对象中不参与序列化的属性。 这两个注解比较简单，就不举例说明了。在遇到类似需要与Java互通的场景时，只需要将其关键字替换为该注解即可。 以上就是我们日常开发过程中能够遇到的所有注解了，在Kotlin 1.3版本中，还增加了一个新的注解@JvmDefault用于在接口中处理默认实现的方法。接口中允许有默认实现是从JDK 1.8版本开始的，为了兼容低版本JDK，Kotlin语言新增了该注解用于生成兼容性字节码，但该注解目前仍处于实验阶段，名称或行为均可能发生改变，建议大家先不要使用，推荐大家始终使用JDK 1.8及其以上版本。 最佳实践如果在工程中必须存在部分Java代码，为了实现完美调用，一定要谨慎并正确地使用上述注解。要充分理解Kotlin编译器与Java编译器生成的字节码差异。 如果是由于现存Java库仅兼容Java字节码，导致部分框架在遇到Kotlin语言生成的字节码时会出现解析错误，不能正常使用。这个时候要尝试检查是否需要通过上述注解矫正字节码的生成，使Java库能够正常使用。 如果是新工程，建议大家全部使用Kotlin代码，避免出现上述注解，减少阅读上的困难。目前，Kotlin版本已经非常稳定了，请大家放心使用。 阅读更多技术文章，请关注微信公众号”欧阳锋工作室“ 参与Kotlin技术讨论，请添加唯一官方QQ交流群：329673958]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>注解</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10分钟看懂动态代理设计模式]]></title>
    <url>%2F2018%2F03%2F02%2Fdesign%20pattern%2F10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。 什么是代理从字面意思来看，代理比较好理解，无非就是代为处理的意思。举个例子，你在上大学的时候，总是喜欢逃课。因此，你拜托你的同学帮你答到，而自己却窝在宿舍玩游戏… 你的这个同学恰好就充当了代理的作用，代替你去上课。 是的，你没有看错，代理就是这么简单！ 理解了代理的意思，你脑海中恐怕还有两个巨大的疑问： 怎么实现代理模式 代理模式有什么实际用途 要理解这两个问题，看一个简单的例子：12345678910111213141516public interface Flyable &#123; void fly();&#125;public class Bird implements Flyable &#123; @Override public void fly() &#123; System.out.println("Bird is flying..."); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 很简单的一个例子，用一个随机睡眠时间模拟小鸟在空中的飞行时间。接下来问题来了，如果我要知道小鸟在天空中飞行了多久，怎么办？ 有人说，很简单，在Bird-&gt;fly()方法的开头记录起始时间，在方法结束记录完成时间，两个时间相减就得到了飞行时间。123456789101112@Override public void fly() &#123; long start = System.currentTimeMillis(); System.out.println("Bird is flying..."); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start)); &#125; 的确，这个方法没有任何问题，接下来加大问题的难度。如果Bird这个类来自于某个SDK（或者说Jar包）提供，你无法改动源码，怎么办？ 一定会有人说，我可以在调用的地方这样写：1234567public static void main(String[] args) &#123; Bird bird = new Bird(); long start = System.currentTimeMillis(); bird.fly(); long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start));&#125; 这个方案看起来似乎没有问题，但其实你忽略了准备这些方法所需要的时间，执行一个方法，需要开辟栈内存、压栈、出栈等操作，这部分时间也是不可以忽略的。因此，这个解决方案不可行。那么，还有什么方法可以做到呢？ a）使用继承继承是最直观的解决方案，相信你已经想到了，至少我最开始想到的解决方案就是继承。为此，我们重新创建一个类Bird2，在Bird2中我们只做一件事情，就是调用父类的fly方法，在前后记录时间，并打印时间差：123456789101112public class Bird2 extends Bird &#123; @Override public void fly() &#123; long start = System.currentTimeMillis(); super.fly(); long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start)); &#125;&#125; 这是一种解决方案，还有一种解决方案叫做：聚合，其实也是比较容易想到的。我们再次创建新类Bird3，在Bird3的构造方法中传入Bird实例。同时，让Bird3也实现Flyable接口，并在fly方法中调用传入的Bird实例的fly方法：1234567891011121314151617public class Bird3 implements Flyable &#123; private Bird bird; public Bird3(Bird bird) &#123; this.bird = bird; &#125; @Override public void fly() &#123; long start = System.currentTimeMillis(); bird.fly(); long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start)); &#125;&#125; 为了记录Bird-&gt;fly()方法的执行时间，我们在前后添加了记录时间的代码。同样地，通过这种方法我们也可以获得小鸟的飞行时间。那么，这两种方法孰优孰劣呢？咋一看，不好评判！ 继续深入思考，用问题推导来解答这个问题： 问题一：如果我还需要在fly方法前后打印日志，记录飞行开始和飞行结束，怎么办？有人说，很简单！继承Bird2并在在前后添加打印语句即可。那么，问题来了，请看问题二。 问题二：如果我需要调换执行顺序，先打印日志，再获取飞行时间，怎么办？有人说，再新建一个类Bird4继承Bird，打印日志。再新建一个类Bird5继承Bird4，获取方法执行时间。 问题显而易见：使用继承将导致类无限制扩展，同时灵活性也无法获得保障。那么，使用 聚合 是否可以避免这个问题呢？答案是：可以！但我们的类需要稍微改造一下。修改Bird3类，将聚合对象Bird类型修改为Flyable 1234567891011121314151617public class Bird3 implements Flyable &#123; private Flyable flyable; public Bird3(Flyable flyable) &#123; this.flyable = flyable; &#125; @Override public void fly() &#123; long start = System.currentTimeMillis(); flyable.fly(); long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start)); &#125;&#125; 为了让你看的更清楚，我将Bird3更名为BirdTimeProxy，即用于获取方法执行时间的代理的意思。同时我们新建BirdLogProxy代理类用于打印日志： 12345678910111213141516public class BirdLogProxy implements Flyable &#123; private Flyable flyable; public BirdLogProxy(Flyable flyable) &#123; this.flyable = flyable; &#125; @Override public void fly() &#123; System.out.println("Bird fly start..."); flyable.fly(); System.out.println("Bird fly end..."); &#125;&#125; 接下来神奇的事情发生了，如果我们需要先记录日志，再获取飞行时间，可以在调用的地方这么做： 1234567public static void main(String[] args) &#123; Bird bird = new Bird(); BirdLogProxy p1 = new BirdLogProxy(bird); BirdTimeProxy p2 = new BirdTimeProxy(p1); p2.fly();&#125; 反过来，可以这么做： 1234567public static void main(String[] args) &#123; Bird bird = new Bird(); BirdTimeProxy p2 = new BirdTimeProxy(bird); BirdLogProxy p1 = new BirdLogProxy(p2); p1.fly();&#125; 看到这里，有同学可能会有疑问了。虽然现象看起来，聚合可以灵活调换执行顺序。可是，为什么 聚合 可以做到，而继承不行呢。我们用一张图来解释一下： 静态代理接下来，观察上面的类BirdTimeProxy，在它的fly方法中我们直接调用了flyable-&gt;fly()方法。换而言之，BirdTimeProxy其实代理了传入的Flyable对象，这就是典型的静态代理实现。 从表面上看，静态代理已经完美解决了我们的问题。可是，试想一下，如果我们需要计算SDK中100个方法的运行时间，同样的代码至少需要重复100次，并且创建至少100个代理类。往小了说，如果Bird类有多个方法，我们需要知道其他方法的运行时间，同样的代码也至少需要重复多次。因此，静态代理至少有以下两个局限性问题： 如果同时代理多个类，依然会导致类无限制扩展 如果类中有多个方法，同样的逻辑需要反复实现 那么，我们是否可以使用同一个代理类来代理任意对象呢？我们以获取方法运行时间为例，是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢？甚至再大胆一点，代理的逻辑也可以自己指定。比如，获取方法的执行时间，打印日志，这类逻辑都可以自己指定。这就是本文重点探讨的问题，也是最难理解的部分：动态代理。 动态代理继续回到上面这个问题：是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢。 这个部分需要一定的抽象思维，我想，你脑海中的第一个解决方案应该是使用反射。反射是用于获取已创建实例的方法或者属性，并对其进行调用或者赋值。很明显，在这里，反射解决不了问题。但是，再大胆一点，如果我们可以动态生成TimeProxy这个类，并且动态编译。然后，再通过反射创建对象并加载到内存中，不就实现了对任意对象进行代理了吗？为了防止你依然一头雾水，我们用一张图来描述接下来要做什么： 动态生成Java源文件并且排版是一个非常繁琐的工作，为了简化操作，我们使用 JavaPoet 这个第三方库帮我们生成TimeProxy的源码。希望 JavaPoet 不要成为你的负担，不理解 JavaPoet 没有关系，你只要把它当成一个Java源码生成工具使用即可。 PS：你记住，任何工具库的使用都不会太难，它是为了简化某些操作而出现的，目标是简化而不是繁琐。因此，只要你适应它的规则就轻车熟路了。 第一步：生成TimeProxy源码12345678910111213141516171819202122232425262728293031323334353637383940public class Proxy &#123; public static Object newProxyInstance() throws IOException &#123; TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder("TimeProxy") .addSuperinterface(Flyable.class); FieldSpec fieldSpec = FieldSpec.builder(Flyable.class, "flyable", Modifier.PRIVATE).build(); typeSpecBuilder.addField(fieldSpec); MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(Flyable.class, "flyable") .addStatement("this.flyable = flyable") .build(); typeSpecBuilder.addMethod(constructorMethodSpec); Method[] methods = Flyable.class.getDeclaredMethods(); for (Method method : methods) &#123; MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .returns(method.getReturnType()) .addStatement("long start = $T.currentTimeMillis()", System.class) .addCode("\n") .addStatement("this.flyable." + method.getName() + "()") .addCode("\n") .addStatement("long end = $T.currentTimeMillis()", System.class) .addStatement("$T.out.println(\"Fly Time =\" + (end - start))", System.class) .build(); typeSpecBuilder.addMethod(methodSpec); &#125; JavaFile javaFile = JavaFile.builder("com.youngfeng.proxy", typeSpecBuilder.build()).build(); // 为了看的更清楚，我将源码文件生成到桌面 javaFile.writeTo(new File("/Users/ouyangfeng/Desktop/")); return null; &#125;&#125; 在main方法中调用Proxy.newProxyInstance()，你将看到桌面已经生成了TimeProxy.java文件，生成的内容如下： 12345678910111213141516171819202122package com.youngfeng.proxy;import java.lang.Override;import java.lang.System;class TimeProxy implements Flyable &#123; private Flyable flyable; public TimeProxy(Flyable flyable) &#123; this.flyable = flyable; &#125; @Override public void fly() &#123; long start = System.currentTimeMillis(); this.flyable.fly(); long end = System.currentTimeMillis(); System.out.println("Fly Time =" + (end - start)); &#125;&#125; 第二步：编译TimeProxy源码编译TimeProxy源码我们直接使用JDK提供的编译工具即可，为了使你看起来更清晰，我使用一个新的辅助类来完成编译操作： 1234567891011public class JavaCompiler &#123; public static void compile(File javaFile) throws IOException &#123; javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null); Iterable iterable = fileManager.getJavaFileObjects(javaFile); javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable); task.call(); fileManager.close(); &#125;&#125; 在Proxy-&gt;newProxyInstance()方法中调用该方法，编译顺利完成： 123456// 为了看的更清楚，我将源码文件生成到桌面String sourcePath = "/Users/ouyangfeng/Desktop/";javaFile.writeTo(new File(sourcePath));// 编译JavaCompiler.compile(new File(sourcePath + "/com/youngfeng/proxy/TimeProxy.java")); 第三步：加载到内存中并创建对象123456URL[] urls = new URL[] &#123;new URL("file:/" + sourcePath)&#125;;URLClassLoader classLoader = new URLClassLoader(urls);Class clazz = classLoader.loadClass("com.youngfeng.proxy.TimeProxy");Constructor constructor = clazz.getConstructor(Flyable.class);Flyable flyable = (Flyable) constructor.newInstance(new Bird());flyable.fly(); 通过以上三个步骤，我们至少解决了下面两个问题： 不再需要手动创建TimeProxy 可以代理任意实现了Flyable接口的类对象，并获取接口方法的执行时间 可是，说好的任意对象呢？ 第四步：增加InvocationHandler接口查看Proxy-&gt;newProxyInstance()的源码，代理类继承的接口我们是写死的，为了增加灵活性，我们将接口类型作为参数传入： 接口的灵活性问题解决了，TimeProxy的局限性依然存在，它只能用于获取方法的执行时间，而如果要在方法执行前后打印日志则需要重新创建一个代理类，显然这是不妥的！ 为了增加控制的灵活性，我们考虑针将代理的处理逻辑也抽离出来（这里的处理就是打印方法的执行时间）。新增InvocationHandler接口，用于处理自定义逻辑： 123public interface InvocationHandler &#123; void invoke(Object proxy, Method method, Object[] args);&#125; 想象一下，如果客户程序员需要对代理类进行自定义的处理，只要实现该接口，并在invoke方法中进行相应的处理即可。这里我们在接口中设置了三个参数（其实也是为了和JDK源码保持一致）： proxy =&gt; 这个参数指定动态生成的代理类，这里是TimeProxy method =&gt; 这个参数表示传入接口中的所有Method对象 args =&gt; 这个参数对应当前method方法中的参数 引入了InvocationHandler接口之后，我们的调用顺序应该变成了这样： 12345MyInvocationHandler handler = new MyInvocationHandler();Flyable proxy = Proxy.newProxyInstance(Flyable.class, handler);proxy.fly();方法执行流：proxy.fly() =&gt; handler.invoke() 为此，我们需要在Proxy.newProxyInstance()方法中做如下改动： 在newProxyInstance方法中传入InvocationHandler 在生成的代理类中增加成员变量handler 在生成的代理类方法中，调用invoke方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 public static Object newProxyInstance(Class inf, InvocationHandler handler) throws Exception &#123; TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder("TimeProxy") .addModifiers(Modifier.PUBLIC) .addSuperinterface(inf); FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, "handler", Modifier.PRIVATE).build(); typeSpecBuilder.addField(fieldSpec); MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(InvocationHandler.class, "handler") .addStatement("this.handler = handler") .build(); typeSpecBuilder.addMethod(constructorMethodSpec); Method[] methods = inf.getDeclaredMethods(); for (Method method : methods) &#123; MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .returns(method.getReturnType()) .addCode("try &#123;\n") .addStatement("\t$T method = " + inf.getName() + ".class.getMethod(\"" + method.getName() + "\")", Method.class) // 为了简单起见，这里参数直接写死为空 .addStatement("\tthis.handler.invoke(this, method, null)") .addCode("&#125; catch(Exception e) &#123;\n") .addCode("\te.printStackTrace();\n") .addCode("&#125;\n") .build(); typeSpecBuilder.addMethod(methodSpec); &#125; JavaFile javaFile = JavaFile.builder("com.youngfeng.proxy", typeSpecBuilder.build()).build(); // 为了看的更清楚，我将源码文件生成到桌面 String sourcePath = "/Users/ouyangfeng/Desktop/"; javaFile.writeTo(new File(sourcePath)); // 编译 JavaCompiler.compile(new File(sourcePath + "/com/youngfeng/proxy/TimeProxy.java")); // 使用反射load到内存 URL[] urls = new URL[] &#123;new URL("file:" + sourcePath)&#125;; URLClassLoader classLoader = new URLClassLoader(urls); Class clazz = classLoader.loadClass("com.youngfeng.proxy.TimeProxy"); Constructor constructor = clazz.getConstructor(InvocationHandler.class); Object obj = constructor.newInstance(handler); return obj;&#125; 上面的代码你可能看起来比较吃力，我们直接调用该方法，查看最后生成的源码。在main方法中测试newProxyInstance查看生成的TimeProxy源码： 测试代码 1Proxy.newProxyInstance(Flyable.class, new MyInvocationHandler(new Bird())); 生成的TimeProxy.java源码 12345678910111213141516171819202122package com.youngfeng.proxy;import java.lang.Override;import java.lang.reflect.Method;public class TimeProxy implements Flyable &#123; private InvocationHandler handler; public TimeProxy(InvocationHandler handler) &#123; this.handler = handler; &#125; @Override public void fly() &#123; try &#123; Method method = com.youngfeng.proxy.Flyable.class.getMethod("fly"); this.handler.invoke(this, method, null); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; MyInvocationHandler.java 1234567891011121314151617181920212223public class MyInvocationHandler implements InvocationHandler &#123; private Bird bird; public MyInvocationHandler(Bird bird) &#123; this.bird = bird; &#125; @Override public void invoke(Object proxy, Method method, Object[] args) &#123; long start = System.currentTimeMillis(); try &#123; method.invoke(bird, new Object[] &#123;&#125;); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start)); &#125;&#125; 至此，整个方法栈的调用栈变成了这样： 看到这里，估计很多同学已经晕了，在静态代理部分，我们在代理类中传入了被代理对象。可是，使用newProxyInstance生成动态代理对象的时候，我们居然不再需要传入被代理对象了。我们传入了的实际对象是InvocationHandler实现类的实例，这看起来有点像生成了InvocationHandler的代理对象，在动态生成的代理类的任意方法中都会间接调用InvocationHandler-&gt;invoke(proxy, method, args)方法。 其实的确是这样。TimeProxy真正代理的对象就是InvocationHandler，不过这里设计的巧妙之处在于，InvocationHandler是一个接口，真正的实现由用户指定。另外，在每一个方法执行的时候，invoke方法都会被调用 ，这个时候如果你需要对某个方法进行自定义逻辑处理，可以根据method的特征信息进行判断分别处理。 如何使用上面这段解释是告诉你在执行Proxy-&gt;newProxyInstance方法的时候真正发生的事情，而在实际使用过程中你完全可以忘掉上面的解释。按照设计者的初衷，我们做如下简单归纳： Proxy-&gt;newProxyInstance(infs, handler) 用于生成代理对象 InvocationHandler：这个接口主要用于自定义代理逻辑处理 为了完成对被代理对象的方法拦截，我们需要在InvocationHandler对象中传入被代理对象实例。 查看上面的代码，你可以看到我将Bird实例已经传入到了MyInvocationHandler中，原因就是第三点。 这样设计有什么好处呢？有人说，我们大费周章，饶了一大圈，最终变成了这个样子，到底图什么呢？ 想象一下，到此为止，如果我们还需要对其它任意对象进行代理，是否还需要改动newProxyInstance方法的源码，答案是：完全不需要！ 只要你在newProxyInstance方法中指定代理需要实现的接口，指定用于自定义处理的InvocationHandler对象，整个代理的逻辑处理都在你自定义的InvocationHandler实现类中进行处理。至此，而我们终于可以从不断地写代理类用于实现自定义逻辑的重复工作中解放出来了，从此需要做什么，交给InvocationHandler。 事实上，我们之前给自己定下的目标“使用同一个类来计算任意对象的任一方法的执行时间”已经实现了。严格来说，是我们超额完成了任务，TimeProxy不仅可以计算方法执行的时间，也可以打印方法执行日志，这完全取决于你的InvocationHandler接口实现。因此，这里取名为TimeProxy其实已经不合适了。我们可以修改为和JDK命名一致，即$Proxy0，感兴趣的同学请自行实践，本篇文章的代码将放到我的Github仓库，文章结尾会给出代码地址。 JDK实现揭秘通过上面的这些步骤，我们完成了一个简易的仿JDK实现的动态代理逻辑。接下来，我们一起来看一看JDK实现的动态代理和我们到底有什么不同。 Proxy.java InvocationHandler 可以看到，官方版本Proxy类提供的方法多一些，而我们主要使用的接口newProxyInstance参数也和我们设计的不太一样。这里给大家简单解释一下，每个参数的意义： Classloader：类加载器，你可以使用自定义的类加载器，我们的实现版本为了简化，直接在代码中写死了Classloader。 Class&lt;?&gt;[]：第二个参数也和我们的实现版本不一致，这个其实很容易理解，我们应该允许我们自己实现的代理类同时实现多个接口。前面设计只传入一个接口，只是为了简化实现，让你专注核心逻辑实现而已。 最后一个参数就不用说了，和我们实现的版本完全是一样的。 仔细观察官方版本的InvocationHandler，它和我们自己的实现的版本也有一个细微的差别：官方版本invoke方法有返回值，而我们的版本中是没有返回值的。那么，返回值到底有什么作用呢？直接来看官方文档： 核心思想：这里的返回值类型必须和传入接口的返回值类型一致，或者与其封装对象的类型一致。 遗憾的是，这里并没有说明返回值的用途，其实这里稍微发挥一下想象力就知道了。在我们的版本实现中，Flyable接口的所有方法都是没有返回值的，问题是，如果有返回值呢？是的，你没有猜错，这里的invoke方法对应的就是传入接口中方法的返回值。 答疑解惑invoke方法的第一个参数proxy到底有什么作用？这个问题其实也好理解，如果你的接口中有方法需要返回自身，如果在invoke中没有传入这个参数，将导致实例无法正常返回。在这种场景中，proxy的用途就表现出来了。简单来说，这其实就是最近非常火的链式编程的一种应用实现。 动态代理到底有什么用？学习任何一门技术，一定要问一问自己，这到底有什么用。其实，在这篇文章的讲解过程中，我们已经说出了它的主要用途。你发现没，使用动态代理我们居然可以在不改变源码的情况下，直接在方法中插入自定义逻辑。这有点不太符合我们的一条线走到底的编程逻辑，这种编程模型有一个专业名称叫 AOP。所谓的AOP，就像刀一样，抓住时机，趁机插入。 基于这样一种动态特性，我们可以用它做很多事情，例如： 事务提交或回退（Web开发中很常见） 权限管理 自定义缓存逻辑处理 SDK Bug修复… 如果你阅读过 Android_Slide_To_Close 的源码会发现，它也在某个地方使用了动态代理设计模式。 总结到此为止，关于动态代理的所有讲解已经结束了，原谅我使用了一个诱导性的标题“骗”你进来阅读这篇文章。如果你不是一个久经沙场的“老司机”，10分钟完全看懂动态代理设计模式还是有一定难度的。但即使没有看懂也没关系，如果你在第一次阅读完这篇文章后依然一头雾水，就不妨再仔细阅读一次。在阅读的过程中，一定要跟着文章思路去敲代码。反反复复，一定会看懂的。我在刚刚学习动态代理设计模式的时候就反复看了不下5遍，并且亲自敲代码实践了多次。 为了让你少走弯路，我认为看懂这篇文章，你至少需要学习以下知识点： 至少已经理解了面向对象语言的多态特性 了解简单的反射用法 会简单使用 JavaPoet 生成Java源码 如果你在阅读文章的过程中，有任何不理解的问题或者建议，欢迎在文章下方留言告诉我！ 本篇文章例子代码：https://github.com/yuanhoujun/java-dynamic-proxy 我是欧阳锋，设计模式是一种非常好的编程指导模型，它在所有编程语言中是通用的，并且是亘古不变的。我建议你在这个方面多下苦功，不要纠结在一些重复的劳动中，活用设计模式会让你的代码更显灵动。想要了解我吗？看这里：欧阳锋档案馆。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
</search>
