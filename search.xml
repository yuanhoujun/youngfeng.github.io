<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正确使用Kotlin注解，兼容Java代码]]></title>
    <url>%2F2019%2F11%2F12%2F%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8Kotlin%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%85%BC%E5%AE%B9Java%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[大多数情况下，你不需要关注这个问题。但是，如果你的代码中包含了部分Java代码，理解这些注解将帮助你解决很多棘手问题。 产生这个问题的根本原因在于：Kotlin语言与Java语言的设计思路不同，部分特性属于Java语言独有，例如静态变量。部分特性属于Kotlin语言独有，例如逆变和协变。 为了抹平这些差异，Kotlin语言提供了一个绝佳的思路，通过添加注解可以改变Kotlin编译器生成的Java字节码，使之按照Java语言可以理解的方向进行，从而实现兼容。 问题答疑：Kotlin语言与Java字节码有什么关系？为什么Kotlin编译器会生成Java字节码？ 不管是Kotlin语言还是Java语言都是建立在JVM平台上面的编程语言，其最终都需要编译成JVM可以识别的Java字节码才能被正确执行。这也是为什么Kotlin语言与Java可以完全互通的原因之一，不要将Java与Java平台混为一谈。 接下来我们看第一个注解，也是最常见的注解 @JvmFieldKotlin编译器默认会将类中声明的成员变量编译成私有变量，Java语言要访问该变量必须通过其生成的getter方法。而使用上面的注解可以向Java暴露该变量，即使其访问变为公开（修饰符变为public)。 我们来做一个实验： @JvmFieldKotlinJava1234class Person { @JvmField var name: String? = null}123456789public class Client { public static void main(String[] args) { Person p = new Person(); // 在添加@JvmField注解之前，这样访问会报错 // 只能通过p.getName()的方式进行访问 String name = p.name; }} 在Person类中我们定义了一个成员变量name，在添加@JvmField属性前我们试图通过p.name的方式进行访问，编译器会报错。因为，默认生成的成员变量name是私有的。而添加该注解之后我们却可以正常访问了。 由此可见，@JvmField注解的确使生成的字节码发生了变化，我们将字节码用Java语言的形式表示，具体发生的变化类似下面的代码展示： 添加@JvmField注解的变化beforeafter1234567891011public final class Person { private String name; public final String getName() { return this.name; } public final void setName(@Nullable String var1) { this.name = var1; }}123public final class Person { public String name;} 注：before与after分别为添加注解前与添加之后 以上场景是将@JvmField注解添加到普通变量上方，如果添加到伴随对象的成员变量上方，会发生什么呢？我们来试试看： 添加到伴随对象KotlinJava12345678class Person { var name: String? = null companion object { @JvmField val GENDER_MALE = 1 }}1234567public static void main(String[] args) { // 未添加之前 // int gender = Person.Companion.getGENDER_MALE(); // 添加之后，可直接访问 int gender = Person.GENDER_MALE; System.out.println(gender);} 同样地，添加注解之后我们可以通过点语法直接对其进行访问。 由此可见，@JvmField注解会使伴随对象在伴生类中生成静态成员变量，通过伴生类类名可直接对其进行访问。 结论@JvmField注解可改变字节码的生成，其作用的目标是类成员变量或伴随对象成员变量。作用在类成员中可使该变量对外暴露，通过点语法直接访问。即将私有成员变量公有化（public），并去掉setter/getter方法。作用在伴随对象成员变量中，可以使该伴随对象中的变量生成在伴生对象中，成为伴生对象的公有静态成员变量，通过伴生类可直接访问。 那么问题来了，如果该注解作用在私有成员变量上方会发生什么呢？请大家自行做实验验证。 @JvmStatic这个注解与@JvmField非常容易出现混淆，两者都可以作用在伴随对象成员变量上方，我们来试试看，如果同样作用在伴随对象成员变量中，会出现什么情况。 添加@JvmField注解的效果，上面我们已经看到了，我们直接将注解修改为@JvmStatic试试看： 添加到伴随对象KotlinJava12345678class Person { var name: String? = null companion object { @JvmStatic val GENDER_MALE = 1 }}12345678910public static void main(String[] args) { // 1) 这样访问报错 int gender = Person.GENDER_MALE; // 2) 这样访问正常 int gender = Person.Companion.getGENDER_MALE(); // 3) 这样访问也正常 int gender = Person.getGENDER_MALE(); System.out.println(gender);} 切换到Java代码，你可以看到，我一共提供了三种访问方式。第一种访问方式是通过点语法直接访问，编译器报错，由此可见，@JvmStatic注解并没有在伴生类中生成静态的公有成员变量。第三种方式可以正常访问，证明该注解在伴生类中生成了静态的公有getter方法。第二种方式可以正常访问，证明该注解不会破坏伴随对象中原有成员的访问方式。 由此，我们可以大胆猜测，@JvmStatic注解的作用应该是生成静态的setter/getter方法，而不会改变属性（成员变量）的访问权限。 为了进一步验证我们的猜想，我们将val修改为var试试看。 12345678910111213public static void main(String[] args) &#123; // 1) 这样访问报错 int gender = Person.GENDER_MALE; // 2) 这样访问正常 int gender = Person.Companion.getGENDER_MALE(); // 3) 这样访问也正常 int gender = Person.getGENDER_MALE(); // 4) 以下访问正常 Person.setGENDER_MALE(1); System.out.println(gender);&#125; 第四种方式调用正常，证明我们的猜测没有错，@JvmStatic仅会改变伴随对象或对象（object）中setter/getter方法的生成方式，而不会改变属性访问权限，这是与注解@JvmField的本质区别。 注意：由于@JvmField不仅会改变属性的访问权限，同时也会改变setter/getter方法的生成，细心的同学应该已经注意到了。一旦添加了@JvmField注解，setter/getter方法也消失了（变量可以通过点语法直接访问，setter/getter方法也就没必要存在了）。而@JvmStatic仅仅是使setter/getter方法变为静态方法，同时生成位置放置到伴生类中。这与@JvmField的处理方式有些冲突（@JvmField会直接删除掉setter/getter方法）。为了避免冲突，Kotlin语言禁止将这两个注解混淆使用。 以上是将@JvmStatic与@JvmField作用在伴随对象成员变量上的区别。实际上，@JvmStatic不仅可以修饰属性（成员变量），还可以修饰方法，修饰方法的作用与修饰属性的作用一致，都是将方法变成静态类型。 为了更直观地表示两种的区别，我们用一个表格完整展示两个注解的区别： 注解 作用位置 作用 @JvmField 类属性或对象属性 使属性修饰符成为public @JvmStatic 对象方法（包括伴生对象） 使用方法成为静态类型，如果作用在伴生对象方法中，其方法会成为伴生类的静态方法 @JvmName这个注解可以改变字节码中生成的类名或方法名称，如果作用在顶级作用域（文件中），则会改变生成对应Java类的名称。如果作用在方法上，则会改变生成对应Java方法的名称。 @JvmNameKotlinJava123456@file:JvmName("FooKt")@JvmName("foo1")fun foo() { println("Hello, Jvm...")}1234567// 相当于下面的Java代码public final class FooKt { public static final void foo1() { String var0 = "Hello, Jvm..."; System.out.println(var0); }} 可以看到第一个注解@file:JvmName(&quot;FooKt&quot;)的作用是使生成的类名变为FooKt，第二个注解的作用是使生成的方法名称变为foo1。 注意：该注解不能改变类中生成的属性（成员变量）的名称。 这里的注解中，我们看到了一个特殊的前缀@file:，这个注解前缀是Kotlin语言特有的一种标识，其作用是标记该注解最终会作用在生成的字节码的具体位置（属性、setter、getter等），关于这个部分，大家可以先跳过，下一篇文章将给大家详细讲解。 @JvmMultifileClass说完了上面这个注解，就不得不提到@JvmMultifileClass这个注解，这个注解通常是与@JvmName结合使用的。其使用场景比较单一，看下面的例子： @JvmMultifileClassUtil1Util212345@file:JvmName("Utils")fun isEmpty(str: String?): Boolean { return null == str || str.length &lt;= 0}12345@file:JvmName("Utils")fun isPhoneNumber(str: String): Boolean { return str.startsWith("1") &amp;&amp; str.length == 11} 编译以上代码，Kotlin编译器会提示错误Error:(1, 1) Kotlin: Duplicate JVM class name &#39;Utils&#39; generated from: package-fragment, package-fragment，即生成的类名出现了重复。可是，如果我们就是希望声明使用多个文件，但方法生成到同一个类中呢？@JvmMultifileClass就是为解决这个问题而生的。 我们在上面代码的基础上分别添加注解@JvmMultifileClass试试看: @JvmMultifileClassUtil1Util2Java123456@file:JvmName("Utils")@file:JvmMultifileClasfun isEmpty(str: String?): Boolean { return null == str || str.length &lt;= 0}123456@file:JvmName("Utils")@file:JvmMultifileClassfun isPhoneNumber(str: String): Boolean { return str.startsWith("1") &amp;&amp; str.length == 11}12345678910// 生成的代码相当于下面这段Java代码public final class Utils { public static final boolean isEmpty(@Nullable String str) { return Utils__A1Kt.isEmpty(str); } public static final boolean isPhoneNumber(@NotNull String str) { return Utils__A2Kt.isPhoneNumber(str); }} 这个注解在处理多个文件声明，合并到一个类的场景中发挥着举足轻重的作用。如果你有这样的需求，一定要谨记这个注解。 @JvmOverloads由于Kotlin语言支持方法参数默认值，而实现类似功能Java需要使用方法重载来实现，这个注解就是为解决这个问题而生的，添加这个注解会自动生成重载方法。我们来试一下： @JvmOverloadsKotlinJava1234@JvmOverloadsfun foo(x: Int, y: Int = 0, z: Int = 0): Int { return x + y + z}123456789101112// 生成的代码相当于下面这段Java代码public static final int foo(int x, int y, int z) { return x + y + z;} public static final int foo(int x, int y) { return foo(x, y, 0);}public static final int foo(int x) { return foo(x, 0, 0);} 由此可见，通过这个注解可以影响带有参数默认值方法的生成，添加该注解将自动生成带有默认值参数数量的重载方法。这是一个非常有用的特性，方便Java端可以更高效地调用Kotlin端代码。 @Throws由于Kotlin语言不支持CE（Checked Exception），所谓CE，即方法可能抛出的异常是已知的。Java语言通过throws关键字在方法上声明CE。为了兼容这种写法，Kotlin语言新增了@Throws注解，该注解的接收一个可变参数，参数类型是多个异常的KClass实例。Kotlin编译器通过读取注解参数，在生成的字节码中自动添加CE声明。 为了便于理解，看一个简单的例子： @JvmOverloadsKotlinJava1234@Throws(IllegalArgumentException::class)fun div(x: Int, y: Int): Float { return x.toFloat() / y}1234// 生成的代码相当于下面这段Java代码public static final float div(int x, int y) throws IllegalArgumentException { return (float)x / (float)y;} 可以看到，添加了@Throws(IllegalArgumentException::class)注解后，在生成的方法签名上自动添加了可能抛出的异常声明（throws IllegalArgumentException），即CE。 这个注解在保证逻辑的严谨性方面非常有用，但如果你的工程中仅使用Kotlin代码，可以不用理会该注解。在Kotlin语言的设计哲学里面，CE被认为是一个错误的设计。 @Synchronized这个注解很容易理解，顾名思义，主要用于产生同步方法。Kotlin语言不支持synchronized关键字，处理类似Java语言的并发问题，Kotlin语言建议使用同步方法进行处理。 Kotlin团队认为同步的逻辑应该交给代码处理，而不应该在语言层面处理： 但为了兼容Java，Kotlin语言支持使用该注解让编译器自动生成同步方法： @SynchronizedKotlinJava1234@Synchronizedfun start() { println("Start do something...")}12345// 生成的代码相当于下面这段Java代码public static final synchronized void start() { String var0 = "Start do something..."; System.out.println(var0);} @JvmWildcard这个注解主要用于处理泛型参数，这涉及到两个新的知识点：逆变与协变。由于Java语言不支持协变，为了保证安全地相互调用，可以通过在泛型参数声明的位置添加该注解使用Kotlin编译器生成通配符形式的泛型参数（？extends ...)。 看下面这段代码： 1234567class Box&lt;out T&gt;(val value: T)interface Baseclass Derived : Basefun boxDerived(value: Derived): Box&lt;Derived&gt; = Box(value)fun unboxBase(box: Box&lt;Base&gt;): Base = box.value 按照正常思维，下面的两个方法转换到Java代码应该是这样： 12Box&lt;Derived&gt; boxDerived(Derived value) &#123; …… &#125;Base unboxBase(Box&lt;Base&gt; box) &#123; …… &#125; 但问题是，Kotlin泛型支持型变，在Kotlin中，我们可以这样写unboxBase(Box(Derived()))，而在Java语言中，泛型参数类型是不可变的，按照上面的写法显然已经做不到了。 正确转换到Java代码应该是这样： 1Base unboxBase(Box&lt;? extends Base&gt; box) &#123; …… &#125; 为了使这样的转换正确生成，我们需要在泛型参数的位置添加上面的注解: 1fun unboxBase(box: Box&lt;@JvmWildcard Base&gt;): Base = box.value @JvmSuppressWildcards这个注解的作用与@JvmWildcard恰恰相反，它是用来抑制通配符泛型参数的生成，即在不需要型变泛型参数的情况下，我们可以通过添加这个注解来避免生成型变泛型参数。 @JvmSuppressWildcardsKotlinJava1fun unboxBase(box: Box&lt;@JvmSuppressWildcards Base&gt;): Base = box.value12// 生成的代码相当于下面这段Java代码Base unboxBase(Box&lt;Base&gt; box) { …… } 正确使用上述注解，可以抹平Kotlin与Java泛型处理的差异，避免出现安全转换问题。 @Volatile @Transient这两个注解恰好对应Java端的两个关键字volatile与transient，前者主要用于解决多线程脏数据问题，后者用于标记序列化对象中不参与序列化的属性。 这两个注解比较简单，就不举例说明了。在遇到类似需要与Java互通的场景时，只需要将其关键字替换为该注解即可。 以上就是我们日常开发过程中能够遇到的所有注解了，在Kotlin 1.3版本中，还增加了一个新的注解@JvmDefault用于在接口中处理默认实现的方法。接口中允许有默认实现是从JDK 1.8版本开始的，为了兼容低版本JDK，Kotlin语言新增了该注解用于生成兼容性字节码，但该注解目前仍处于实验阶段，名称或行为均可能发生改变，建议大家先不要使用，推荐大家始终使用JDK 1.8及其以上版本。 最佳实践如果在工程中必须存在部分Java代码，为了实现完美调用，一定要谨慎并正确地使用上述注解。要充分理解Kotlin编译器与Java编译器生成的字节码差异。 如果是由于现存Java库仅兼容Java字节码，导致部分框架在遇到Kotlin语言生成的字节码时会出现解析错误，不能正常使用。这个时候要尝试检查是否需要通过上述注解矫正字节码的生成，使Java库能够正常使用。 如果是新工程，建议大家全部使用Kotlin代码，避免出现上述注解，减少阅读上的困难。目前，Kotlin版本已经非常稳定了，请大家放心使用。 阅读更多技术文章，请关注微信公众号”欧阳锋工作室“ 参与Kotlin技术讨论，请添加唯一官方QQ交流群：329673958]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Jvm</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10分钟看懂动态代理设计模式]]></title>
    <url>%2F2018%2F03%2F02%2Fdesign%20pattern%2F10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。 什么是代理从字面意思来看，代理比较好理解，无非就是代为处理的意思。举个例子，你在上大学的时候，总是喜欢逃课。因此，你拜托你的同学帮你答到，而自己却窝在宿舍玩游戏… 你的这个同学恰好就充当了代理的作用，代替你去上课。 是的，你没有看错，代理就是这么简单！ 理解了代理的意思，你脑海中恐怕还有两个巨大的疑问： 怎么实现代理模式 代理模式有什么实际用途 要理解这两个问题，看一个简单的例子：12345678910111213141516public interface Flyable &#123; void fly();&#125;public class Bird implements Flyable &#123; @Override public void fly() &#123; System.out.println("Bird is flying..."); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 很简单的一个例子，用一个随机睡眠时间模拟小鸟在空中的飞行时间。接下来问题来了，如果我要知道小鸟在天空中飞行了多久，怎么办？ 有人说，很简单，在Bird-&gt;fly()方法的开头记录起始时间，在方法结束记录完成时间，两个时间相减就得到了飞行时间。123456789101112@Override public void fly() &#123; long start = System.currentTimeMillis(); System.out.println("Bird is flying..."); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start)); &#125; 的确，这个方法没有任何问题，接下来加大问题的难度。如果Bird这个类来自于某个SDK（或者说Jar包）提供，你无法改动源码，怎么办？ 一定会有人说，我可以在调用的地方这样写：1234567public static void main(String[] args) &#123; Bird bird = new Bird(); long start = System.currentTimeMillis(); bird.fly(); long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start));&#125; 这个方案看起来似乎没有问题，但其实你忽略了准备这些方法所需要的时间，执行一个方法，需要开辟栈内存、压栈、出栈等操作，这部分时间也是不可以忽略的。因此，这个解决方案不可行。那么，还有什么方法可以做到呢？ a）使用继承继承是最直观的解决方案，相信你已经想到了，至少我最开始想到的解决方案就是继承。为此，我们重新创建一个类Bird2，在Bird2中我们只做一件事情，就是调用父类的fly方法，在前后记录时间，并打印时间差：123456789101112public class Bird2 extends Bird &#123; @Override public void fly() &#123; long start = System.currentTimeMillis(); super.fly(); long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start)); &#125;&#125; 这是一种解决方案，还有一种解决方案叫做：聚合，其实也是比较容易想到的。我们再次创建新类Bird3，在Bird3的构造方法中传入Bird实例。同时，让Bird3也实现Flyable接口，并在fly方法中调用传入的Bird实例的fly方法：1234567891011121314151617public class Bird3 implements Flyable &#123; private Bird bird; public Bird3(Bird bird) &#123; this.bird = bird; &#125; @Override public void fly() &#123; long start = System.currentTimeMillis(); bird.fly(); long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start)); &#125;&#125; 为了记录Bird-&gt;fly()方法的执行时间，我们在前后添加了记录时间的代码。同样地，通过这种方法我们也可以获得小鸟的飞行时间。那么，这两种方法孰优孰劣呢？咋一看，不好评判！ 继续深入思考，用问题推导来解答这个问题： 问题一：如果我还需要在fly方法前后打印日志，记录飞行开始和飞行结束，怎么办？有人说，很简单！继承Bird2并在在前后添加打印语句即可。那么，问题来了，请看问题二。 问题二：如果我需要调换执行顺序，先打印日志，再获取飞行时间，怎么办？有人说，再新建一个类Bird4继承Bird，打印日志。再新建一个类Bird5继承Bird4，获取方法执行时间。 问题显而易见：使用继承将导致类无限制扩展，同时灵活性也无法获得保障。那么，使用 聚合 是否可以避免这个问题呢？答案是：可以！但我们的类需要稍微改造一下。修改Bird3类，将聚合对象Bird类型修改为Flyable 1234567891011121314151617public class Bird3 implements Flyable &#123; private Flyable flyable; public Bird3(Flyable flyable) &#123; this.flyable = flyable; &#125; @Override public void fly() &#123; long start = System.currentTimeMillis(); flyable.fly(); long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start)); &#125;&#125; 为了让你看的更清楚，我将Bird3更名为BirdTimeProxy，即用于获取方法执行时间的代理的意思。同时我们新建BirdLogProxy代理类用于打印日志： 12345678910111213141516public class BirdLogProxy implements Flyable &#123; private Flyable flyable; public BirdLogProxy(Flyable flyable) &#123; this.flyable = flyable; &#125; @Override public void fly() &#123; System.out.println("Bird fly start..."); flyable.fly(); System.out.println("Bird fly end..."); &#125;&#125; 接下来神奇的事情发生了，如果我们需要先记录日志，再获取飞行时间，可以在调用的地方这么做： 1234567public static void main(String[] args) &#123; Bird bird = new Bird(); BirdLogProxy p1 = new BirdLogProxy(bird); BirdTimeProxy p2 = new BirdTimeProxy(p1); p2.fly();&#125; 反过来，可以这么做： 1234567public static void main(String[] args) &#123; Bird bird = new Bird(); BirdTimeProxy p2 = new BirdTimeProxy(bird); BirdLogProxy p1 = new BirdLogProxy(p2); p1.fly();&#125; 看到这里，有同学可能会有疑问了。虽然现象看起来，聚合可以灵活调换执行顺序。可是，为什么 聚合 可以做到，而继承不行呢。我们用一张图来解释一下： 静态代理接下来，观察上面的类BirdTimeProxy，在它的fly方法中我们直接调用了flyable-&gt;fly()方法。换而言之，BirdTimeProxy其实代理了传入的Flyable对象，这就是典型的静态代理实现。 从表面上看，静态代理已经完美解决了我们的问题。可是，试想一下，如果我们需要计算SDK中100个方法的运行时间，同样的代码至少需要重复100次，并且创建至少100个代理类。往小了说，如果Bird类有多个方法，我们需要知道其他方法的运行时间，同样的代码也至少需要重复多次。因此，静态代理至少有以下两个局限性问题： 如果同时代理多个类，依然会导致类无限制扩展 如果类中有多个方法，同样的逻辑需要反复实现 那么，我们是否可以使用同一个代理类来代理任意对象呢？我们以获取方法运行时间为例，是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢？甚至再大胆一点，代理的逻辑也可以自己指定。比如，获取方法的执行时间，打印日志，这类逻辑都可以自己指定。这就是本文重点探讨的问题，也是最难理解的部分：动态代理。 动态代理继续回到上面这个问题：是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢。 这个部分需要一定的抽象思维，我想，你脑海中的第一个解决方案应该是使用反射。反射是用于获取已创建实例的方法或者属性，并对其进行调用或者赋值。很明显，在这里，反射解决不了问题。但是，再大胆一点，如果我们可以动态生成TimeProxy这个类，并且动态编译。然后，再通过反射创建对象并加载到内存中，不就实现了对任意对象进行代理了吗？为了防止你依然一头雾水，我们用一张图来描述接下来要做什么： 动态生成Java源文件并且排版是一个非常繁琐的工作，为了简化操作，我们使用 JavaPoet 这个第三方库帮我们生成TimeProxy的源码。希望 JavaPoet 不要成为你的负担，不理解 JavaPoet 没有关系，你只要把它当成一个Java源码生成工具使用即可。 PS：你记住，任何工具库的使用都不会太难，它是为了简化某些操作而出现的，目标是简化而不是繁琐。因此，只要你适应它的规则就轻车熟路了。 第一步：生成TimeProxy源码12345678910111213141516171819202122232425262728293031323334353637383940public class Proxy &#123; public static Object newProxyInstance() throws IOException &#123; TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder("TimeProxy") .addSuperinterface(Flyable.class); FieldSpec fieldSpec = FieldSpec.builder(Flyable.class, "flyable", Modifier.PRIVATE).build(); typeSpecBuilder.addField(fieldSpec); MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(Flyable.class, "flyable") .addStatement("this.flyable = flyable") .build(); typeSpecBuilder.addMethod(constructorMethodSpec); Method[] methods = Flyable.class.getDeclaredMethods(); for (Method method : methods) &#123; MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .returns(method.getReturnType()) .addStatement("long start = $T.currentTimeMillis()", System.class) .addCode("\n") .addStatement("this.flyable." + method.getName() + "()") .addCode("\n") .addStatement("long end = $T.currentTimeMillis()", System.class) .addStatement("$T.out.println(\"Fly Time =\" + (end - start))", System.class) .build(); typeSpecBuilder.addMethod(methodSpec); &#125; JavaFile javaFile = JavaFile.builder("com.youngfeng.proxy", typeSpecBuilder.build()).build(); // 为了看的更清楚，我将源码文件生成到桌面 javaFile.writeTo(new File("/Users/ouyangfeng/Desktop/")); return null; &#125;&#125; 在main方法中调用Proxy.newProxyInstance()，你将看到桌面已经生成了TimeProxy.java文件，生成的内容如下： 12345678910111213141516171819202122package com.youngfeng.proxy;import java.lang.Override;import java.lang.System;class TimeProxy implements Flyable &#123; private Flyable flyable; public TimeProxy(Flyable flyable) &#123; this.flyable = flyable; &#125; @Override public void fly() &#123; long start = System.currentTimeMillis(); this.flyable.fly(); long end = System.currentTimeMillis(); System.out.println("Fly Time =" + (end - start)); &#125;&#125; 第二步：编译TimeProxy源码编译TimeProxy源码我们直接使用JDK提供的编译工具即可，为了使你看起来更清晰，我使用一个新的辅助类来完成编译操作： 1234567891011public class JavaCompiler &#123; public static void compile(File javaFile) throws IOException &#123; javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null); Iterable iterable = fileManager.getJavaFileObjects(javaFile); javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable); task.call(); fileManager.close(); &#125;&#125; 在Proxy-&gt;newProxyInstance()方法中调用该方法，编译顺利完成： 123456// 为了看的更清楚，我将源码文件生成到桌面String sourcePath = "/Users/ouyangfeng/Desktop/";javaFile.writeTo(new File(sourcePath));// 编译JavaCompiler.compile(new File(sourcePath + "/com/youngfeng/proxy/TimeProxy.java")); 第三步：加载到内存中并创建对象123456URL[] urls = new URL[] &#123;new URL("file:/" + sourcePath)&#125;;URLClassLoader classLoader = new URLClassLoader(urls);Class clazz = classLoader.loadClass("com.youngfeng.proxy.TimeProxy");Constructor constructor = clazz.getConstructor(Flyable.class);Flyable flyable = (Flyable) constructor.newInstance(new Bird());flyable.fly(); 通过以上三个步骤，我们至少解决了下面两个问题： 不再需要手动创建TimeProxy 可以代理任意实现了Flyable接口的类对象，并获取接口方法的执行时间 可是，说好的任意对象呢？ 第四步：增加InvocationHandler接口查看Proxy-&gt;newProxyInstance()的源码，代理类继承的接口我们是写死的，为了增加灵活性，我们将接口类型作为参数传入： 接口的灵活性问题解决了，TimeProxy的局限性依然存在，它只能用于获取方法的执行时间，而如果要在方法执行前后打印日志则需要重新创建一个代理类，显然这是不妥的！ 为了增加控制的灵活性，我们考虑针将代理的处理逻辑也抽离出来（这里的处理就是打印方法的执行时间）。新增InvocationHandler接口，用于处理自定义逻辑： 123public interface InvocationHandler &#123; void invoke(Object proxy, Method method, Object[] args);&#125; 想象一下，如果客户程序员需要对代理类进行自定义的处理，只要实现该接口，并在invoke方法中进行相应的处理即可。这里我们在接口中设置了三个参数（其实也是为了和JDK源码保持一致）： proxy =&gt; 这个参数指定动态生成的代理类，这里是TimeProxy method =&gt; 这个参数表示传入接口中的所有Method对象 args =&gt; 这个参数对应当前method方法中的参数 引入了InvocationHandler接口之后，我们的调用顺序应该变成了这样： 12345MyInvocationHandler handler = new MyInvocationHandler();Flyable proxy = Proxy.newProxyInstance(Flyable.class, handler);proxy.fly();方法执行流：proxy.fly() =&gt; handler.invoke() 为此，我们需要在Proxy.newProxyInstance()方法中做如下改动： 在newProxyInstance方法中传入InvocationHandler 在生成的代理类中增加成员变量handler 在生成的代理类方法中，调用invoke方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 public static Object newProxyInstance(Class inf, InvocationHandler handler) throws Exception &#123; TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder("TimeProxy") .addModifiers(Modifier.PUBLIC) .addSuperinterface(inf); FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, "handler", Modifier.PRIVATE).build(); typeSpecBuilder.addField(fieldSpec); MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(InvocationHandler.class, "handler") .addStatement("this.handler = handler") .build(); typeSpecBuilder.addMethod(constructorMethodSpec); Method[] methods = inf.getDeclaredMethods(); for (Method method : methods) &#123; MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .returns(method.getReturnType()) .addCode("try &#123;\n") .addStatement("\t$T method = " + inf.getName() + ".class.getMethod(\"" + method.getName() + "\")", Method.class) // 为了简单起见，这里参数直接写死为空 .addStatement("\tthis.handler.invoke(this, method, null)") .addCode("&#125; catch(Exception e) &#123;\n") .addCode("\te.printStackTrace();\n") .addCode("&#125;\n") .build(); typeSpecBuilder.addMethod(methodSpec); &#125; JavaFile javaFile = JavaFile.builder("com.youngfeng.proxy", typeSpecBuilder.build()).build(); // 为了看的更清楚，我将源码文件生成到桌面 String sourcePath = "/Users/ouyangfeng/Desktop/"; javaFile.writeTo(new File(sourcePath)); // 编译 JavaCompiler.compile(new File(sourcePath + "/com/youngfeng/proxy/TimeProxy.java")); // 使用反射load到内存 URL[] urls = new URL[] &#123;new URL("file:" + sourcePath)&#125;; URLClassLoader classLoader = new URLClassLoader(urls); Class clazz = classLoader.loadClass("com.youngfeng.proxy.TimeProxy"); Constructor constructor = clazz.getConstructor(InvocationHandler.class); Object obj = constructor.newInstance(handler); return obj;&#125; 上面的代码你可能看起来比较吃力，我们直接调用该方法，查看最后生成的源码。在main方法中测试newProxyInstance查看生成的TimeProxy源码： 测试代码 1Proxy.newProxyInstance(Flyable.class, new MyInvocationHandler(new Bird())); 生成的TimeProxy.java源码 12345678910111213141516171819202122package com.youngfeng.proxy;import java.lang.Override;import java.lang.reflect.Method;public class TimeProxy implements Flyable &#123; private InvocationHandler handler; public TimeProxy(InvocationHandler handler) &#123; this.handler = handler; &#125; @Override public void fly() &#123; try &#123; Method method = com.youngfeng.proxy.Flyable.class.getMethod("fly"); this.handler.invoke(this, method, null); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; MyInvocationHandler.java 1234567891011121314151617181920212223public class MyInvocationHandler implements InvocationHandler &#123; private Bird bird; public MyInvocationHandler(Bird bird) &#123; this.bird = bird; &#125; @Override public void invoke(Object proxy, Method method, Object[] args) &#123; long start = System.currentTimeMillis(); try &#123; method.invoke(bird, new Object[] &#123;&#125;); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println("Fly time = " + (end - start)); &#125;&#125; 至此，整个方法栈的调用栈变成了这样： 看到这里，估计很多同学已经晕了，在静态代理部分，我们在代理类中传入了被代理对象。可是，使用newProxyInstance生成动态代理对象的时候，我们居然不再需要传入被代理对象了。我们传入了的实际对象是InvocationHandler实现类的实例，这看起来有点像生成了InvocationHandler的代理对象，在动态生成的代理类的任意方法中都会间接调用InvocationHandler-&gt;invoke(proxy, method, args)方法。 其实的确是这样。TimeProxy真正代理的对象就是InvocationHandler，不过这里设计的巧妙之处在于，InvocationHandler是一个接口，真正的实现由用户指定。另外，在每一个方法执行的时候，invoke方法都会被调用 ，这个时候如果你需要对某个方法进行自定义逻辑处理，可以根据method的特征信息进行判断分别处理。 如何使用上面这段解释是告诉你在执行Proxy-&gt;newProxyInstance方法的时候真正发生的事情，而在实际使用过程中你完全可以忘掉上面的解释。按照设计者的初衷，我们做如下简单归纳： Proxy-&gt;newProxyInstance(infs, handler) 用于生成代理对象 InvocationHandler：这个接口主要用于自定义代理逻辑处理 为了完成对被代理对象的方法拦截，我们需要在InvocationHandler对象中传入被代理对象实例。 查看上面的代码，你可以看到我将Bird实例已经传入到了MyInvocationHandler中，原因就是第三点。 这样设计有什么好处呢？有人说，我们大费周章，饶了一大圈，最终变成了这个样子，到底图什么呢？ 想象一下，到此为止，如果我们还需要对其它任意对象进行代理，是否还需要改动newProxyInstance方法的源码，答案是：完全不需要！ 只要你在newProxyInstance方法中指定代理需要实现的接口，指定用于自定义处理的InvocationHandler对象，整个代理的逻辑处理都在你自定义的InvocationHandler实现类中进行处理。至此，而我们终于可以从不断地写代理类用于实现自定义逻辑的重复工作中解放出来了，从此需要做什么，交给InvocationHandler。 事实上，我们之前给自己定下的目标“使用同一个类来计算任意对象的任一方法的执行时间”已经实现了。严格来说，是我们超额完成了任务，TimeProxy不仅可以计算方法执行的时间，也可以打印方法执行日志，这完全取决于你的InvocationHandler接口实现。因此，这里取名为TimeProxy其实已经不合适了。我们可以修改为和JDK命名一致，即$Proxy0，感兴趣的同学请自行实践，本篇文章的代码将放到我的Github仓库，文章结尾会给出代码地址。 JDK实现揭秘通过上面的这些步骤，我们完成了一个简易的仿JDK实现的动态代理逻辑。接下来，我们一起来看一看JDK实现的动态代理和我们到底有什么不同。 Proxy.java InvocationHandler 可以看到，官方版本Proxy类提供的方法多一些，而我们主要使用的接口newProxyInstance参数也和我们设计的不太一样。这里给大家简单解释一下，每个参数的意义： Classloader：类加载器，你可以使用自定义的类加载器，我们的实现版本为了简化，直接在代码中写死了Classloader。 Class&lt;?&gt;[]：第二个参数也和我们的实现版本不一致，这个其实很容易理解，我们应该允许我们自己实现的代理类同时实现多个接口。前面设计只传入一个接口，只是为了简化实现，让你专注核心逻辑实现而已。 最后一个参数就不用说了，和我们实现的版本完全是一样的。 仔细观察官方版本的InvocationHandler，它和我们自己的实现的版本也有一个细微的差别：官方版本invoke方法有返回值，而我们的版本中是没有返回值的。那么，返回值到底有什么作用呢？直接来看官方文档： 核心思想：这里的返回值类型必须和传入接口的返回值类型一致，或者与其封装对象的类型一致。 遗憾的是，这里并没有说明返回值的用途，其实这里稍微发挥一下想象力就知道了。在我们的版本实现中，Flyable接口的所有方法都是没有返回值的，问题是，如果有返回值呢？是的，你没有猜错，这里的invoke方法对应的就是传入接口中方法的返回值。 答疑解惑invoke方法的第一个参数proxy到底有什么作用？这个问题其实也好理解，如果你的接口中有方法需要返回自身，如果在invoke中没有传入这个参数，将导致实例无法正常返回。在这种场景中，proxy的用途就表现出来了。简单来说，这其实就是最近非常火的链式编程的一种应用实现。 动态代理到底有什么用？学习任何一门技术，一定要问一问自己，这到底有什么用。其实，在这篇文章的讲解过程中，我们已经说出了它的主要用途。你发现没，使用动态代理我们居然可以在不改变源码的情况下，直接在方法中插入自定义逻辑。这有点不太符合我们的一条线走到底的编程逻辑，这种编程模型有一个专业名称叫 AOP。所谓的AOP，就像刀一样，抓住时机，趁机插入。 基于这样一种动态特性，我们可以用它做很多事情，例如： 事务提交或回退（Web开发中很常见） 权限管理 自定义缓存逻辑处理 SDK Bug修复… 如果你阅读过 Android_Slide_To_Close 的源码会发现，它也在某个地方使用了动态代理设计模式。 总结到此为止，关于动态代理的所有讲解已经结束了，原谅我使用了一个诱导性的标题“骗”你进来阅读这篇文章。如果你不是一个久经沙场的“老司机”，10分钟完全看懂动态代理设计模式还是有一定难度的。但即使没有看懂也没关系，如果你在第一次阅读完这篇文章后依然一头雾水，就不妨再仔细阅读一次。在阅读的过程中，一定要跟着文章思路去敲代码。反反复复，一定会看懂的。我在刚刚学习动态代理设计模式的时候就反复看了不下5遍，并且亲自敲代码实践了多次。 为了让你少走弯路，我认为看懂这篇文章，你至少需要学习以下知识点： 至少已经理解了面向对象语言的多态特性 了解简单的反射用法 会简单使用 JavaPoet 生成Java源码 如果你在阅读文章的过程中，有任何不理解的问题或者建议，欢迎在文章下方留言告诉我！ 本篇文章例子代码：https://github.com/yuanhoujun/java-dynamic-proxy 我是欧阳锋，设计模式是一种非常好的编程指导模型，它在所有编程语言中是通用的，并且是亘古不变的。我建议你在这个方面多下苦功，不要纠结在一些重复的劳动中，活用设计模式会让你的代码更显灵动。想要了解我吗？看这里：欧阳锋档案馆。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
</search>
