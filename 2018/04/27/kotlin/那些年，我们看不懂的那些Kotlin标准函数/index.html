
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="欧阳锋工作室">
    <title>那些年，我们看不懂的那些Kotlin标准函数 - 欧阳锋工作室</title>
    <meta name="author" content="欧阳锋工作室">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"欧阳锋工作室","sameAs":["https://github.com/yuanhoujun","assets/images/mpwexin.jpg","https://weibo.com/u/6140262139?is_all=1","mailto:ouyangfeng2016@gmail.com"],"image":"avatar.jpeg"},"articleBody":"\nKotlin标准库中提供了一套用于常用操作的函数。最近，在我的Kotlin交流群中有人再次问到了关于这些函数的用法。今天，让我们花一点时间，一起看一下这些函数的用法。\n\nReady go &gt;&gt;&gt;注：这里所说的标准函数主要来自于标准库中在文件Standard.kt中的所有函数。\nrun#11234567@kotlin.internal.InlineOnlypublic inline fun &lt;R&gt; run(block: () -&gt; R): R &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    return block()&#125;\ncontract部分主要用于编译器上下文推断，这里我们忽略掉这部分代码。\n观察源码发现，run方法仅仅是执行传入的block表达式并返回执行结果而已（block是一个lambda表达式）。\n因此，如果你仅仅需要执行一个代码块，可以使用该函数\n看一个例子：\n123456789val x = run &#123;           println(&quot;Hello, world&quot;)           return@run 1        &#125;println(x)// 执行结果Hello，world1\nrun#21234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    return block()&#125;\n这个函数跟上面的函数功能是完全一样的。不同的是，block的receiver是当前调用对象，即在block中可以使用当前对象的上下文。\n因此，如果你需要在执行的lambda表达式中使用当前对象的上下文的话，可以使用该函数。除此之外，两者没有任何差别\n看一个例子：\n1234567891011121314151617181920212223class A &#123;    fun sayHi(name: String) &#123;        println(&quot;Hello, $name&quot;)    &#125;&#125;class B &#123;&#125;fun main(args: Array&lt;String&gt;) &#123;    val a = A()    val b = a.run &#123;        // 这里你可以使用A的上下文        a.sayHi(&quot;Scott Smith&quot;)        return@run B()    &#125;    println(b)&#125;// 执行结果Hello，Scott Smithb@2314\n从例子中，我们可以看到，这个函数还可以用于对数据类型进行转换。\nwith1234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    return receiver.block()&#125;\n这个函数其实和run函数也是做了一样的事情。不同的是，这里可以指定block的接收者。\n因此，如果你在执行lambda表达式的时候，希望指定不同的接收者的话，可以使用该方法\n1234567891011121314class A &#123;    fun sayHi(name: String) &#123;        println(&quot;Hello, $name&quot;)    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val a = A()    with(a) &#123;        // 这里的接收者是对象a，因此可以调用a实例的所有方法        sayHi(&quot;Scott Smith&quot;)    &#125;&#125;\napply12345678@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    block()    return this&#125;\n可以看到，这个方法是针对泛型参数的扩展方法，即所有对象都将拥有该扩展方法。相对于run#2方法，apply不仅执行了block，同时还返回了receiver本身。\n这在链式编程中很常用，如果你希望执行lambda表达式的同时而不破坏链式编程，可以使用该方法\n看一个例子：\n1234567891011121314151617181920212223class A &#123;    fun sayHi(name: String) &#123;        println(&quot;Hello, $name&quot;)    &#125;        fun other() &#123;        println(&quot;Other function...&quot;)    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val a = A()    a.apply &#123;         println(&quot;This is a block&quot;)        sayHi(&quot;Scott Smith&quot;)    &#125;.other()&#125;// 执行结果This is a blockHello, Scott SmithOther function...\nalso123456789@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    block(this)    return this&#125;\n这个函数跟with又很像，不同的是，block带有一个当前receiver类型的参数。在block中，你可以使用该参数对当前实例进行操作。\n这个函数和with完全可以互相通用，with函数可以直接在当前实例上下文中对其进行操作，而also函数要通过block参数获取当前类实例。因为用法完全一致，这里就不举例了\nlet1234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    return block(this)&#125;\n如果你使用过RxJava，可能会感到似曾相识，这其实就是RxJava的map函数。这个函数也是针对泛型参数的扩展函数，所有类都将拥有这个扩展函数。\n如果你希望对当前数据类型进行一定的转换，可以使用该方法。该方法的block中同样可以使用当前receiver的上下文\n看一个例子：\n12345678910111213141516class Triangle &#123;&#125;class Rectangle &#123;&#125;fun main(args: Array&lt;String&gt;) &#123;    val tr = Triangle()    val rect = tr.let &#123; it -&gt;        println(&quot;It is $it&quot;)        return@let Rectangle()    &#125;    println(rect)&#125;// 执行结果It is Triangle@78308db1Rectangle@27c170f0\n从例子中可以看到，我们成功地将三角形转换成了矩形，这就是let函数的作用。\ntakeIf12345678@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? &#123;    contract &#123;        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)    &#125;    return if (predicate(this)) this else null&#125;\n这个函数也是针对泛型参数的扩展函数，所有类都将拥有这个扩展。这个函数使用了一个预言函数作为参数，主要用于判断当前对象是否符合条件。这个条件函数由你指定。如果条件符合，将返回当前对象。否则返回空值。\n因此，如果你希望筛选集合中某个数据是否符合要求，可以使用这个函数\n看一个例子：\n1234567891011fun main(args: Array&lt;String&gt;) &#123;    val arr = listOf(1, 2, 3)    arr.forEach &#123;        println(&quot;$it % 2 == 0 =&gt; $&#123;it.takeIf &#123; it % 2 == 0 &#125;&#125;&quot;)    &#125;&#125;// 执行结果1 % 2 == 0 =&gt; null2 % 2 == 0 =&gt; 23 % 2 == 0 =&gt; null\ntakeUnless12345678@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? &#123;    contract &#123;        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)    &#125;    return if (!predicate(this)) this else null&#125;\n这个函数刚好与takeIf筛选逻辑恰好相反。即：如果符合条件返回null，不符合条件返回对象本身。\n看一个例子：\n1234567891011fun main(args: Array&lt;String&gt;) &#123;    val arr = listOf(1, 2, 3)    arr.forEach &#123;        println(&quot;$it % 2 == 0 =&gt; $&#123;it.takeUnless &#123; it % 2 == 0 &#125;&#125;&quot;)    &#125;&#125;// 执行结果1 % 2 == 0 =&gt; 12 % 2 == 0 =&gt; null3 % 2 == 0 =&gt; 3\n看到了吗？这里的执行结果和takeIf恰好相反。\nrepeat12345678@kotlin.internal.InlineOnlypublic inline fun repeat(times: Int, action: (Int) -&gt; Unit) &#123;    contract &#123; callsInPlace(action) &#125;    for (index in 0 until times) &#123;        action(index)    &#125;&#125;\n这个函数意思很明显，就是将一个动作重复指定的次数。动作对应一个lambda表达式，表达式中持有一个参数表示当前正在执行的次数索引。\n看一个例子：\n123456789fun main(args: Array&lt;String&gt;) &#123;    repeat(3) &#123;        println(&quot;Just repeat, index: $it&quot;)    &#125;&#125;Just repeat, index: 0Just repeat, index: 1Just repeat, index: 2\n简单总结最后，我们用一个表格简单总结一下这些函数的用法：函数|用途|特点|形式:—:|:—:|:—:|:—:run#1|执行block，并返回执行结果|block中无法获取接收者上下文|全局函数run#2|执行block，并返回执行结果|block中可以获取接收者上下文|扩展函数with|指定接收者，通过接收者执行block|block中可以获取接收者的上下文，可以对接收者数据类型做一定转换|全局函数apply|执行block，并返回接收者实例本身|block中可以获取接收者的上下文，可用于链式编程|扩展also|执行block，并返回接收者实例本身|block中有一个参数代表接收者实例，可用于链式编程|扩展let|执行block，并返回执行结果|block中有一个参数代表接收者实例，可以对接收者数据类型做一定转换|扩展takeIf|根据条件predicate判断当前实例是否符合要求|如果符合要求，返回当前实例本身；否则返回null|扩展函数takeUnless|根据条件predicate判断当前实例是否不符合要求|如果不符合要求，返回当前实例本身；否则返回null|扩展\n搞定Receiver理解上面这几个函数，最重要的一点是要理解Receiver。遗憾的是，Kotlin官方文档中并没有针对Receiver的详细讲解。关于这部分的讲解，请扫描下方二维码关注欧阳锋工作室，回复搞定Receiver查看文章。\n欢迎加入Kotlin交流群关于Kotlin，如果你有任何问题，欢迎加入我的Kotlin交流群： 329673958。当前群交流活跃，问题解答速度很快，期待你的加入。\n","dateCreated":"2018-04-27T15:21:00+08:00","dateModified":"2019-04-28T20:46:52+08:00","datePublished":"2018-04-27T15:21:00+08:00","description":"","headline":"那些年，我们看不懂的那些Kotlin标准函数","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/"},"publisher":{"@type":"Organization","name":"欧阳锋工作室","sameAs":["https://github.com/yuanhoujun","assets/images/mpwexin.jpg","https://weibo.com/u/6140262139?is_all=1","mailto:ouyangfeng2016@gmail.com"],"image":"avatar.jpeg","logo":{"@type":"ImageObject","url":"avatar.jpeg"}},"url":"http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/","keywords":"Kotlin, 编程语言"}</script>
    <meta name="description" content="Kotlin标准库中提供了一套用于常用操作的函数。最近，在我的Kotlin交流群中有人再次问到了关于这些函数的用法。今天，让我们花一点时间，一起看一下这些函数的用法。  Ready go &amp;gt;&amp;gt;&amp;gt;注：这里所说的标准函数主要来自于标准库中在文件Standard.kt中的所有函数。 run#11234567@kotlin.internal.InlineOnlypublic inlin">
<meta name="keywords" content="Kotlin,编程语言">
<meta property="og:type" content="blog">
<meta property="og:title" content="那些年，我们看不懂的那些Kotlin标准函数">
<meta property="og:url" content="http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/index.html">
<meta property="og:site_name" content="欧阳锋工作室">
<meta property="og:description" content="Kotlin标准库中提供了一套用于常用操作的函数。最近，在我的Kotlin交流群中有人再次问到了关于这些函数的用法。今天，让我们花一点时间，一起看一下这些函数的用法。  Ready go &amp;gt;&amp;gt;&amp;gt;注：这里所说的标准函数主要来自于标准库中在文件Standard.kt中的所有函数。 run#11234567@kotlin.internal.InlineOnlypublic inlin">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2019-04-28T12:46:52.219Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="那些年，我们看不懂的那些Kotlin标准函数">
<meta name="twitter:description" content="Kotlin标准库中提供了一套用于常用操作的函数。最近，在我的Kotlin交流群中有人再次问到了关于这些函数的用法。今天，让我们花一点时间，一起看一下这些函数的用法。  Ready go &amp;gt;&amp;gt;&amp;gt;注：这里所说的标准函数主要来自于标准库中在文件Standard.kt中的所有函数。 run#11234567@kotlin.internal.InlineOnlypublic inlin">
    
    
        
    
    
        <meta property="og:image" content="http://youngfeng.com/assets/images/avatar.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-n3h5fvwrba2ezx3jjewg1itrl3r4ognmb0rqhxoh9kr7ltfomtbpdedrggqw.min.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            欧阳锋工作室
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">欧阳锋工作室</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Stay hungry, stay foolish</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="首页"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="分类"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="标签"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="归档"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="搜索"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                            title="关于"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/yuanhoujun" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/assets/images/mpwexin.jpg"
                            title="微信公众号"
                        >
                    
                        <i class="sidebar-button-icon fab fa-weixin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微信公众号</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://weibo.com/u/6140262139?is_all=1" target="_blank" rel="noopener" title="微博">
                    
                        <i class="sidebar-button-icon fab fa-weibo" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微博</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:ouyangfeng2016@gmail.com" target="_blank" rel="noopener" title="邮箱">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            那些年，我们看不懂的那些Kotlin标准函数
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-04-27T15:21:00+08:00">
	
		    4月 27, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>, <a class="category-link" href="/categories/Kotlin/基础知识/">基础知识</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>Kotlin标准库中提供了一套用于常用操作的函数。最近，在我的Kotlin交流群中有人再次问到了关于这些函数的用法。今天，让我们花一点时间，一起看一下这些函数的用法。</p>
</blockquote>
<h1 id="Ready-go-gt-gt-gt"><a href="#Ready-go-gt-gt-gt" class="headerlink" title="Ready go &gt;&gt;&gt;"></a>Ready go &gt;&gt;&gt;</h1><p><strong>注：这里所说的标准函数主要来自于标准库中在文件Standard.kt中的所有函数。</strong></p>
<h3 id="run-1"><a href="#run-1" class="headerlink" title="run#1"></a>run#1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;R&gt; run(block: () -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>contract部分主要用于编译器上下文推断，这里我们忽略掉这部分代码。</p>
<p>观察源码发现，run方法仅仅是执行传入的block表达式并返回执行结果而已（block是一个lambda表达式）。</p>
<p><strong>因此，如果你仅仅需要执行一个代码块，可以使用该函数</strong></p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val x = run &#123;</span><br><span class="line">           println(&quot;Hello, world&quot;)</span><br><span class="line">           return@run 1</span><br><span class="line">        &#125;</span><br><span class="line">println(x)</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">Hello，world</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="run-2"><a href="#run-2" class="headerlink" title="run#2"></a>run#2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数跟上面的函数功能是完全一样的。不同的是，block的receiver是当前调用对象，即在block中可以使用当前对象的上下文。</p>
<p><strong>因此，如果你需要在执行的lambda表达式中使用当前对象的上下文的话，可以使用该函数。除此之外，两者没有任何差别</strong></p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    fun sayHi(name: String) &#123;</span><br><span class="line">        println(&quot;Hello, $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val a = A()</span><br><span class="line">    val b = a.run &#123;</span><br><span class="line">        // 这里你可以使用A的上下文</span><br><span class="line">        a.sayHi(&quot;Scott Smith&quot;)</span><br><span class="line">        return@run B()</span><br><span class="line">    &#125;</span><br><span class="line">    println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">Hello，Scott Smith</span><br><span class="line">b@2314</span><br></pre></td></tr></table></figure>
<p>从例子中，我们可以看到，这个函数还可以用于对数据类型进行转换。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数其实和run函数也是做了一样的事情。不同的是，这里可以指定block的接收者。</p>
<p><strong>因此，如果你在执行lambda表达式的时候，希望指定不同的接收者的话，可以使用该方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    fun sayHi(name: String) &#123;</span><br><span class="line">        println(&quot;Hello, $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val a = A()</span><br><span class="line">    with(a) &#123;</span><br><span class="line">        // 这里的接收者是对象a，因此可以调用a实例的所有方法</span><br><span class="line">        sayHi(&quot;Scott Smith&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个方法是针对泛型参数的扩展方法，即所有对象都将拥有该扩展方法。相对于run#2方法，apply不仅执行了block，同时还返回了receiver本身。</p>
<p><strong>这在链式编程中很常用，如果你希望执行lambda表达式的同时而不破坏链式编程，可以使用该方法</strong></p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    fun sayHi(name: String) &#123;</span><br><span class="line">        println(&quot;Hello, $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fun other() &#123;</span><br><span class="line">        println(&quot;Other function...&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val a = A()</span><br><span class="line">    a.apply &#123; </span><br><span class="line">        println(&quot;This is a block&quot;)</span><br><span class="line">        sayHi(&quot;Scott Smith&quot;)</span><br><span class="line">    &#125;.other()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">This is a block</span><br><span class="line">Hello, Scott Smith</span><br><span class="line">Other function...</span><br></pre></td></tr></table></figure>
<h3 id="also"><a href="#also" class="headerlink" title="also"></a>also</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">@SinceKotlin(&quot;1.1&quot;)</span><br><span class="line">public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(this)</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数跟with又很像，不同的是，block带有一个当前receiver类型的参数。在block中，你可以使用该参数对当前实例进行操作。</p>
<p><strong>这个函数和with完全可以互相通用，with函数可以直接在当前实例上下文中对其进行操作，而also函数要通过block参数获取当前类实例。因为用法完全一致，这里就不举例了</strong></p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return block(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用过RxJava，可能会感到似曾相识，这其实就是RxJava的map函数。这个函数也是针对泛型参数的扩展函数，所有类都将拥有这个扩展函数。</p>
<p><strong>如果你希望对当前数据类型进行一定的转换，可以使用该方法。该方法的block中同样可以使用当前receiver的上下文</strong></p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Triangle &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle &#123;&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val tr = Triangle()</span><br><span class="line">    val rect = tr.let &#123; it -&gt;</span><br><span class="line">        println(&quot;It is $it&quot;)</span><br><span class="line">        return@let Rectangle()</span><br><span class="line">    &#125;</span><br><span class="line">    println(rect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">It is Triangle@78308db1</span><br><span class="line">Rectangle@27c170f0</span><br></pre></td></tr></table></figure>
<p>从例子中可以看到，我们成功地将三角形转换成了矩形，这就是let函数的作用。</p>
<h3 id="takeIf"><a href="#takeIf" class="headerlink" title="takeIf"></a>takeIf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">@SinceKotlin(&quot;1.1&quot;)</span><br><span class="line">public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return if (predicate(this)) this else null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数也是针对泛型参数的扩展函数，所有类都将拥有这个扩展。这个函数使用了一个预言函数作为参数，主要用于判断当前对象是否符合条件。<br>这个条件函数由你指定。如果条件符合，将返回当前对象。否则返回空值。</p>
<p><strong>因此，如果你希望筛选集合中某个数据是否符合要求，可以使用这个函数</strong></p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val arr = listOf(1, 2, 3)</span><br><span class="line">    arr.forEach &#123;</span><br><span class="line">        println(&quot;$it % 2 == 0 =&gt; $&#123;it.takeIf &#123; it % 2 == 0 &#125;&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">1 % 2 == 0 =&gt; null</span><br><span class="line">2 % 2 == 0 =&gt; 2</span><br><span class="line">3 % 2 == 0 =&gt; null</span><br></pre></td></tr></table></figure>
<h3 id="takeUnless"><a href="#takeUnless" class="headerlink" title="takeUnless"></a>takeUnless</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">@SinceKotlin(&quot;1.1&quot;)</span><br><span class="line">public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return if (!predicate(this)) this else null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数刚好与takeIf筛选逻辑恰好相反。即：如果符合条件返回null，不符合条件返回对象本身。</p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val arr = listOf(1, 2, 3)</span><br><span class="line">    arr.forEach &#123;</span><br><span class="line">        println(&quot;$it % 2 == 0 =&gt; $&#123;it.takeUnless &#123; it % 2 == 0 &#125;&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行结果</span><br><span class="line">1 % 2 == 0 =&gt; 1</span><br><span class="line">2 % 2 == 0 =&gt; null</span><br><span class="line">3 % 2 == 0 =&gt; 3</span><br></pre></td></tr></table></figure>
<p>看到了吗？这里的执行结果和takeIf恰好相反。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun repeat(times: Int, action: (Int) -&gt; Unit) &#123;</span><br><span class="line">    contract &#123; callsInPlace(action) &#125;</span><br><span class="line"></span><br><span class="line">    for (index in 0 until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数意思很明显，就是将一个动作重复指定的次数。动作对应一个lambda表达式，表达式中持有一个参数表示当前正在执行的次数索引。</p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    repeat(3) &#123;</span><br><span class="line">        println(&quot;Just repeat, index: $it&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Just repeat, index: 0</span><br><span class="line">Just repeat, index: 1</span><br><span class="line">Just repeat, index: 2</span><br></pre></td></tr></table></figure>
<h1 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h1><p>最后，我们用一个表格简单总结一下这些函数的用法：<br>函数|用途|特点|形式<br>:—:|:—:|:—:|:—:<br>run#1|执行block，并返回执行结果|block中无法获取接收者上下文|全局函数<br>run#2|执行block，并返回执行结果|block中可以获取接收者上下文|扩展函数<br>with|指定接收者，通过接收者执行block|block中可以获取接收者的上下文，可以对接收者数据类型做一定转换|全局函数<br>apply|执行block，并返回接收者实例本身|block中可以获取接收者的上下文，可用于链式编程|扩展<br>also|执行block，并返回接收者实例本身|block中有一个参数代表接收者实例，可用于链式编程|扩展<br>let|执行block，并返回执行结果|block中有一个参数代表接收者实例，可以对接收者数据类型做一定转换|扩展<br>takeIf|根据条件predicate判断当前实例是否符合要求|如果符合要求，返回当前实例本身；否则返回null|扩展函数<br>takeUnless|根据条件predicate判断当前实例是否不符合要求|如果不符合要求，返回当前实例本身；否则返回null|扩展</p>
<h1 id="搞定Receiver"><a href="#搞定Receiver" class="headerlink" title="搞定Receiver"></a>搞定Receiver</h1><p>理解上面这几个函数，最重要的一点是要理解Receiver。遗憾的是，Kotlin官方文档中并没有针对Receiver的详细讲解。关于这部分的讲解，请扫描下方二维码关注<strong>欧阳锋工作室</strong>，回复<strong>搞定Receiver</strong>查看文章。</p>
<h1 id="欢迎加入Kotlin交流群"><a href="#欢迎加入Kotlin交流群" class="headerlink" title="欢迎加入Kotlin交流群"></a>欢迎加入Kotlin交流群</h1><p>关于Kotlin，如果你有任何问题，欢迎加入我的Kotlin交流群： 329673958。当前群交流活跃，问题解答速度很快，期待你的加入。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Kotlin/">Kotlin</a> <a class="tag tag--primary tag--small t-link" href="/tags/编程语言/">编程语言</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/07/09/kotlin/2018最新Kotlin基础视频教程上线了/"
                    data-tooltip="2018最新Kotlin基础视频教程上线了"
                    aria-label="上一篇: 2018最新Kotlin基础视频教程上线了"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/04/27/kotlin/测测你的Kotlin基础/"
                    data-tooltip="测测你的Kotlin基础"
                    aria-label="下一篇: 测测你的Kotlin基础"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/&amp;title=那些年，我们看不懂的那些Kotlin标准函数"
                    title="分享到 QQ"
                    aria-label="分享到 QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/"
                    title="分享到 Qzone"
                    aria-label="分享到 Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="KPSM" sourceid="2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/" appid="kp0000QPGPNP83"></div>
<script type="text/javascript" src="https://cdn.kuaiping.yhdm360.com/pub/common/js/kp.js"></script>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 欧阳锋工作室. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/07/09/kotlin/2018最新Kotlin基础视频教程上线了/"
                    data-tooltip="2018最新Kotlin基础视频教程上线了"
                    aria-label="上一篇: 2018最新Kotlin基础视频教程上线了"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/04/27/kotlin/测测你的Kotlin基础/"
                    data-tooltip="测测你的Kotlin基础"
                    aria-label="下一篇: 测测你的Kotlin基础"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/&amp;title=那些年，我们看不懂的那些Kotlin标准函数"
                    title="分享到 QQ"
                    aria-label="分享到 QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/"
                    title="分享到 Qzone"
                    aria-label="分享到 Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://connect.qq.com/widget/shareqq/index.html?url=http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/&amp;title=那些年，我们看不懂的那些Kotlin标准函数"
                        aria-label="分享到 QQ"
                    >
                        <i class="fab fa-qq" aria-hidden="true"></i><span>分享到 QQ</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://youngfeng.com/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/"
                        aria-label="分享到 Qzone"
                    >
                        <i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
            <h4 id="about-card-name">欧阳锋工作室</h4>
        
            <div id="about-card-bio"><p>Stay hungry, stay foolish</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>深圳一行代码科技有限公司创始人</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                广东深圳
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-uxpinu5umcabfr9aiy0uhzftnioszmvauq3qgkh8evzewnqgit0fhssjlsfq.min.js"></script>
<!--SCRIPTS END-->


    




    </body>
</html>
